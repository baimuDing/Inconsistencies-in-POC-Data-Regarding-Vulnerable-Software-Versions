{
    "text": "Date: Tue, 11 May 2021 12:01:24 +0300 ， From: Nadav Markus <nmarkus@.oaltonetworks.com> ， To: oss-security@.ts.openwall.com ， Cc: Or Cohen <orcohen@.oaltonetworks.com> ， Subject: CVE-2021-23134: Linux kernel: UAF in nfc sockets ， Hello, ， This is an announcement about CVE-2021-23134. This is a vulnerability ， in the linux kernel that we found in the implementation of nfc sockets ， (in net/nfc/llcp_sock.c). This can lead to kernel privilege escalation ， The patch can be found here: ， https:/git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=c61760e6940d ， =*=*=*=*=*=*=*=*= VULNERABILITY DETAILS =*=*=*=*=*=*=*=*= ， All of the code figures are from kernel version 5.11. ， A recent bug fix to a refcount leak in llcp_sock_connect was issued to ， the linux kernel, with the following code changes (targeting an issue ， that was named CVE-2020-25670): ， net/nfc/llcp_sock.c | 2 + ， 1 file changed, 2 insertions(+) ， diff -git a/net/nfc/llcp_sock.c b/net/nfc/llcp_sock.c ， index d257ed3b732a.68832ee4b9f8 100644 ， - a/net/nfc/llcp_sock.c ， + b/net/nfc/llcp_sock.c ， @ -108,11 +108,13 @ static int llcp_sock_bind(struct socket *sock, ， struct sockaddr *addr, int alen) ， llcp_sock->service_name_len, ， GFP_KERNEL); ， + nfc_llcp_local_put(llcp_sock->local); ， ret = -ENOMEM; ， goto put_dev; ， } ， llcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock); ， + nfc_llcp_local_put(llcp_sock->local); ， kfree(llcp_sock->service_name); ， llcp_sock->service_name = NULL; ， ret = -EADDRINUSE; ， The original patch notes says: ， ` ， nfc_llcp_local_get() is invoked in llcp_sock_bind(), ， but nfc_llcp_local_put() is not invoked in subsequent failure branches. ， As a result, refcount leakage occurs. ， To fix it, add calling nfc_llcp_local_put(). ， ` ， However, this fix causes a UAF under certain conditions. Specifically, ， there is another location where nfc_llcp_local_put is called with ， llcp_sock->local - the destructor of the socket: ， void nfc_llcp_sock_free(struct nfc_llcp_sock *sock) ， { ， kfree(sock->service_name); ， skb_queue_purge(&sock->tx_queue); ， skb_queue_purge(&sock->tx_pending_queue); ， list_del_init(&sock->accept_queue); ， sock->parent = NULL; ， nfc_llcp_local_put(sock->local); ， } ， Note that the 'local' field (of type nfc_llcp_local) is acquired from ， a global per device list, via the function nfc_llcp_find_local. So if ， we can fail the nfc_llcp_get_sdp_ssap for example, the global object ， will get its reference count increased only once (via the ， nfc_llcp_local_get function), but it will be freed twice (once in the ， failure branch in bind, and another time in the destructor of the ， socket when the last fd to it is closed). ， Our reproducer program looks like this:"
}