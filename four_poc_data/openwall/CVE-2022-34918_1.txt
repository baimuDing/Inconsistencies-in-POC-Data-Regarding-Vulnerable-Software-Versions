{
    "text": "Cc : Hugues ANGUELKOV <hanguelkov @ .dorisec.fr> ， Subject : Re : Linux kernel : Netfilter heap buffer overflow in ， nft_set_elem_init ， Hi ,  ， Mitre has assigned CVE-2022-34918 to this issue. ， Ciao , Marcus ， On Sat , Jul 02 , 2022 at 09 : 37 : 46PM +0200 , Solar Designer wrote :  ， > Hi ,  ， > The message below was meant to start an embargo for the issue , but it ， > was CC'ed to netfilter-devel , which is a public mailing list , so it also ， > appears here :  ， > https : /lore.kernel.org/netfilter-devel/cd9428b6-7ffb-dd22-d949-d86f4869f452 @ randorisec.fr/T/ # u ， > In fact , I am forwarding a copy as downloaded from \"lore\" , but of course ， > it looks identical to what reached linux-distros. ， > Alexander ， > - Forwarded message from Hugues ANGUELKOV <hanguelkov @ .dorisec.fr> - ， > > > Cc : security , pablo , kadlec , fw , netfilter-devel , coreteam , davy , amongodin ， > > Subject :  [ vs ] Netfilter vulnerability disclosure ， > Hello everyone ,  ， > One of our collaborators at RandoriSec , Arthur Mongodin found a ， > vulnerability within the netfilter subsystem during his internship. ， > Successful exploitation of this bug leads to a Local Privilege ， > Escalation ( LPE ) to the `root` user , as tested on Ubuntu server 22.04 ， > ( Linux 5.15.0-39-generic ) . ， > This vulnerability is a heap buffer overflow due to a weak check and has ， > been introduced within the commit ， > [ fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81 ]  ( https : /github.com/torvalds/linux/commit/fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81 )  ,  ， > it affects the Linux kernel since the version 5.8 and is still present today. ， > The heap buffer overflow happens in the function `nft_set_elem_init` ， > ( `/net/netfilter/nf_tables_api.c` )  ， > `c ， > void * nft_set_elem_init ( const struct nft_set * set ,  ， > ? const struct nft_set_ext_tmpl * tmpl ,  ， > ? const u32 * key , const u32 * key_end ,  ， > ? const u32 * data , u64 timeout , u64 expiration , gfp_t gfp )  ， > { ， > ? struct nft_set_ext * ext ;  ， > ? void * elem ;  ， > ? elem = kzalloc ( set->ops->elemsize + tmpl->len ,  ， > gfp )  ; ? <= ( 0 )  ， > ? if ( elem = NULL )  ， > ? return NULL ;  ， > ? . ， > ? if ( nft_set_ext_exists ( ext , NFT_SET_EXT_DATA )  ， > ? memcpy ( nft_set_ext_data ( ext )  , data ,  ， > set->dlen )  ; ? <= ( 1 )  ， > ? . ， > ? return elem ;  ， > } ， > ` ， > A buffer is allocated at ( 0 ) without taking in consideration the value ， > `set->dlen` used at ( 1 ) for the copy. ， > The computation of the needed space ( `tmpl->len` ) is realized before the ， > call to `nft_set_elem_init` , however ,  ， > ?a weak check on a user input allows a user to provide an element with ， > a data length lower than the `set->dlen` for the allocation. ， > This check is located within the function `nft_set_elem_parse_data` ， > ( `/net/netfilter/nf_tables_api.c` ) . ， > `c ， > static int nft_setelem_parse_data ( struct nft_ctx * ctx , struct nft_set * set ,  ， > ? struct nft_data_desc * desc ,  ， > ? struct nft_data * data ,  ， > ? struct nlattr * attr )  ， > { ， > ? . ， > ? if ( desc->type ! = NFT_DATA_VERDICT & desc->len ! = set->dlen )  ， > {? <= ( 2 )  ， > ? nft_data_release ( data , desc->type )  ;  ， > ? return -EINVAL ;  ， > ? } ， > ? return 0 ;  ， > } ， > ` ， > As we can see at ( 2 )  , if the data type is `NFT_DATA_VERDICT` , the ， > comparison between `desc->len` and `set->dlen` is not done. ， > Finally , `desc->len` it is used to compute `tmpl->len` at ( 0 ) and ， > `set->dlen` for the copy at ( 1 ) and they can be different. ， > The vulnerable code path can be reached if the kernel is built with the ， > configuration `CONFIG_NETFILTER` , `CONFIG_NF_TABLES` enabled. ， > To exploit the vulnerability , an attacker may need to obtain an ， > unprivileged user namespace to gain the capability `CAP_NET_ADMIN` ， > ( `CONFIG_USER_NS` and `CONFIG_NET_NS` enabled , and ， > `kernel.unprivileged_userns_clone = 1` ) . ， > The exploitation was simplified by the use of an uninitialized variable ， > in `nft_add_set_elem` :  ， > `c ， > static int nft_add_set_elem ( struct nft_ctx * ctx , struct nft_set * set ,  ， > const struct nlattr * attr , u32 nlmsg_flags )  ， > { ， > ? struct nft_set_elem elem ;  ， > ? . ， > } ， > ` ， > First we add an `elem` with the type `NFT_DATA_VALUE` , then `elem.data` ， > will be filled `set->dlen` bytes , the second iteration will only erase ， > the first bytes of `elem.data` with an element of type `NFT_DATA_VERDICT`. ， > We get an infoleak by overwriting the field `datalen` of ， > an`user_key_payload` structure. The write primitive can be obtained with ， > an unlinking attack on the `list_head` of the `simple_xattr` structure. ， > We targeted the `modprobe_path` to gain root permission by executing a ， > shell wrapper. ， > The following Proof of Concept ( PoC ) will trigger KASAN on the upstream ， > kernel ( Linux 5.19.0-rc4 )  ， > `c",
    "time": "Tue, 5 Jul 2022 08:56:28 +0200"
}