{
    "text": "Subject : Qualys Security Advisory - The Stack Clash ， Qualys Security Advisory ， The Stack Clash ， Contents ， I. Introduction ， II. Problem ， II.1. Automatic stack expansion ， II.2. Stack guard-page ， II.3. Stack-clash exploitation ， III. Solutions ， IV. Results ， IV.1. Linux ， IV.2. OpenBSD ， IV.3. NetBSD ， IV.4. FreeBSD ， IV.5. Solaris ， V. Acknowledgments ， I. Introduction ， Our research started with a 96-megabyte surprise :  ， b97bb000-b97dc000 rw-p 00000000 00 : 00 0 [ heap ]  ， bf7c6000-bf806000 rw-p 00000000 00 : 00 0 [ stack ]  ， and a 12-year-old question : \"If the heap grows up , and the stack grows ， down , what happens when they clash? Is it exploitable? How?\" ， - In 2005 , Gael Delalleau presented \"Large memory management ， vulnerabilities\" and the first stack-clash exploit in user-space ，  ( against mod_php 4.3.0 on Apache 2.0.53 )  :  ， http : /cansecwest.com/core05/memory_vulns_delalleau.pdf ， - In 2010 , Rafal Wojtczuk published \"Exploiting large memory management ， vulnerabilities in Xorg server running on Linux\" , the second ， stack-clash exploit in user-space ( CVE-2010-2240 )  :  ， http : /www.invisiblethingslab.com/resources/misc-2010/xorg-large-memory-attacks.pdf ， - Since 2010 , security researchers have exploited several stack-clashes ， in the kernel-space ; for example :  ， https : /jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/ ， https : /jon.oberheide.org/files/infiltrate12-thestackisback.pdf ， https : /googleprojectzero.blogspot.com/2016/06/exploiting-recursion-in-linux-kernel_20.html ， In user-space , however , this problem has been greatly underestimated ;  ， the only public exploits are Gael Delalleau's and Rafal Wojtczuk's , and ， they were written before Linux introduced a protection against ， stack-clashes ( a \"guard-page\" mapped below the stack )  :  ， https : /bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-2240 ， In this advisory , we show that stack-clashes are widespread in ， user-space , and exploitable despite the stack guard-page ; we discovered ， multiple vulnerabilities in guard-page implementations , and devised ， general methods for :  ， - \"Clashing\" the stack with another memory region : we allocate memory ， until the stack reaches another memory region , or until another memory ， region reaches the stack ;  ， - \"Jumping\" over the stack guard-page : we move the stack-pointer from ， the stack and into the other memory region , without accessing the ， stack guard-page ;  ， - \"Smashing\" the stack , or the other memory region : we overwrite the ， stack with the other memory region , or the other memory region with ， the stack. ， To illustrate our findings , we developed the following exploits and ， proofs-of-concepts :  ， - a local-root exploit against Exim ( CVE-2017-1000369 , CVE-2017-1000376 )  ， on i386 Debian ;  ， - a local-root exploit against Sudo ( CVE-2017-1000367 , CVE-2017-1000366 )  ， on i386 Debian , Ubuntu , CentOS ;  ， - an independent Sudoer-to-root exploit against CVE-2017-1000367 on any ， SELinux-enabled distribution ;  ， - a local-root exploit against ld.so and most SUID-root binaries ，  ( CVE-2017-1000366 , CVE-2017-1000370 ) on i386 Debian , Fedora , CentOS ;  ， - a local-root exploit against ld.so and most SUID-root PIEs ，  ( CVE-2017-1000366 , CVE-2017-1000371 ) on i386 Debian , Ubuntu , Fedora ;  ， - a local-root exploit against /bin/su ( CVE-2017-1000366 ,  ， CVE-2017-1000365 ) on i386 Debian ;  ， - a proof-of-concept that gains eip control against Sudo on i386 ， grsecurity/PaX ( CVE-2017-1000367 , CVE-2017-1000366 , CVE-2017-1000377 )  ;  ， - a local proof-of-concept that gains rip control against Exim ，  ( CVE-2017-1000369 ) on amd64 Debian ;  ， - a local-root exploit against ld.so and most SUID-root binaries ，  ( CVE-2017-1000366 , CVE-2017-1000379 ) on amd64 Debian , Ubuntu , Fedora ,  ， CentOS ;  ， - a proof-of-concept against /usr/bin/at on i386 OpenBSD , for ， CVE-2017-1000372 in OpenBSD's stack guard-page implementation and ， CVE-2017-1000373 in OpenBSD's qsort (  ) function ;  ， - a proof-of-concept for CVE-2017-1000374 and CVE-2017-1000375 in ， NetBSD's stack guard-page implementation ;  ， - a proof-of-concept for CVE-2017-1085 in FreeBSD's setrlimit (  )  ， RLIMIT_STACK implementation ;  ， - two proofs-of-concept for CVE-2017-1083 and CVE-2017-1084 in FreeBSD's ， stack guard-page implementation ;  ， - a local-root exploit against /usr/bin/rsh ( CVE-2017-3630 ,  ， CVE-2017-3629 , CVE-2017-3631 ) on Solaris 11. ， II. Problem ， Note : in this advisory , the \"start of the stack\" is the lowest address ， of its memory region , and the \"end of the stack\" is the highest address ， of its memory region ; we do not use the ambiguous terms \"top of the ， stack\" and \"bottom of the stack\". ， II.1. Automatic stack expansion ， The user-space stack of a process is automatically expanded by the ， kernel :  ， - if the stack-pointer ( the esp register , on i386 ) reaches the start of ， the stack and the unmapped memory pages below ( the stack grows down ,  ， on i386 )  ,  ， - then a \"page-fault\" exception is raised and caught by the kernel ,  ， - and the page-fault handler transparently expands the user-space stack ， of the process ( it decreases the start address of the stack )  ,  ， - or it terminates the process with a SIGSEGV if the stack expansion ， fails ( for example , if the RLIMIT_STACK is reached ) . ， Unfortunately , this stack expansion mechanism is implicit and fragile :  ， it relies on page-fault exceptions , but if another memory region is ， mapped directly below the stack , then the stack-pointer can move from ， the stack into the other memory region without raising a page-fault ,  ， and :  ， - the kernel cannot tell that the process needed more stack memory ;  ， - the process cannot tell that its stack-pointer moved from the stack ， into another memory region. ， In contrast , the heap expansion mechanism is explicit and robust : the ， process uses the brk (  ) system-call to tell the kernel that it needs more ， heap memory , and the kernel expands the heap accordingly ( it increases ， the end address of the heap memory region - the heap always grows up ) . ， II.2. Stack guard-page ， The fragile stack expansion mechanism poses a security threat : if the ， stack-pointer of a process can move from the stack into another memory ， region ( which ends exactly where the stack starts ) without raising a ， page-fault , then :  ， - the process uses this other memory region as if it were an extension ， of the stack ;  ， - a write to this stack extension smashes the other memory region ;  ， - a write to the other memory region smashes the stack extension. ， To protect against this security threat , the kernel maps a \"guard-page\" ， below the start of the stack : one or more PROT_NONE pages ( or unmappable ， pages ) that :  ， - raise a page-fault exception if accessed ( before the stack-pointer can ， move from the stack into another memory region )  ;  ， - terminate the process with a SIGSEGV ( because the page-fault handler ， cannot expand the stack if another memory region is mapped directly ， below ) . ， Unfortunately , a stack guard-page of a few kilobytes is insufficient ，  ( CVE-2017-1000364 )  : if the stack-pointer \"jumps\" over the guard-page - ， the guard-page - then no page-fault exception is raised and the stack ， extends into the other memory region. ， This theoretical vulnerability was first described in Gael Delalleau's ， 2005 presentation ( slides 24-29 ) . In the present advisory , we discuss ， its practicalities , and multiple vulnerabilities in stack guard-page ， implementations ( in OpenBSD , NetBSD , and FreeBSD )  , but we exclude ， related vulnerabilities such as unbounded alloca (  ) s and VLAs ，  ( Variable-Length Arrays ) that have been exploited in the past :  ， http : /phrack.org/issues/63/14.html ， http : /blog.exodusintel.com/2013/01/07/who-was-phone/ ， II.3. Stack-clash exploitation ， Must be a clash , there's no alternative. ， -The Clash , \"Kingston Advice\" ， Our exploits follow a series of four sequential steps - each step ， allocates memory that must not be freed before all steps are complete :  ， Step 1 : Clash ( the stack with another memory region )  ， Step 2 : Run ( move the stack-pointer to the start of the stack )  ， Step 3 : Jump ( over the stack guard-page , into the other memory region )  ， Step 4 : Smash ( the stack , or the other memory region )  ， II.3.1. Step 1 : Clash the stack with another memory region ， Have the boys found the leak yet? ， -The Clash , \"The Leader\" ， Allocate memory until the start of the stack reaches the end of another ， memory region , or until the end of another memory region reaches the ， start of the stack. ， - The other memory region can be , for example :  ， . the heap ;  ， . an anonymous mmap (  )  ;  ， . the read-write segment of ld.so ;  ， . the read-write segment of a PIE , a Position-Independent Executable. ， - The memory allocated in this Step 1 can be , for example :  ， . stack and heap memory ;  ， . stack and anonymous mmap (  ) memory ;  ， . stack memory only. ， - The heap and anonymous mmap (  ) memory can be :  ， . temporarily allocated , but not freed before the stack guard-page is ， jumped over in Step 3 and memory is smashed in Step 4 ;  ， . permanently leaked. On Linux , a general method for allocating ， anonymous mmap (  ) s is the LD_AUDIT memory leak that we discovered in ， the ld.so part of the glibc , the GNU C Library ( CVE-2017-1000366 ) . ， - The stack memory can be allocated , for example :  ， . through megabytes of command-line arguments and environment ， variables. ， On Linux , this general method for allocating stack memory is limited ， by the kernel to 1/4 of the current RLIMIT_STACK ( 1GB on i386 if ， RLIMIT_STACK is RLIM_INFINITY - man execve , \"Limits on size of ， arguments and environment\" ) . ， However , as we were drafting this advisory , we realized that the ， kernel imposes this limit on the argument and environment strings ,  ， but not on the argv [  ] and envp [  ] pointers to these strings , and we ， developed alternative versions of our Linux exploits that do not ， depend on application-specific memory leaks ( CVE-2017-1000365 ) . ， . through recursive function calls. ， On BSD , we discovered a general method for allocating megabytes of ， stack memory : a vulnerability in qsort (  ) that causes this function ， to recurse N/4 times , given a pathological input array of N elements ，  ( CVE-2017-1000373 in OpenBSD , CVE-2017-1000378 in NetBSD , and ， CVE-2017-1082 in FreeBSD ) . ， - In a few rare cases , Step 1 is not needed , because another memory ， region is naturally mapped directly below the stack ( for example ,  ， ld.so in our Solaris exploit ) . ， II.3.2. Step 2 : Move the stack-pointer to the start of the stack ， Run , run , run , run , run , don't you know? ， -The Clash , \"Three Card Trick\" ， Consume the unused stack memory that separates the stack-pointer from ， the start of the stack. This Step 2 is similar to Step 3 ( \"Jump over the ， stack guard-page\" ) but is needed because :  ， - the stack-pointer is usually several kilobytes higher than the start ， of the stack ( functions that allocate a large stack-frame decrease the ， start address of the stack , but this address is never increased ， again )  ; moreover :  ， . the FreeBSD kernel automatically expands the user-space stack of a ， process by multiples of 128KB ( SGROWSIZ , in vm_map_growstack (  )  ;  ， . the Linux kernel initially expands the user-space stack of a process ， by 128KB ( stack_expand , in setup_arg_pages (  ) . ， - in Step 3 , the stack-based buffer used to jump over the guard-page :  ， . is usually not large enough to simultaneously move the stack-pointer ， to the start of the stack , and then into another memory region ;  ， . must not be fully written to ( a full write would access the stack ， guard-page and terminate the process ) but the stack memory consumed ， in this Step 2 can be fully written to ( for example , strdupa (  ) can ， be used in Step 2 , but not in Step 3 ) . ， The stack memory consumed in this Step 2 can be , for example :  ， - large stack-frames , alloca (  ) s , or VLAs ( which can be detected by ， grsecurity/PaX's STACKLEAK plugin for GCC ,  ， https : /grsecurity.net/features.php )  ;  ， - recursive function calls ( which can be detected by GNU cflow ,  ， http : /www.gnu.org/software/cflow/ )  ;  ， - on Linux , we discovered that the argv [  ] and envp [  ] arrays of pointers ， can be used to consume the 128KB of initial stack expansion , because ， the kernel allocates these arrays on the stack long after the call to ， setup_arg_pages (  )  ; this general method for completing Step 2 is ， exploitable locally , but the initial stack expansion poses a major ， obstacle to the remote exploitation of stack-clashes , as mentioned in ， IV.1.1. ， In a few rare cases , Step 2 is not needed , because the stack-pointer is ， naturally close to the start of the stack ( for example , in Exim's main (  )  ， function , the 256KB group_list [  ] moves the stack-pointer to the start of ， the stack and beyond ) . ， II.3.3. Step 3 : Jump over the stack guard-page , into another memory ， region ， You need a little jump of electrical shockers. ， -The Clash , \"Clash City Rockers\" ， Move the stack-pointer from the stack and into the memory region that ， clashed with the stack in Step 1 , but without accessing the guard-page. ， To complete this Step 3 , a large stack-based buffer , alloca (  )  , or VLA is ， needed , and :  ， - it must be larger than the guard-page ;  ， - it must end in the stack , above the guard-page ;  ， - it must start in the memory region below the stack guard-page ;  ， - it must not be fully written to ( a full write would access the ， guard-page , raise a page-fault exception , and terminate the process ,  ， because the memory region mapped directly below the stack prevents the ， page-fault handler from expanding the stack ) . ， In a few cases , Step 3 is not needed :  ， - on FreeBSD , a stack guard-page is implemented but disabled by default ，  ( CVE-2017-1083 )  ;  ， - on OpenBSD , NetBSD , and FreeBSD , we discovered implementation ， vulnerabilities that eliminate the stack guard-page ( CVE-2017-1000372 ,  ， CVE-2017-1000374 , CVE-2017-1084 ) . ， On Linux , we devised general methods for jumping over the stack ， guard-page ( CVE-2017-1000366 )  :  ， - The glibc's _dcigettext (  ) function alloca (  ) tes single_locale , a ， stack-based buffer of up to 128KB ( MAX_ARG_STRLEN , man execve )  , the ， length of the LANGUAGE environment variable ( if the current locale is ， neither \"C\" nor \"POSIX\" , but distributions install default locales ， such as \"C.UTF-8\" and \"en_US.utf8\" ) . ， If LANGUAGE is mostly composed of ' : ' characters , then single_locale ， is barely written to , and can be used to jump over the stack ， guard-page. ， Moreover , if _dcigettext (  ) finds the message to be translated , then ， _nl_find_msg (  ) strdup (  ) licates the OUTPUT_CHARSET environment variable ， and allows a local attacker to immediately smash the stack and gain ， control of the instruction pointer ( the eip register , on i386 )  , as ， detailed in Step 4a. ， We exploited this stack-clash against Sudo and su , but most of the ， SUID ( set-user-ID ) and SGID ( set-group-ID ) binaries that call ， setlocale ( LC_ALL , \" ) and _dcigettext (  ) or its derivatives ( the ，  * gettext (  ) functions , the _ (  ) convenience macro , the strerror (  )  ， function ) are exploitable. ， - The glibc's vfprintf (  ) function ( called by the * printf (  ) family of ， functions ) alloca (  ) tes a stack-based work buffer of up to 64KB ，  ( _MAX_ALLOCA_CUTOFF ) if a width or precision is greater than 1KB ，  ( WORK_BUFFER_SIZE ) . ， If the corresponding format specifier is %s then this work buffer is ， never written to and can be used to jump over the stack guard-page. ， None of our exploits is based on this method , but it was one of our ， ideas to exploit Exim remotely , as mentioned in IV.1.1. ， - The glibc's getaddrinfo (  ) function calls gaih_inet (  )  , which ， alloca (  ) tes tmpbuf , a stack-based buffer of up to 64KB ，  ( _MAX_ALLOCA_CUTOFF ) that may be used to jump over the stack ， guard-page. ， Moreover , gaih_inet (  ) calls the gethostbyname *  (  ) functions , which ， malloc (  ) ate a heap-based DNS response of up to 64KB ( MAXPACKET ) that ， may allow a remote attacker to immediately smash the stack , as ， detailed in Step 4a. ， None of our exploits is based on this method , but it may be the key to ， the remote exploitation of stack-clashes. ， - The glibc's run-time dynamic linker ld.so alloca (  ) tes llp_tmp , a ， stack-based copy of the LD_LIBRARY_PATH environment variable. If ， LD_LIBRARY_PATH contains Dynamic String Tokens ( DSTs )  , they are first ， expanded : llp_tmp can be larger than 128KB ( MAX_ARG_STRLEN ) and not ， fully written to , and can therefore be used to jump over the stack ， guard-page and smash the memory region mapped directly below , as ， detailed in Step 4b. ， We exploited this ld.so stack-clash in two data-only attacks that ， bypass NX ( No-eXecute ) and ASLR ( Address Space Layout Randomization )  ， and obtain a privileged shell through most SUID and SGID binaries on ， most i386 Linux distributions. ， - Several local and remote applications allocate a 256KB stack-based ， \"gid_t buffer [ NGROUPS_MAX ]  ; \" that is not fully written to and can be ， used to move the stack-pointer to the start of the stack ( Step 2 ) and ， jump over the guard-page ( Step 3 ) . For example , Exim's main (  ) function ， and older versions of util-linux's su. ， None of our exploits is based on this method , but an experimental ， version of our Exim exploit unexpectedly gained control of eip after ， the group_list [  ] buffer had jumped over the stack guard-page. ， II.3.4. Step 4 : Either smash the stack with another memory region ( Step ， 4a ) or smash another memory region with the stack ( Step 4b )  ， Smash and grab , it's that kind of world. ， -The Clash , \"One Emotion\" ， In Step 3 , a function allocates a large stack-based buffer and jumps ， over the stack guard-page into the memory region mapped directly below ;  ， in Step 4 , before this function returns and jumps back into the stack :  ， - Step 4a : a write to the memory region mapped below the stack ( where ， esp still points to ) effectively smashes the stack. We exploit this ， general method for completing Step 4 in Exim , Sudo , and su :  ， . we overwrite a return-address on the stack and gain control of eip ;  ， . we return-into-libc ( into system (  ) or _libc_dlopen (  ) to defeat NX ;  ， . we brute-force ASLR ( 8 bits of entropy ) if CVE-2016-3672 is patched ;  ， . we bypass SSP ( Stack-Smashing Protector ) because we overwrite the ，  ( the memcpy (  ) that smashes the stack usually overwrites its own ， stack-frame and return-address ) . ， - Step 4b : a write to the stack effectively smashes the memory region ， mapped below ( where esp still points to ) . This second method for ， completing Step 4 is application-specific ( it depends on the contents ， of the memory region that we smash ) unless we exploit the run-time ， dynamic linker ld.so :  ， . on Solaris , we devised a general method for smashing ld.so's ， read-write segment , overwriting one of its function pointers , and ， executing our own shell-code ;  ， . on Linux , we exploited most SUID and SGID binaries through ld.so :  ， our \"hwcap\" exploit smashes an mmap (  ) ed string , and our \".dynamic\" ， exploit smashes a PIE's read-write segment before it is mprotect (  ) ed ， read-only by Full RELRO ( Full RELocate Read-Only - GNU_RELRO and ， BIND_NOW ) . ， III. Solutions ， Based on our research , we recommend that the affected operating systems :  ， - Increase the size of the stack guard-page to at least 1MB , and allow ， system administrators to easily modify this value ( for example ,  ， grsecurity/PaX introduced /proc/sys/vm/heap_stack_gap in 2010 ) . ， This first , short-term solution is cheap , but it can be defeated by a ， very large stack-based buffer. ， - Recompile all userland code ( ld.so , libraries , binaries ) with GCC's ， \"-fstack-check\" option , which prevents the stack-pointer from moving ， into another memory region without accessing the stack guard-page ( it ， writes one word to every 4KB page allocated on the stack ) . ， This second , long-term solution is expensive , but it cannot be ， defeated ( even if the stack guard-page is only 4KB , one page ) - ， unless a vulnerability is discovered in the implementation of the ， stack guard-page or the \"-fstack-check\" option. ， IV. Results ， IV.1. Linux ， IV.1.1. Exim ， Debian 8.5 ， Crude exploitation ， Our first exploit , a Local Privilege Escalation against Exim's SUID-root ， PIE ( Position-Independent Executable ) on i386 Debian 8.5 , simply follows ， the four sequential steps outlined in II.3. ， Step 1 : Clash the stack with the heap ， To reach the start of the stack with the end of the heap ( man brk )  , we ， permanently leak memory through multiple -p command-line arguments that ， are malloc (  ) ated by Exim but never free (  ) d ( CVE-2017-1000369 ) - we call ， such a malloc (  ) ated chunk of heap memory a \"memleak-chunk\". ， Because the -p argument strings are originally allocated on the stack by ， execve (  )  , we must cover half of the initial heap-stack distance ( between ， the start of the heap and the end of the stack ) with stack memory , and ， half of this distance with heap memory. ， If we set the RLIMIT_STACK to 136MB ( MIN_GAP , arch/x86/mm/mmap.c ) then ， the initial heap-stack distance is minimal ( randomized in a [ 96MB , 137MB ]  ， range )  , but we cannot reach the stack with the heap because of the 1/4 ， limit imposed by the kernel on the argument and environment strings ( man ， execve )  : 136MB/4=34MB of -p argument strings cannot cover 96MB/2=48MB ,  ， half of the minimum heap-stack distance. ， Moreover , if we increase the RLIMIT_STACK , the initial heap-stack ， distance also increases and we still cannot reach the stack with the ， heap. However , if we set the RLIMIT_STACK to RLIM_INFINITY ( 4GB on i386 )  ， then the kernel switches from the default top-down mmap (  ) layout to a ， legacy bottom-up mmap (  ) layout , and :  ， - the initial heap-stack distance is approximately 2GB , because the ， start of the heap ( the initial brk (  ) is randomized above the address ， 0x40000000 , and the end of the stack is randomized below the address ， 0xC0000000 ;  ， - we can reach the stack with the heap , despite the 1/4 limit imposed by ， the kernel on the argument and environment strings , because 4GB/4=1GB ， of -p argument strings can cover 2GB/2=1GB , half of the initial ， heap-stack distance ;  ， - we clash the stack with the heap around the address 0x80000000. ， Step 2 : Move the stack-pointer ( esp ) to the start of the stack ， The 256KB stack-based group_list [  ] in Exim's main (  ) naturally consumes ， the 128KB of initial stack expansion , as mentioned in II.3.2. ， Step 3 : Jump over the stack guard-page and into the heap ， To move esp from the start of the stack into the heap , without accessing ， the stack guard-page , we use a malformed -d command-line argument that ， is written to the 32KB ( STRING_SPRINTF_BUFFER_SIZE ) stack-based buffer ， in Exim's string_sprintf (  ) function. This buffer is not fully written to ， and hence does not access the stack guard-page , because our -d argument ， string is much shorter than 32KB. ， Step 4a : Smash the stack with the heap ， Before string_sprintf (  ) returns ( and moves esp from the heap back into ， the stack ) it calls string_copy (  )  , which malloc (  ) ates and memcpy (  ) es our ， -d argument string to the end of the heap , where esp still points to - ， we call this malloc (  ) ated chunk of heap memory the \"smashing-chunk\". ， This call to memcpy (  ) therefore smashes its own stack-frame ( which is ， not protected by SSP ) with the contents of our smashing-chunk , and we ， overwrite memcpy (  ) 's return-address with the address of libc's system (  )  ， function ( which is not randomized by ASLR because Debian 8.5 is ， vulnerable to CVE-2016-3672 )  :  ， - instead of smashing memcpy (  ) 's stack-frame with an 8-byte pattern ( the ， 4-byte pattern ( the return-address to system (  )  , append \".\" to the ， PATH environment variable , and symlink (  ) our exploit to the string ， that begins at the address of libc's system (  ) function ;  ， - system (  ) does not drop our escalated root privileges , because Debian's ， /bin/sh is dash , not bash and its -p option ( man bash ) . ， This first version of our Exim exploit obtained a root-shell after ， nearly a week of failed attempts ; to improve this result , we analyzed ， every step of a successful run. ， Refined exploitation ， Step 1 : Clash the stack with the heap ， + The heap must be able to reach the stack [ Condition 1 ]  ， The start of the heap is randomized in the 32MB range above the end of ， Exim's PIE ( the end of its .bss section )  , but the growth of the heap is ， sometimes blocked by libraries that are mmap (  ) ed within the same range ，  ( because of the legacy bottom-up mmap (  ) layout ) . On Debian 8.5 , Exim's ， libraries occupy about 8MB and thus block the growth of the heap with a ， probability of 8MB/32MB = 1/4. ， When the heap is blocked by the libraries , malloc (  ) switches from brk (  )  ， to mmap (  ) s of 1MB ( MMAP_AS_MORECORE_SIZE )  , and our memory leak reaches ， the stack with mmap (  ) s instead of the heap. Such a stack-clash is also ， exploitable , but its probability of success is low , as detailed in ， IV.1.6. , and we therefore discarded this approach. ， + The heap must always reach the stack , when not blocked by libraries ， Because the initial heap-stack distance ( between the start of the heap ， and the end of the stack ) is a random variable :  ， - either we allocate the exact amount of heap memory to cover the mean ， heap-stack distance , but the probability of success of this approach ， is low and we therefore discarded it ;  ， - or we allocate enough heap memory to always reach the stack , even when ， the initial heap-stack distance is maximal ; after the heap reaches the ， stack , our memory leak allocates mmap (  ) s of 1MB above the stack ( below ， 0xC0000000 ) and below the heap ( above the libraries )  , but it must not ， exhaust the address-space ( the 1GB below 0x40000000 is unmappable )  ;  ， - the final heap-stack distance ( between the end of the heap and the ， start of the stack ) is also a random variable :  ， . its minimum value is 8KB ( the stack guard-page , plus a safety page ， imposed by the brk (  ) system-call in mm/mmap.c )  ;  ， . its maximum value is roughly the size of a memleak-chunk , plus 128KB ，  ( DEFAULT_TOP_PAD , malloc/malloc.c ) . ， Step 3 : Jump over the stack guard-page and into the heap ， - The stack-pointer must jump over the guard-page and land into the free ， chunk at the end of the heap ( the remainder of the heap after malloc (  )  ， switches from brk (  ) to mmap (  )  , where both the smashing-chunk and ， memcpy (  ) 's stack-frame are allocated and overwritten in Step 4a ，  [ Condition 2 ]  ;  ， - The write ( of approximately smashing-chunk bytes ) to ， string_sprintf (  ) 's stack-based buffer ( which starts where the ， guard-page jump lands ) must not crash into the end of the heap ，  [ Condition 3 ] . ， Step 4a : Smash the stack with the heap ， The smashing-chunk must be allocated into the free chunk at the end of ， the heap :  ， - the smashing-chunk must not be allocated into the free chunks left ， over at the end of the 1MB mmap (  ) s [ Condition 4 ]  ;  ， - the memleak-chunks must not be allocated into the free chunk at the ， end of the heap [ Condition 5 ] . ， Intuitively , the probability of gaining control of eip depends on the ， size of the smashing-chunk ( the guard-page jump's landing-zone ) and the ， size of the memleak-chunks ( which determines the final heap-stack ， distance ) . ， To maximize this probability , we wrote a helper program that imposes the ， following conditions on the smashing-chunk and memleak-chunks :  ， - the smashing-chunk must be smaller than 32KB ，  ( STRING_SPRINTF_BUFFER_SIZE )  [ Condition 3 ]  ;  ， - the memleak-chunks must be smaller than 128KB ( DEFAULT_MMAP_THRESHOLD ,  ， malloc/malloc.c )  ;  ， - the free chunk at the end of the heap must be larger than twice the ， smashing-chunk size [ ",
    "time": "Mon, 19 Jun 2017 08:28:43 -0700"
}