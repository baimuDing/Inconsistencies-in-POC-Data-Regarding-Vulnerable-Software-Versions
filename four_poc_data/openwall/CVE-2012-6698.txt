{
    "text": "Date: Thu, 3 Dec 2015 00:18:51 -0500 (EST) ， From: cve-assign@.re.org ， To: seth.arnold@.onical.com ， Cc: cve-assign@.re.org, oss-security@.ts.openwall.com, guidovranken@.il.com ， Subject: Re: CVE Request: dhcpcd 3.x, potentially other versions too ， -BEGIN PGP SIGNED MESSAGE- ， Hash: SHA256 ， > https:/launchpadlibrarian.net/228152582/dhcp.c.patch ， > I had expected this part of the diff to address the out-of-bounds writes: ， > if (out & out != start) ， > *(out - 1) = ' '; ， > Ack, looks like heap[-1] OOB write to me. ， Use CVE-2012-6698 for the vulnerability in which the possibility of ， \"out = start\" wasn't considered, leading to an out-of-bounds write. ， > Recalling from my last analyse, I think this is just an OOB read, because ， > decode_search() is called with out being NULL to count the amount of data ， > to be copied later. Unless this data is somehow modified the next call ， > to decode_search() should have sufficient amount of heap allocated for ， > the memcpy() to be correct. But the loop has an OOB read when counting ， > the data (and later when copying it and there wasnt already a SIGSEGV). ， Use CVE-2012-6699 for this loop error that results in an out-of-bounds read. ， >\t case DHCP_DNSSEARCH: ， > MIN_LENGTH (1); ， > - free (dhcp->dnssearch); ， > len = decode_search (p, length, NULL); ， > if (len > 0) { ， > + free (dhcp->dnssearch); ， Use CVE-2012-6700 for the presence of the free call in an incorrect place. ， CVE assignment team, MITRE CVE Numbering Authority ， M/S M300 ， 202 Burlington Road, Bedford, MA 01730 USA ， [ PGP key available through http:/cve.mitre.org/cve/request_id.html ]"
}