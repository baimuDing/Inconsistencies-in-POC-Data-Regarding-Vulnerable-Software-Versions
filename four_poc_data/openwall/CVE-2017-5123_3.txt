{
    "text": "Cc : oss-security @ .ts.openwall.com ， Subject : Re : Re : CVE-2017-5123 Linux kernel v4.13 waitid (  )  ， not calling access_ok (  )  ， This will be a fast writeup on how I exploited CVE-2017-5123 , a Linux ， kernel vulnerability in the waitid (  ) syscall for 4.12-4.13 , which ， gives an attacker a \"write-not-what-only-where\" primitive , or in other ， words , the ability to write \"non-controlled\" user data to arbitrary ， kernel memory. ， KASLR is bypassed using memory probing and root obtained via cred ， struct spraying and location predictability. ， The video demonstrating my exploit in action was published on November ， 5th , as it can be seen here :  ， https : /www.youtube.com/watch?v=DfwOJIcV5ZA ， Surprisingly , Chris Salls independently published his own writeup and ， exploit on November 6th. Awesome work there !  ， https : /salls.github.io/Linux-Kernel-CVE-2017-5123/ ， So now , November 7th ( 0 : 30 a.m here in Portugal !  )  , I'll be detailing ， how I used this \"write-not-what-only-where\" vulnerability without a ， single read to get root. ， Obviously , given other vulnerabilities , such as certain infoleaks , it ， would be an instant game over. ， What spiked some interest to me , was what could one actually do with ， only this vulnerability by itself , or other vulnerabilities of this ， type , assuming all vanilla kernel protections. ， It's powerful , but some would initially assume that it's not enough to ， increase our privileges these days. ， The vulnerability :  ， SYSCALL_DEFINE5 ( waitid , int , which , pid_t , upid , struct siginfo _user *  ,  ， infop , int , options , struct rusage ， _user *  , ru )  ， { ， struct rusage r ;  ， struct waitid_info info = {.status = 0} ;  ， long err = kernel_waitid ( which , upid , &info , options , ru ? &r : NULL )  ;  ， int signo = 0 ;  ， signo = SIGCHLD ;  ， err = 0 ;  ， } ， user_access_begin (  )  ;  ， unsafe_put_user ( signo , &infop->si_signo , Efault )  ;  ， unsafe_put_user ( 0 , &infop->si_errno , Efault )  ;  ， unsafe_put_user ( info.cause , &infop->si_code , Efault )  ;  ， unsafe_put_user ( info.pid , &infop->si_pid , Efault )  ;  ， unsafe_put_user ( info.uid , &infop->si_uid , Efault )  ;  ， unsafe_put_user ( info.status , &infop->si_status , Efault )  ;  ， user_access_end (  )  ;  ， Efault :  ， user_access_end (  )  ;  ， } ， The vulnerability here is that there's a missing access_ok (  ) check in ， the waitid (  ) syscall since they've introduced unsafe_put_user (  ) in 4.12. ， The macro access_ok (  ) should basically ensure that the user specified ， ptr points to user space and not kernel space , since unprivileged ， users shouldn't be able to write arbitrarily to kernel memory. ， This is done by checking the address limit.",
    "time": "Tue, 07 Nov 2017 02:38:03 +0100"
}