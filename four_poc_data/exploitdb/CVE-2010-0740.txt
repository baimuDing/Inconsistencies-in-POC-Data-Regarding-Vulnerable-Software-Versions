{
    "text": "ecve : CVE-2010-0740 ， title : OpenSSL - Remote Denial of Service - Linux dos Exploit ， verified : Verified ， exploit_detail : / ，  * hoagie_openssl_record_of_death.c ，  * OPENSSL REMOTE DENIAL-OF-SERVICE EXPLOIT ，  * - OpenSSL 0.9.8m ( short = 16 bit )  ，  * - OpenSSL 0.9.8f through 0.9.8m ( short ! = 16 bit )  ，  * CVE-2010-0740 ，  * Bug discovered by :  ，  * Bodo Moeller and Adam Langley ( Google )  ，  * Philip Olausson <po @ secweb.se> ，  * The main problem is in ssl/t1_enc.c => tls1_mac (  ) function ，  * - OpenSSL 0.9.8m ，  * if ( ssl->version == DTLS1_BAD_VER |  |  ，  *  ( ssl->version == DTLS1_VERSION ssl->client_version ! = DTLS1_BAD_VER )  )  ，  * { ，  * unsigned char dtlsseq [ 8 ]  ,  * p=dtlsseq ;  ，  * s2n ( send?ssl->d1->w_epoch : ssl->d1->r_epoch , p )  ;  ，  * - OpenSSL 0.9.8f - 0.9.8n ，  * if ( ssl->version == DTLS1_VERSION ssl->client_version ! = DTLS1_BAD_VER )  ，  * { ，  * unsigned char dtlsseq [ 8 ]  ,  * p=dtlsseq ;  ，  * s2n ( send?ssl->d1->w_epoch : ssl->d1->r_epoch , p )  ;  ，  * There is a NULL pointer dereference => ssl->d1 because d1 is only initialized in ，  * ssl/d1_lib.c => dtls1_new (  ) . So if you use SSLv23_server_method (  ) or ，  * TLSv1_server_method (  ) this variable will be NULL. ，  * If the patch ( see is not applied ，  * its possible to set the version to DTLS1_BAD_VER ( 0x100 ) or DTLS_VERSION ( 0xfeff )  ，  * and transmit the packet to the server or client to trigger the vulnerability. ，  * When you are using OpenSSL 0.9.8m you can send DTLS1_BAD_VER because 0x100 is not ，  * a problem with signed/unsigned. ，  * If you are using OpenSSL 0.9.8f to 0.9.8n you have to trigger the vulnerability ，  * via DTLS1_VERSION. In that case version will be 0xfffffeff. So it doesnt work ，  * if DTLS1_VERSION is 16 bit. ，  * THIS FILE IS FOR STUDYING PURPOSES ONLY AND A PROOF-OF- ，  * CONCEPT. THE AUTHOR CAN NOT BE HELD RESPONSIBLE FOR ANY ，  * DAMAGE DONE USING THIS PROGRAM. ，  * VOID.AT Security ，  * andi @ void.at",
    "time": "2010-04-22"
}