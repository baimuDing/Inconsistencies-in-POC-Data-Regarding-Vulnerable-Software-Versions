{
    "text": "published_time: 2015-08-21 ， id: 32507 ， eid: 37920 ， cve: CVE-2015-2432 ， title: Microsoft Windows - 'ATMFD.DLL' Write to Uninitialized Address Due to Malformed CFF Table - Windows dos Exploit ， author: Google Security Research ， published_time: 2015-08-21 ， verified: Verified ， platform: Windows ， exploit_type: dos ， exploit_url: /download/37920 ， exploit_detail: Source: \r ， We have encountered a number of Windows kernel crashes in the ATMFD.DLL OpenType driver while processing corrupted OTF font files, such as:\r ， PAGE_FAULT_IN_NONPAGED_AREA (50)\r ， Invalid system memory was referenced.  This cannot be protected by try-except,\r ， it must be protected by a Probe.  Typically the address is just plain bad or it\r ， is pointing at freed memory.\r ， Arguments:\r ， Arg1: a3a3a3db, memory referenced.\r ， Arg2: 00000001, value 0 = read operation, 1 = write operation.\r ， Arg3: 91f445c9, If non-zero, the instruction address which referenced the bad memory\r ， \taddress.\r ， Arg4: 00000002, (reserved)\r ， Debugging Details:\r ，  ERROR: Module load completed but symbols could not be loaded for ATMFD.DLL\r ， WRITE_ADDRESS:  a3a3a3db \r ， FAULTING_IP: \r ， ATMFD+345c9\r ， 91f445c9 83483810        or      dword ptr [eax+38h],10h\r ， MM_INTERNAL_CODE:  2\r ， IMAGE_NAME:  ATMFD.DLL\r ， DEBUG_FLR_IMAGE_TIMESTAMP:  54e6a55a\r ， MODULE_NAME: ATMFD\r ， FAULTING_MODULE: 91f10000 ATMFD\r ， DEFAULT_BUCKET_ID:  WIN7_DRIVER_FAULT\r ， BUGCHECK_STR:  0x50\r ， PROCESS_NAME:  csrss.exe\r ， CURRENT_IRQL:  2\r ， ANALYSIS_VERSION: 6.3.9600.17237 (debuggers(dbg).140716-0327) x86fre\r ， TRAP_FRAME:  879cfd8c -- (.trap 0xffffffff879cfd8c)\r ， ErrCode = 00000002\r ， eax=a3a3a3a3 ebx=00000008 ecx=00000004 edx=fb964900 esi=fb80e380 edi=fb80e3a0\r ， eip=91f445c9 esp=879cfe00 ebp=879cfe10 iopl=0         nv up ei ng nz ac pe cy\r ， cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010297\r ， ATMFD+0x345c9:\r ， 91f445c9 83483810        or      dword ptr [eax+38h],10h ds:0023:a3a3a3db=????????\r ， Resetting default scope\r ， LAST_CONTROL_TRANSFER:  from 826f4ce7 to 826902d8\r ， STACK_TEXT:  \r ， 879cf8dc 826f4ce7 00000003 5e64199c 00000065 nt!RtlpBreakWithStatusInstruction\r ， 879cf92c 826f57e5 00000003 c06028e8 a3a3a3db nt!KiBugCheckDebugBreak+0x1c\r ， 879cfcf0 826a3391 00000050 a3a3a3db 00000001 nt!KeBugCheck2+0x68b\r ， 879cfd74 82655c48 00000001 a3a3a3db 00000000 nt!MmAccessFault+0x104\r ， 879cfd74 91f445c9 00000001 a3a3a3db 00000000 nt!KiTrap0E+0xdc\r ， WARNING: Stack unwind information not available. Following frames may be wrong.\r ， 879cfe10 91f39eec fb964900 ff657038 91f563ec ATMFD+0x345c9\r ， 879cfe34 91f3e987 fb9bec70 91f563ec 00000f5c ATMFD+0x29eec\r ， 879d0544 91f3f6e0 fb9bec70 91f4f028 879d0790 ATMFD+0x2e987\r ， 879d0600 91f327ae fb9bec70 91f4f028 879d0790 ATMFD+0x2f6e0\r ， 879d06ec 91f32858 fb9bec70 879d0790 879d0814 ATMFD+0x227ae\r ， 879d0718 91f232b2 fb9bec70 91f4f028 879d0790 ATMFD+0x22858\r ， 879d087c 91f23689 ffffffff 879d099c fb874f58 ATMFD+0x132b2\r ， 879d08d0 91f1406d ffffffff 879d099c 00000000 ATMFD+0x13689\r ， 879d0924 91c7dcf2 ff7a5010 fbeeccf0 00000001 ATMFD+0x406d\r ， 879d096c 91c667cb ff7a5010 fbeeccf0 00000001 win32k!PDEVOBJ::QueryFontData+0x3e\r ， 879d09e0 91c91513 ffa6a130 fb81e8d0 0000004f win32k!xInsertMetricsRFONTOBJ+0x9c\r ， 879d0a14 91c935f5 00000020 879d0b2c 879d0c92 win32k!RFONTOBJ::bGetGlyphMetrics+0x131\r ， 879d0cb8 91ca6684 040101b7 00000060 00000040 win32k!GreGetCharABCWidthsW+0x147\r ， 879d0d14 82652a66 040101b7 00000040 00000040 win32k!NtGdiGetCharABCWidthsW+0xf8\r ， 879d0d14 771870f4 040101b7 00000040 00000040 nt!KiSystemServicePostCall\r ， 0012f1d4 00000000 00000000 00000000 00000000 ntdll!KiFastSystemCallRet\r ， The crash occurs while trying to modify memory under an invalid address. More specifically, the \"a3a3a3a3\" bytes found in the EAX register at the time of the crash are a repetition of a random byte filled by Driver Verifier in each pool allocation before returning it to the caller. This means that the dereferenced pointer is in fact an uninitialized value from the kernel pool.\r ， The offending code (containing the crashing instruction) is as follows:\r ， .text:000445C6 loc_445C6:\r ， .text:000445C6                 mov     eax, [esi+ecx*4]\r ， .text:000445C9                 or      dword ptr [eax+38h], 10h\r ， .text:000445CD                 inc     ecx\r ， .text:000445CE                 cmp     ecx, ebx\r ， .text:000445D0                 jl      short loc_445C6\r ， As shown above, there is a loop iterating EBX times over an array of addresses stored in [ESI]. At the time of the bugcheck, EBX=8, so the code expects 8 valid pointers in the array; however, only 4 pointers are properly initialized:\r ， kd> dd fb80e380\r ， fb80e380  fb964980 fb9649c0 fb964900 fb964940\r ， fb80e390  a3a3a3a3 a3a3a3a3 a3a3a3a3 a3a3a3a3\r ， fb80e3a0  a3a3a3a3 a3a3a3a3 a3a3a3a3 a3a3a3a3\r ， The issue reproduces on Windows 7. It is easiest to"
}