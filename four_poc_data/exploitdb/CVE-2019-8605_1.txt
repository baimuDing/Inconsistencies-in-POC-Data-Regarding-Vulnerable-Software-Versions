{
    "text": "ecve : CVE-2019-8605 ， title : Apple macOS < 10.14.5 / iOS < 12.3 XNU - 'in6_pcbdetach' Stale Pointer Use-After-Free - Multiple dos Exploit ， verified : Verified ， exploit_detail :  # Reproduction ， Repros on 10.14.3 when run as root. It may need multiple tries to trigger. ，  $ clang -o in6_selectsrc in6_selectsrc.cc ，  $ while 1 ; do sudo ./in6_selectsrc ; done ， res0 : 3 ， res1 : 0 ， res1.5 : -1 // failure expected here ， res2 : 0 ， done ，  [ crash ]  ，  # Explanation ， The following snippet is taken from in6_pcbdetach :  ， void ， in6_pcbdetach ( struct inpcb * inp )  ， // ... ， struct ip_moptions * imo ;  ， struct ip6_moptions * im6o ;  ， inp->inp_vflag = 0 ;  ， m_freem ( inp->in6p_options )  ;  ， inp->in6p_options = NULL ; // <- good ， ip6_freepcbopts ( inp->in6p_outputopts )  ; // <- bad ， ROUTE_RELEASE ( &inp->in6p_route )  ;  ， // free IPv4 related resources in case of mapped addr ，  ( void ) m_free ( inp->inp_options )  ; // <- good ， inp->inp_options = NULL ;  ， Notice that freed options must also be cleared so they are not accidentally reused. ， This can happen when a socket is disconnected and reconnected without being destroyed. ， In the inp->in6p_outputopts case , the options are freed but not cleared , so they can be ， used after they are freed. ， This specific",
    "time": "2019-05-21"
}