{
    "text": "ecve : CVE-2016-4486 ， title : Linux Kernel 4.4 - 'rtnetlink' Stack Memory Disclosure - Linux local Exploit ， verified : Not Verified ， exploit_detail : / *  ，  *  [ Briefs ]  ，  * - CVE-2016-4486 has discovered and reported by Kangjie Lu. ，  * - This is local exploit against the CVE-2016-4486. ，  *  [ Tested version ]  ，  * - Distro : Ubuntu 16.04 ，  * - Kernel version : 4.4.0-21-generic ，  * - Arch : x86_64 ，  *  [ Prerequisites ]  ，  * - None ，  *  [ Goal ]  ，  * - Leak kernel stack base address of current process by exploiting CVE-2016-4486. ，  *  [ Exploitation ]  ，  * - CVE-2016-4486 leaks 32-bits arbitrary kernel memory from uninitialized stack. ，  * - This exploit gets 61-bits stack base address among the 64-bits full address. ，  * remaining 3-bits is not leaked because of limitation of ebpf. ，  * - Full exploitation are performed as follows. ，  * 1. Spraying kernel stack as kernel stack address via running ebpf program. ，  * - We can spray stack up to 512-bytes by running ebpf program. ，  * - After this step , memory to be leaked will be filled with kernel stack address. ，  * 2. Trigger CVE-2016-4486 to leak 4-bytes which is low part of stack address. ，  * - After this step , stack address : 0xffff8800???????? ;  ( ? is unknown address yet. )  ，  * 3. Leak high 4-bytes of stack address. The leaking is done as one-by-one bit. why one-by-one? ，  * - CVE-2016-4486 allows to leak 4-bytes only , so that we always get low 4-bytes of stack address. ，  * - Then , How to overcome this challenge?? The one of possible answer is that ，  * do operation on high-4bytes with carefully selected value which changes low-4bytes. ，  * For example , Assume that real stack address is 0xffff880412340000 ;  ，  * and , do sub operation. ==> 0xffff880412340000 - 0x0000000012360000 ( selected value )  ;  ，  * The result will be \"0xffff8803.....\" ==> Yap ! low 4-bytes are changed !  ! and We can see this !  ，  * The result makes us to know that high 4-bytes are smaller than 0x12360000 ;  ，  * Then , We can keep going with smaller value. ，  * - The algorithm is quite similar to quick-search. ，  * 4. Unfortunately , ebpf program limitation stops us to leak full 64-bits. ，  * - 3-bits ( bit [ 16 ]  , bit [ 15 ]  , bit [ 14 ]  ) are not leaked. ，  * - But , Since 3-bit is not sufficient randomness , It's very valuable for attacker. ，  * Bonus ) Why do I use compat_sendmsg (  ) instead of normal sendmsg (  ) ? ，  * - When I did spraying stack with normal sendmsg (  )  , I couldn't spray up to memory to be leaked. ，  * - If I use compat-sendmsg (  )  , The execution path will be different from normal sendmsg (  ) . ，  * This makes me to spray it more far. ，  *  [ Run exploit ]  ，  * - $ gcc poc.c -o poc ，  * - $ ./poc ，  * .... ，  * .... ，  * leak stack address range :  ，  * -from : ffff88007f7e0000 ，  * -to : ffff88007f7fc000 ，  *  ( Since we can get 61-bit address , Print the possible address range out. )  ，  *  [ Contact ]  ，  * - jinb.park7 @ gmail.com ，  * - github.com/jinb-park ，  * /",
    "time": "2018-12-19"
}