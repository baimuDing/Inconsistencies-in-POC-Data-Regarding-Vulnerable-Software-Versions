{
    "text": "published_time: 2016-12-23 ， id: 34624 ， eid: 40961 ， cve: CVE-2016-0736 ， title: Apache mod_session_crypto - Padding Oracle - Multiple webapps Exploit ， author: RedTeam Pentesting GmbH ， published_time: 2016-12-23 ， verified: Not Verified ， platform: Multiple ， exploit_type: webapps ， exploit_url: /download/40961 ， exploit_detail: '''\r ， Advisory: Padding Oracle in Apache mod_session_crypto\r ， During a penetration test, RedTeam Pentesting discovered a Padding\r ， Oracle vulnerability in mod_session_crypto of the Apache web server.\r ， This vulnerability can be exploited to decrypt the session data and even\r ， encrypt attacker-specified data.\r ， Details\r ， Product: Apache HTTP Server mod_session_crypto\r ， Affected Versions: 2.3 to 2.5\r ， Fixed Versions: 2.4.25\r ， Vulnerability Type: Padding Oracle\r ， Security Risk: high\r ， Vendor URL: \r ， Vendor Status: fixed version released\r ， Advisory URL: \r ， Advisory Status: published\r ， CVE: CVE-2016-0736\r ， CVE URL: \r ， Introduction\r ， The module mod_session_crypto of the Apache HTTP Server can be used in\r ， conjunction with the modules mod_session and mod_session_cookie to store\r ， session data in an encrypted cookie within the users' browsers. This\r ， avoids server-side session state so that incoming HTTP requests can be\r ， easily distributed amongst a number of application web servers which do\r ， not need to share session state.\r ， More Details\r ， The module mod_session_crypto uses symmetric cryptography to encrypt and\r ， decrypt session data and uses mod_session to store the encrypted data in\r ， a cookie (usually called \"session\") within the user's browser. The\r ， decrypted session is then made available to the application in an\r ， environment variable (in case of a CGI script) or in a custom HTTP\r ， request header. The application can add a custom HTTP response header\r ， (usually \"X-Replace-Session\") which instructs the HTTP server to replace\r ， the session's content with the value of the header. Detailed\r ， instructions to set up mod_session and mod_session_crypto can be found\r ， in the documentation:\r ， The module mod_session_crypto is configured to use either 3DES or AES\r ， with various key sizes, defaulting to AES256. Encryption is handled by\r ， the function \"encrypt_string\":\r ， modules/session/mod_session_crypto.c\r ，  * Encrypt the string given as per the current config.\r ，  * Returns APR_SUCCESS if successful.\r ，  */\r ， static apr_status_t encrypt_string(request_rec * r, const apr_crypto_t *f,\r ，         session_crypto_dir_conf *dconf, const char *in, char out)\r ， [...]\r ，     apr_crypto_key_t *key = NULL;\r ， [...]\r ，     const unsigned char *iv = NULL;\r ， [...]\r ，     /* use a uuid as a salt value, and prepend it to our result */\r ，     apr_uuid_get(&salt);\r ， [...]\r ，     res = apr_crypto_passphrase(&key, &ivSize, passphrase,\r ，             strlen(passphrase),\r ，             (unsigned char *) (&salt), sizeof(apr_uuid_t),\r ，             *cipher, APR_MODE_CBC, 1, 4096, f, r->pool);\r ， [...]\r ，     res = apr_crypto_block_encrypt_init(&block, &iv, key, &blockSize, r->pool);\r ， [...]\r ，     res = apr_crypto_block_encrypt(&encrypt, &encryptlen, (unsigned char *)in,\r ，             strlen(in), block);\r ， [...]\r ，     res = apr_crypto_block_encrypt_finish(encrypt + encryptlen, &tlen, block);\r ， [...]\r ，     /* prepend the salt and the iv to the result */\r ，     combined = apr_palloc(r->pool, ivSize + encryptlen + sizeof(apr_uuid_t));\r ，     memcpy(combined, &salt, sizeof(apr_uuid_t));\r ，     memcpy(combined + sizeof(apr_uuid_t), iv, ivSize);\r ，     memcpy(combined + sizeof(apr_uuid_t) + ivSize, encrypt, encryptlen);\r ，     /* base64 encode the result */\r ，     base64 = apr_palloc(r->pool, apr_base64_encode_len(ivSize + encryptlen +\r ，                     sizeof(apr_uuid_t) + 1)\r ，             * sizeof(char));\r ， [...]\r ， The source code shows that an encryption key is derived from the\r ， configured password and a randomly chosen salt by calling the function\r ， \"apr_crypto_passphrase\". This function internally uses PBKDF2 to derive\r ， the key. The data is then encrypted and the salt and IV prepended to the\r ， encrypted data. Before returning to the caller, the result is encoded as\r ， base64.\r ， This procedure does not guarantee integrity of the ciphertext, so the\r ， Apache module is unable to detect whether a session sent back to the\r ， server has been tampered with. Depending on the application this often\r ， means that attackers are able to exploit a Padding Oracle vulnerability.\r ， This allows decrypting the session and encrypting arbitrary data chosen\r ， by the attacker."
}