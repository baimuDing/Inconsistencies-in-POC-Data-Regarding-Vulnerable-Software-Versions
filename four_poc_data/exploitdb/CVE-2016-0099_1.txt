{
    "text": "ecve : CVE-2016-0099 ， title : Microsoft Windows 8.1/10 ( x86 ) - Secondary Logon Standard Handles Missing Sanitization Privilege Escalation ( MS16-032 ) - Windows_x86 local Exploit ， verified : Verified ， exploit_detail : / *  ， Sources :  ， Windows : Secondary Logon Standard Handles Missing Sanitization EoP ， Platform : Windows 8.1 , Windows 10 , not testing on Windows 7 ， Class : Elevation of Privilege ， Summary :  ， The SecLogon service does not sanitize standard handles when creating a new process leading to duplicating a system service thread pool handle into a user accessible process. This can be used to elevate privileges to Local System. ， Description :  ， The APIs CreateProcessWithToken and CreateProcessWithLogon are exposed to user applications , however theyre actually implemented in a system service , Secondary Logon. When these methods are called its actually dispatched over RPC to the service. ， Both these methods take the normal STARTUPINFO structure and supports the passing of standard handles when the STARTF_USESTDHANDLES is used. Rather than the standard way of inheriting these handles to the new process the service copies them manually using the SlpSetStdHandles function. This does something equivalent to :  ， BOOL SlpSetStdHandles ( HANDLE hSrcProcess , HANDLE hTargetProcess , HANDLE handles [  ]  ) { ， foreach ( HANDLE h : handles ) { ， DuplicateHandle ( hSrcProcesss , h , hTargetProcess , &hNewHandle , 0 , FALSE , DUPLICATE_SAME_ACCESS )  ;  ， The vulnerability is nothing sanitizes these values. NtDuplicateObject special cases a couple of values for the source handle , Current Process ( -1 ) and Current Thread ( -2 ) . NtDuplicateObject switches the threads current process to the target process when duplicating the handle , this means that while duplicating -1 will return a handle to the new process -2 will return a handle to the current thread which is actually a thread inside the svchost process hosting seclogon. When passing DUPLICATE_SAME_ACCESS for the current thread handle it's automatically given THREAD_ALL_ACCESS rights. The handle now exists in the new process and can be used by low privileged code. ， This can be exploited in a number of ways. The new process can set the threads context causing the thread to dispatch to an arbitrary RIP. Or as these are thread pool threads servicing RPC requests for services such as BITS , Task Scheduler or seclogon itself you could do things like force a system level impersonation token ( repeatedly ) which overrides the security enforcement of these services leading to arbitrary file writes or process creation at Local System. It would be easy enough to run the exploit multiple times to capture handles to all thread pool threads available for RPC in the hosting process and then just keep trying until it succeeds. ， One final point on exploitability. A normal user cannot use CreateProcessWithToken as the service checks that an arbitrary process can be opened by the user and has SeImpersonatePrivilege in its primary token. CreateProcessWithLogon will work but it seems youd need to know a users password which makes it less useful for a malicious attacker. However you can specify the LOGON_NETCREDENTIALS_ONLY flag which changes the behaviour of LogonUser , instead of needing valid credentials the password is used to change the network password of a copy of the callers token. The password can be anything you like , it doesnt matter.",
    "time": "2016-03-21"
}