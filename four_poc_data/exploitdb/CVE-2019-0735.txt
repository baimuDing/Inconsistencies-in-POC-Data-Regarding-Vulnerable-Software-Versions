{
    "text": "ecve : CVE-2019-0735 ， title : Microsoft Windows 10 1809 / 1709 - CSRSS SxSSrv Cached Manifest Privilege Escalation - Windows local Exploit ， verified : Verified ， exploit_detail : Windows : CSRSS SxSSrv Cached Manifest EoP ， Platform : Windows 10 1809 , 1709 ， Class : Elevation of Privilege ， Security Boundary ( per Windows Security Service Criteria )  : User boundary ( and others )  ， Summary :  ， The SxS manifest cache in CSRSS uses a weak key allowing an attacker to fill a cache entry for a system binary leading to EoP. ， Description :  ， Manifest files are stored as XML , typically inside the PE resource section. To avoid having to parse the XML file each time a process starts CSRSS caches the parsed activation context binary format in a simple database. This cache can be queried during process startup or library loading by calling into CSRSS via CsrClientCall resulting in calls to BaseSrvSxsCreateProcess or BaseSrvSxsCreateActivationContext inside SXSSRV.DLL. ， The database is an AVL tree and uses the function BaseSrvActivationContextCacheCompareEntries to identify a hit or miss in the cache. The comparison function only checks the Win32 path to the file , the Win32 base path , the language string , the last write timestamp of the executable and some flags. BaseSrvSxsCreateProcess which is sent during process creation in CreateProcessInternal via the call to BasepConstructSxsCreateProcessMessage queries the cache for a new process , adding an entry to the cache if it doesnt already exist. All the values used by the cache seem to be passed to BasepConstructSxsCreateProcessMessage with no further checking taking place. If an executable does not have a cached manifest entry a process can trivially add their own entry into the cache which would match against another executable file on the system. Once CSRSS has processed the manifest itll map the binary activation context into the new process memory and update the ActivationContextData value in the PEB so that it can be used. ， Adding an arbitrary cache entry is a problem as the keying doesnt take into account the different privilege levels in the same session. For example it should be possible to use this to escape a sandbox by filling in a cache entry for a process that will run at normal user privilege , when that process starts itll get the arbitrary cache entry allowing the attacker to hijack COM",
    "time": "2019-04-16"
}