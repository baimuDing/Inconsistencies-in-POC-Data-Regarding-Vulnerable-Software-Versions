{
    "text": "ecve : CVE-2019-0731 ， title : Microsoft Windows 10 1809 - LUAFV Delayed Virtualization Cross Process Handle Duplication Privilege Escalation - Windows local Exploit ， verified : Verified ， exploit_detail : Windows : LUAFV Delayed Virtualization Cross Process Handle Duplication EoP ， Platform : Windows 10 1809 ( not tested earlier )  ， Class : Elevation of Privilege ， Security Boundary ( per Windows Security Service Criteria )  : User boundary ， Summary :  ， The LUAFV driver doesnt take into account a virtualized handle being duplicated to a more privileged process resulting in EoP. ， Description :  ， When a caller creates the virtualized file handle the process token is checked for VirtualizationEnabled. If the flag is set and the file create request meets all the criteria for delayed virtualization the driver collates all the necessary information such as the virtual store location for the resulting file if it needs to be copied and stores it in the file objects context. ， When a caller performs an operation on the file which is considered a write action , such as writing or issuing any FsControl request then the method LuafvPreWrite is called which will call LuafvPerformDelayedVirtualization. This results in the store file being created and the contents of the original file copied into the new store file before assigning the new file to the original fake file object so that the user can continue to use the file. ， The vulnerability occurs during LuafvPerformDelayedVirtualization. The driver doesnt take into account the possibility that the virtualized file handle has been duplicated to a new process , specifically one which runs at higher privileges. For example if a normal user application creates the virtualized file , but then gets a SYSTEM service to duplicate the handle to itself and call one of the mechanisms to trigger LuafvPerformDelayedVirtualization the file creation will run as the SYSTEM user not the original user , but the path to the file will be the original users virtual store. ， Examples of possible duplicate primitives would be RPC/COM services which duplicate the handle either explicitly through the system_handle RPC attribute or manually by querying for the callers PID and calling DuplicateHandle. Another would be a kernel driver which opens a handle in the current users context ( or takes a handle parameter ) but passes that handle to a system thread for a long running operation. In both these cases the file operation does have to occur without the privileged service impersonating the original caller. ， You can exploit this behavior in at least two ways. Firstly you could replace the virtual store directory with a mount point. When the virtualization process goes to create the final file it will follow the mount point and create the file in an arbitrary location. The contents of the file are completely controllable by the caller , but even if the privileged code overwrites part of the file the original opened handle can be used to get write access to the file afterwards. The second way would be to drop a hardlink to a file that the privileged service can write to in the virtual store , then when the file is opened by the service it becomes possible for the original caller to modify the file. ， Fixing wise Id probably double check something in LuafvPerformDelayedVirtualization before continuing with the file copy. Perhaps something as simple as user SID + IL would be sufficient , or only for users in the same authentication session as that would even prevent its abuse in UAC cases. ， These operations cant be done from any sandbox that I know of so its only a user privilege escalation. Note that the user which manipulates the duplicated handle doesnt need to be an admin , as itd be possible to modify files owned by that user so it might be possible to abuse this for cross-session or LOCAL SERVICE/NETWORK SERVICE attacks.",
    "time": "2019-04-16"
}