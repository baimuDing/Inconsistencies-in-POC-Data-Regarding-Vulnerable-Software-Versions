{
    "text": "published_time: 2010-06-10 ， id: 11841 ， eid: 13808 ， cve: CVE-2010-1885 ， title: Microsoft Windows Help Centre Handles - Malformed Escape Sequences Incorrectly (MS03-044) - Windows remote Exploit ， author: Tavis Ormandy ， published_time: 2010-06-10 ， verified: Verified ， platform: Windows ， exploit_type: remote ， exploit_url: /download/13808 ， exploit_detail: Microsoft Windows Help Centre Handles Malformed Escape Sequences Incorrectly\r ， Help and Support Centre is the default application provided to access online\r ， documentation for Microsoft Windows. Microsoft supports accessing help documents\r ， directly via URLs by installing a protocol handler for the scheme \"hcp\", \r ， a typical example is provided in the Windows XP Command Line  ， available at \r ， Using hcp:// URLs is intended to be safe, as when invoked via the registered\r ， protocol handler the command line parameter /fromhcp is passed to the help\r ， centre application. This flag switches the help centre into a restricted mode,\r ， which will only permit a whitelisted set of help documents and parameters.\r ， This design, introduced in SP2, is reasonably sound. A whitelist of trusted\r ， documents is a safe way of allowing interaction with the documentation from\r ， less-trusted sources. Unfortunately, an implementation error in the whitelist\r ， allows it to be evaded.\r ， URLs are normalised and unescaped prior to validation using\r ， MPC::HTML::UrlUnescapeW(), which in turn uses MPC::HexToNum() to translate URL\r ， escape sequences into their original characters, the relevant code from\r ， helpctr.exe 5.1.2600.5512 (latest at time of writing) is below.\r ， .text:0106684C Unescape:\r ， .text:0106684C        cmp     di, '%'              ; di contains the current wchar in the input URL.\r ， .text:01066850        jnz     short LiteralChar    ; if this is not a '%', it must be a literal character.\r ， .text:01066852        push    esi                  ; esi contains a pointer to the current position in URL to unescape.\r ， .text:01066853        call    ds:wcslen            ; find the remaining length.\r ， .text:01066859        cmp     word ptr [esi], 'u'  ; if the next wchar is 'u', this is a unicode escape and I need 4 xdigits.\r ， .text:0106685D        pop     ecx                  ; this sequence calculates the number of wchars needed (4 or 2).\r ， .text:0106685E        setz    cl                   ; i.e. %uXXXX (four needed), or %XX (two needed).\r ， .text:01066861        mov     dl, cl\r ， .text:01066863        neg     dl\r ， .text:01066865        sbb     edx, edx\r ， .text:01066867        and     edx, 3\r ， .text:0106686A        inc     edx\r ， .text:0106686B        inc     edx\r ， .text:0106686C        cmp     eax, edx             ; test if I have enough characters in input to decode.\r ， .text:0106686E        jl      short LiteralChar    ; if not enough, this '%' is considered literal.\r ， .text:01066870        test    cl, cl\r ， .text:01066872        movzx   eax, word ptr [esi+2]\r ， .text:01066876        push    eax\r ， .text:01066877        jz      short NotUnicode\r ， .text:01066879        call    HexToNum             ; call MPC::HexToNum() to convert this nibble (4 bits) to an integer.\r ， .text:0106687E        mov     edi, eax             ; edi contains the running total of the value of this escape sequence.\r ， .text:01066880        movzx   eax, word ptr [esi+4]\r ， .text:01066884        push    eax\r ， .text:01066885        shl     edi, 4               ; shift edi left 4 positions to make room for the next digit, i.e. total = 4;\r ， .text:01066888        call    HexToNum             \r ， .text:0106688D        or      edi, eax             ; or the next value into the 4-bit gap, i.e. total |= val.\r ， .text:0106688F        movzx   eax, word ptr [esi+6]; this process continues for the remaining wchars.\r ， .text:01066893        push    eax\r ， .text:01066894        shl     edi, 4\r ， .text:01066897        call    HexToNum\r ， .text:0106689C        or      edi, eax\r ， .text:0106689E        movzx   eax, word ptr [esi+8]\r ， .text:010668A2        push    eax\r ， .text:010668A3        shl     edi, 4\r ， .text:010668A6        call    HexToNum\r ， .text:010668AB        or      edi, eax\r ， .text:010668AD        add     esi, 0Ah              ; account for number of bytes (not chars) consumed by the escape.\r ， .text:010668B0        jmp     short FinishedEscape\r ， .text:010668B2\r ， .text:010668B2 NotUni"
}