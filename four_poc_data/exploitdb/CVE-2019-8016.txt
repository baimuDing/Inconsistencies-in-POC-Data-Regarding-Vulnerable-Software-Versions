{
    "text": "published_time: 2019-08-15 ， id: 41556 ， eid: 47259 ， cve: CVE-2019-8016 ， title: Adobe Acrobat CoolType (AFDKO) - Memory Corruption in the Handling of Type 1 Font load/store Operators - Windows dos Exploit ， author: Google Security Research ， published_time: 2019-08-15 ， verified: Verified ， platform: Windows ， exploit_type: dos ， exploit_url: /download/47259 ， exploit_detail: -----=====[ Background ]=====-----\r ， AFDKO (Adobe Font Development Kit for OpenType) is a set of tools for examining, modifying and building fonts. The core part of this toolset is a font handling library written in C, which provides interfaces for reading and writing Type 1, OpenType, TrueType (to some extent) and several other font formats. While the library existed as early as 2000, it was open-sourced by Adobe in 2014 on GitHub [1, 2], and is still actively developed. The font parsing code can be generally found under afdko/c/public/lib/source/*read/*.c in the project directory tree.\r ， We have recently discovered that parts of AFDKO are compiled in in Adobe's desktop software such as Adobe Acrobat. Within a single installation of Acrobat, we have found traces of AFDKO in four different libraries: acrodistdll.dll, Acrobat.dll, CoolType.dll and AdobePDFL.dll. According to our brief analysis, AFDKO is not used for font rasterization (there is a different engine for that), but rather for the conversion between font formats. For example, it is possible to execute the AFDKO copy in CoolType.dll by opening a PDF file with an embedded font, and exporting it to a PostScript (.ps) or Encapsulated PostScript (.eps) document. It is uncertain if the AFDKO copies in other libraries are reachable as an attack surface and how.\r ， It is also interesting to note that the AFDKO copies in the above DLLs are much older than the latest version of the code on GitHub. This can be easily recognized thanks to the fact that each component of the library (e.g. the Type 1 Reader - t1r, Type 1 Writer - t1w, CFF reader - cfr etc.) has its own version number included in the source code, and they change over time. For example, CoolType's version of the \"cfr\" module is 2.0.44, whereas the first open-sourced commit of AFDKO from September 2014 has version 2.0.46 (currently 2.1.0), so we can conclude that the CoolType fork is at least about ~5 years old. Furthermore, the forks in Acrobat.dll and AdobePDFL.dll are even older, with a \"cfr\" version of 2.0.31.\r ， Despite the fact that CoolType contains an old fork of the library, it includes multiple non-public fixes for various vulnerabilities, particularly a number of important bounds checks in read*() functions declared in cffread/cffread.c (e.g. readFDSelect, readCharset etc.). These checks were first introduced in CoolType.dll shipped with Adobe Reader 9.1.2, which was released on 28 May 2009. This means that the internal fork of the code has had many bugs fixed for the last 10 years, which are still not addressed in the open-source branch of the code. Nevertheless, we found more security vulnerabilities which affect the AFDKO used by CoolType, through analysis of the publicly available code. This report describes one such issue reachable through the Adobe Acrobat file export functionality.\r ， -----=====[ Description ]=====-----\r ， The \"Type 2 Charstring Format\" specification from 5 May 1998 introduced two storage operators: store and load, which were both deprecated in the next iteration of the specs in 2000. These operators were responsible for copying data between the transient array (also known as the BuildCharArray, or BCA) and the so-called \"Registry object\".\r ， As the document stated:\r ，     The Registry provides more permanent storage for a number of items that have predefined meanings. The items stored in the Registry do not persist beyond the scope of rendering a font. Registry items are selected with an index, thus:\r ，     0 Weight Vector\r ，     1 Normalized Design Vector\r ，     2 User Design Vector\r ，     The result of selecting a Registry item with an index outside this list is undefined.\r ， The Type 1 CharString interpreter implemented in t1Decode() (c/public/lib/source/t1cstr/t1cstr.c) supports the load and store operators:\r ， --- cut ---\r ，   1450                      case t1_store:\r ，   1451                          result = do_store(h);\r ，   1452                          if (result)\r ，   1453                              return result;\r ，   1454                          continue;\r ， [...]\r ，   1470                      case t1_load:\r ，   1471                          result = do_load(h);\r ，   1472                          if (result)\r ，   1473                              return result;\r ，   1474                          continue;\r ， --- cut ---\r ， The do_store() and do_load() functions are as follows:\r ， --- cut ---\r ，    664  /* Select registry item. Return NULL on invalid selector. */\r ，    665  static float *selRegItem(t1cCtx h, int reg, int *size) {\r ，    666      switch (reg) {\r ，    667          case T1_REG_WV:\r ，    668              *size = T1_MAX_MASTERS;\r ，    669              return h->aux->WV;\r ，    670          case T1_REG_NDV:\r ，    671              *size = T1_MAX_AXES;\r ，    672              return h->aux->NDV;\r ，    673          case T1_REG_UDV:\r ，    674              *size = T1_MAX_AXES;\r ，    675              return h->aux->UDV;\r ，    676      }\r ，    677      return NULL;\r ，    678  }\r ，    679\r ，    680  /* Execute \"store\" op. Return 0 on success else error code. */\r ，    681  static int do_store(t1cCtx h) {\r ，    682      int size;\r ，    683      int count;\r ，    684      int i;\r ，    685      int j;\r ，    686      int reg;\r ，    687      float *array;\r ，    688\r ，    689      CHKUFLOW(4);\r ，    690\r ，    691      count = (int)POP();\r ，    692      i = (int)POP();\r ，    693      j = (int)POP();\r ，    694      reg = (int)POP();\r ，    695      array = selRegItem(h, reg, &size);\r ，    696\r ，    697      if (array == NULL ||\r ，    698          i < 0 || i + count + 1 >= TX_BCA_LENGTH ||\r ，    699          j < 0 || j + count + 1 >= size)\r ，    700          return t1cErrStoreBounds;\r ，    701\r ，    702      memcpy(&array[j], &h->BCA[i], sizeof(float) * count);\r ，    703      return 0;\r ，    704  }\r ，    705\r ， [...]\r ，    736\r ，    737  /* Execute \"load\" op. Return 0 on success else error code. */\r ，    738  static int do_load(t1cCtx h) {\r ，    739      int size;\r ，    740      int count;\r ，    741      int i;\r ，    742      int reg;\r ，    743      float *array;\r ，    744\r ，    745      CHKUFLOW(3);\r ，    746\r ，    747      count = (int)POP();\r ，    748      i = (int)POP();\r ，    749      reg = (int)POP();\r ，    750      array = selRegItem(h, reg, &size);\r ，    751\r ，    752      if (i < 0 || i + count - 1 >= TX_BCA_LENGTH || count > size)\r ，    753          return t1cErrLoadBounds;\r ，    754\r ，    755      memcpy(&h->BCA[i], array, sizeof(float) * count);\r ，    756\r ，    757      return 0;\r ，    758  }\r ， --- cut ---\r ， While both routines try to enforce proper bounds of the indexes and lengths (lines 697-700 and 752-753), they miss one important corner case -- negative count. When a value smaller than 0 is specified for \"count\", many of the other sanity checks can be bypassed, and out-of-bounds read/write access can be triggered with a high degree of control over what is copied where. The condition is especially dangerous in x86 builds, where a controlled 32-bit index added to a memory pointer can address the entire process address space. At the time of this writing, Adobe Acrobat for Windows is available as a 32-bit build only.\r ， To give an example, setting count to a value in the range of 0x80000000-0xbfffffff makes it possible to set the \"sizeof(float) * count\" expression evaluate to an arbitrary multiple of 4 (0, 4, 8, ..., 0xfffffff8), enabling us to copy any chosen number of bytes in lines 702 and 755. At the same time, the value is so small that it bypasses all checks where \"i + count\" and \"j + count\" are involved for i, j in the range of 0-0x3fffffff, which also enables us to refer to the entire address space relative to the referenced buffer.\r ， To summarize, we can copy an arbitrary number of bytes between h->BCA[] and the registry arrays at arbitrary offsets, which is a powerful primitive. There is only one obstacle -- the fact that values on the interpreter stack are stored as 32-bit floats, which means they have a 23-bit mantissa. For this reason, it is impossible to precisely control the integer values of i, j and count, if they are in the order of 2^30 or 2^31. The granularity is 128 for numbers around 2^30 and 256 for numbers around 2^31, so for example it is impossible to set i to 0x3fffffff or count to 0x80000001; the closest values are 0x3fffff80/0x40000000 and 0x80000000/0x80000100, respectively. In practice, this means that we can only copy out-of-bounds memory in chunks of 512 bytes (4 * 128) or 1024 under specific conditions, and that we can only choose negative offsets relative to BCA/array which are divisible by 128. On the other hand, if we set count to a largely negative value (e.g. -1073741696), we can set i and j to fully controlled (small) positive numbers.\r ， The h->BCA[] array is stored within the t1cCtx structure in the stack frame of the t1cParse() function. The registry arrays reside within t1cAuxData structures allocated on the heap. As a result, the vulnerability gives us out-of-bounds access to both the stack and heap. An attacker could target generic data in memory related to the control flow such as return addresses, or application-specific data inside t1cCtx/t1cAuxData, which also contain many sensitive fields such as function pointers etc.\r ， As a side note, the do_load() routine doesn't verify that array != NULL, which may result in a) operating on an uninitialized \"size\" variable in line 752, and b) passing NULL as the source parameter to memcpy() in line 755.\r ， -----=====[ Invalid memcpy_s usage ]=====-----\r ， We also wanted to point out another interesting bug in AFDKO, which is not present in the GitHub repository but can be found in CoolType. The latter build of the code uses safe variants of many standard functions, such as memcpy_s() instead of memcpy(), vs"
}