{
    "text": "ecve : CVE-2018-0748 ， title : Microsoft Windows - NTFS Owner/Mandatory Label Privilege Bypass - Windows dos Exploit ， verified : Verified ， exploit_detail : / *  ， Windows : NTFS Owner/Mandatory Label Privilege Bypass EoP ， Platform : Windows 10 1709 not tested 8.1 Update 2 or Windows 7 ， Class : Elevation of Privilege ， Summary :  ， When creating a new file on an NTFS drive its possible to circumvent security checks for setting an arbitrary owner and mandatory label leading to a non-admin user setting those parts of the security descriptor with non-standard values which could result in further attacks resulting EoP. ， Description :  ， The kernel limits who can arbitrarily set the Owner and Mandatory Label fields of a security descriptor. Specifically unless the current token has SeRestorePrivilege , SeTakeOwnershipPrivilege or SeRelabelPrivilege you can only set an owner which is set in the current token ( for the label is can also be less than the current label ) . As setting an arbitrary owner in the token or raising the IL is also a privileged operation this prevents a normal user from setting these fields to arbitrary values. ， When creating a new file on an NTFS volume you can specify an arbitrary Security Descriptor with the create request and it will be set during the creation process. If you specify an arbitrary owner or label it will return an error as expected. Looking at the implementation in NTFS the function NtfsCreateNewFile calls NtfsAssignSecurity which then calls the kernel API SeAssignSecurityEx. The problem here is that SeAssignSecurityEx doesnt take an explicit KPROCESSOR_MODE argument so instead the kernel takes the current threads previous access mode. The previous mode however might not match up with the current assumed access mode based on the caller , for example if the create call has been delegated to a system thread. ， A common place this mode mismatch occurs is in the SMB server , which runs entirely in the system process. All threads used by SMB are running with a previous mode of KernelMode , but will create files by specifying IO_FORCE_ACCESS_CHECK so that the impersonated caller identity is used for security checks. However if you specify a security descriptor to set during file creation the SMB server will call into NTFS ending up in SeAssignSecurityEx which then thinks its been called from KernelMode and bypasses the Owner/Label checks. ， Is this useful? Almost certainly theres some applications out there which use the Owner or Label as an indicator that only an administrator could have created the file ( even if thats not a very good security check ) . For example VirtualBox uses it as part of its security checks for whether a DLL is allowed to be loaded in process ( see my blog about it so I could imagine other examples including Microsoft products. Another example is process creation where the kernel checks the file's label to determine if it needs to drop the IL on the new process , I don't think you can increase the IL but maybe there's a way of doing so. ， Based on the implementation this looks like it would also bypass the checks for setting the SACL , however due to the requirement for an explicit access right this is blocked earlier in the call through the SMBv2 client. Ive not checked if using an alternative SMBv2 client implementation such as SAMBA would allow you to bypass this restriction or whether its still blocked in the server code. ， Its hard to pin down which component is really at fault here. It could be argued that SeAssignSecurityEx should take a KPROCESSOR_MODE parameter to determine the security checks rather than using the threads previous mode. Then again perhaps NTFS needs to do some pre-checking of its own? And of course this wouldnt be an issue if the SMB server driver didnt run in a system thread. Note this doesnt bypass changing the Owner/Label of an existing file , its only an issue when creating a new file.",
    "time": "2018-01-11"
}