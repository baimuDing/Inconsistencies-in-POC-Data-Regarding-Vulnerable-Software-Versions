{
    "text": "ecve : CVE-2019-13272 ， title : Linux - Broken Permission and Object Lifetime Handling for PTRACE_TRACEME - Linux local Exploit ， verified : Verified ， exploit_detail : == Summary == ， This bug report describes two issues introduced by commit 64b875f7ac8a ( \"ptrace :  ， Capture the ptracer's creds not PT_PTRACE_CAP\" , introduced in v4.10 but also ， stable-backported to older versions ) . I will send a suggested patch in a minute ，  ( \"ptrace : Fix ->ptracer_cred handling for PTRACE_TRACEME\" ) . ， When called for PTRACE_TRACEME , ptrace_link (  ) would obtain an RCU reference ， to the parent's objective credentials , then give that pointer to ， get_cred (  ) . However , the object lifetime rules for things like struct cred ， do not permit unconditionally turning an RCU reference into a stable ， reference. ， PTRACE_TRACEME records the parent's credentials as if the parent was acting ， as the subject , but that's not the case. If a malicious unprivileged child ， uses PTRACE_TRACEME and the parent is privileged , and at a later point , the ， parent process becomes attacker-controlled ( because it drops privileges and ， calls execve (  )  )  , the attacker ends up with control over two processes with ， a privileged ptrace relationship , which can be abused to ptrace a suid ， binary and obtain root privileges. ， == Long bug description == ， While I was trying to refactor the cred_guard_mutex logic , I stumbled over the ， following issues :  ， ptrace relationships can be set up in two ways : Either the tracer attaches to ， another process ( PTRACE_ATTACH/PTRACE_SEIZE )  , or the tracee forces its parent to ， attach to it ( PTRACE_TRACEME ) . ， When a tracee goes through a privilege-gaining execve (  )  , the kernel checks ， whether the ptrace relationship is privileged. If it is not , the ， privilege-gaining effect of execve is suppressed. ， The idea here is that a privileged tracer ( e.g. if root runs \"strace\" on ， some process ) is allowed to trace through setuid/setcap execution , but an ， unprivileged tracer must not be allowed to do that , since it could otherwise ， inject arbitrary code into privileged processes. ， In the PTRACE_ATTACH/PTRACE_SEIZE case , the tracer's credentials are recorded at ， the time it calls PTRACE_ATTACH/PTRACE_SEIZE ; later , when the tracee goes ， through execve (  )  , it is checked whether the recorded credentials are capable ， over the tracee's user namespace. ， But in the PTRACE_TRACEME case , the kernel also records _the tracer's_ ， credentials , even though the tracer is not requesting the operation. There are ， two problems with that. ， First , there is an object lifetime issue :  ， ptrace_traceme (  ) -> ptrace_link (  ) grabs __task_cred ( new_parent ) in an RCU ， read-side critical section , then passes the creds to __ptrace_link (  )  , which ， calls get_cred (  ) on them. If the parent concurrently switches its creds ( e.g. ， via setresuid (  )  )  , the creds' refcount may already be zero , in which case ， put_cred_rcu (  ) will already have been scheduled. The kernel usually manages to ， panic (  ) before memory corruption occurs here using the following code in ， put_cred_rcu (  )  ; however , I think memory corruption would also be possible if ， this code races exactly the right way. ， panic ( \"CRED : put_cred_rcu (  ) sees %p with usage %d\\n\" ,  ， cred , atomic_read ( &cred->usage )  )  ;  ， A simple",
    "time": "2019-07-17"
}