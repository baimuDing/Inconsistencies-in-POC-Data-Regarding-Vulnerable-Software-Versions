{
    "text": "ecve : CVE-2013-5697 ， title : mod_accounting Module 0.5 - Blind SQL Injection - Linux webapps Exploit ， verified : Not Verified ， exploit_detail : - Affected Vendor :  ， - Affected Software : mod_accounting ， - Affected Version : 0.5. Other earlier versions may be affected. ， - Issue type : Blind SQL injection ， - Release Date : 20 Sep 2013 ， - Discovered by : Eldar \"Wireghoul\" Marcussen ， - CVE Identifier : CVE-2013-5697 ， - Issue status : Abandoned software , no patch available ， Summary ， mod_accounting is a traffic accounting module for Apache 1.3.x which ， records traffic numbers in a database. Both MySQL and PostgreSQL database ， types are supported. It supports arbitrary database designs as traffic ， recording is performed via a user defined query in the Apache configuration ， using placeholders for received values. The following is an example ， configuration :  ， <VirtualHost _default_ :  * > ， DocumentRoot \"/var/www/\" ， Options Indexes ， AccountingQueryFmt \"INSERT INTO accounting VALUES ( current_time , %r , %s ,  ， '%u' , '%h' )  ; \" ， AccountingDatabase accounting ， AccountingDatabaseDriver postgres ， AccountingDBHost localhost 5432 ， AccountingLoginInfo acct acct ， </VirtualHost> ， As user supplied values are not sanitised before being used in the ， placeholder values it is possible for an attacker to supply malicous values ， to perform blind SQL injection. ， Description ， The SQL injection occurs due to a user supplied HTTP header being used in ， the query without sanitisation. The module uses a simple string ， concatination approach to modify the placeholders in the user defined query ， before sending it to the database. This code can be located in ， mod_accounting.c :  ， 409 : // build the query string from the template ， 410 : while ( ptr ) { ， 411 : char * next ;  ， 412 :  ， 413 : next = strchr ( ptr , '%' )  ;  ， 414 :  ， 415 : if ( next ) { ， 416 : char tmp [ 2 ]  ;  ， 417 :  ， 418 :  * next++ = '\\0' ;  ， 419 :  ， 420 : switch (  * next++ ) { ， 421 :  ， 422 : case 'h' :  ， 423 : query = ap_pstrcat ( p , query , ptr , cfg->ServerName ? ， cfg->ServerName : \"-\" , NULL )  ;  ， 424 : break ;  ， 425 :  ， 426 : case 's' :  ， 427 : query = ap_pstrcat ( p , query , ptr , sent , NULL )  ;  ， 428 : break ;  ， 429 :  ， 430 : case 'r' :  ， 431 : query = ap_pstrcat ( p , query , ptr , recvd , NULL )  ;  ， 432 : break ;  ， 433 :  ， 434 : case 'u' :  ， 435 : query = ap_pstrcat ( p , query , ptr , get_user ( r )  , NULL ，  )  ;  ， 436 : break ;  ， 437 :  ， 438 : default :  ， 439 : tmp [ 0 ] = next [ -1 ]  ;  ， 440 : tmp [ 1 ] = '\\0' ;  ， 441 :  ， 442 : query = ap_pstrcat ( p , query , ptr , tmp , NULL )  ;  ， 443 : break ;  ， 444 : } ， 445 :  ， 446 : next [ -2 ] = '%' ;  ， 447 :  ， 448 : } else ， 449 : query = ap_pstrcat ( p , query , ptr , NULL )  ;  ， 450 :  ， 451 : ptr = next ;  ， 452 : } ， 453 :  ， 454 :  (  * DBDrivers [ cfg->DBDriver ] .Query )  ( cfg , server , p , query )  ;  ， 455 :  ， 456 : cfg->Received = cfg->Sent = 0 ;  ， It is important to note that the database query takes place after the page ， has been served , hence there is no easy way to determine if a particular ， injection method was successful apart from using an out of band approach. ， However , as the injection occurs in an insert statement it is likely that ， the successful injection vector is one of about a handful of likely ， candidates. ， Impact ， An attacker is only limited by the capabilities of the database ， configuration and may be able to read , add , alter or delete data from your ， database ( s )  , read or write arbitrary files or even execute commands on the ， server given a privileged database account.",
    "time": "2013-09-30"
}