{
    "text": "ecve : CVE-2015-0240 ， title : Samba < 3.6.2 ( x86 ) - Denial of Service ( PoC ) - Linux_x86 dos Exploit ， verified : Not Verified ， exploit_detail :  #  ! /usr/bin/python ， Exploit for Samba vulnerabilty ( CVE-2015-0240 ) by sleepya ， The exploit only targets vulnerable x86 smbd <3.6.24 which 'creds' is controlled by ， ReferentID field of PrimaryName ( ServerName ) . That means '_talloc_zero (  ) ' ， in libtalloc does not write a value on 'creds' address. ， Note :  ， - heap might be changed while running exploit , need to try again ( with '-hs' or '-pa' option )  ， Find heap address :  ， - ubuntu PIE heap start range : b7700000 - b9800000 ， - start payload size : the bigger it is the lesser connection and binding time. ， but need more time to shrink payload size ， - payload is too big to fit in freed small hole. so payload is always at end ， of heap ， - start bruteforcing heap address from high memory address to low memory address ， to prevent 'creds' pointed to real heap chunk ( also no crash but not our payload )  ， Leak info :  ， - heap layout is predictable because talloc_stackframe_pool ( 8192 ) is called after ， accepted connection and fork but before calling smbd_server_connection_loop_once (  )  ， - before talloc_stackframe_pool ( 8192 ) is called , there are many holes in heap ， but their size are <8K. so pool is at the end of heap at this time ， - many data that allocated after talloc_stackframe_pool ( 8192 ) are allocated in pool. ， with the same pattern of request , the layout in pool are always the same. ， - many data are not allocated in pool but fit in free holes. so no small size data are ， allocated after pool. ， - normally there are only few data block allocated after pool. ， - pool size : 0x2048 ( included glibc heap header 4 bytes )  ， - a table that created in giconv_open (  ) . the size is 0x7f88 ( included glibc heap header 4 bytes )  ， - p->in_data.pdu.data. the size is 0x10e8 ( included glibc heap header 4 bytes )  ， - this might not be allocated here because its size might fit in freed hole ， - all fragment should be same size to prevent talloc_realloc (  ) changed pdu.data size ， - so last fragment should be padded ， - ndr DATA_BLOB. the size is 0x10d0 ( included glibc heap header 4 bytes )  ， - this might not be allocated here because its size might fit in freed hole ， - p->in_data.data.data. the size is our netlogon data ， - for 8K payload , the size is 0x2168 ( included glibc heap header 4 bytes )  ， - this data is allocated by realloc (  )  , grew by each fragment. so this memory ， block is not allocated by mmapped even the size is very big. ， - pool layout for interested data ， - r->out offset from pool ( talloc header ) is 0x13c0 ， - r->out.return_authenticator offset from pool is 0x13c0+0x18 ， - overwrite this ( with link unlink ) to leak info in ServerPasswordSet response ， - smb_request offset from pool ( talloc header ) is 0x11a0 ， - smb_request.sconn offset from pool is 0x11a0+0x3c ， - socket fd is at smb_request.sconn address ( first struct member )  ， - more shared folder in configuration , more freed heap holes ， - only if there is no or one shared , many data might be unexpected allocated after pool. ， have to get that extra offset or bruteforce it ， More exploitation detail in code ( comment )  ;  ) ",
    "time": "2015-04-13"
}