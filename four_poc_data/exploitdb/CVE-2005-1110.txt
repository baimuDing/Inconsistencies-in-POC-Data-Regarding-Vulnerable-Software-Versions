{
    "text": "ecve : CVE-2005-1110 ， title : Sumus 0.2.2 - HTTPd Remote Buffer Overflow - Linux remote Exploit ， verified : Verified ， exploit_detail : / *  [ sumus [ v0.2.2 ]  :  ( httpd ) remote buffer overflow exploit. ]  ，  *  *  ，  * by : vade79/v9 v9 @ fakehalo.us ( fakehalo/realhalo )  *  ，  *  *  ，  * compile :  *  ，  * gcc xsumus.c -o xsumus *  ，  *  *  ，  * syntax :  *  ，  * ./xsumus [ -pscrln ] -h host *  ，  *  *  ，  * sumus homepage/url :  *  ，  *  *  ，  *  *  ，  * Mus is a Spanish cards game played by 4 folks around a *  ，  * table. SUMUS is a server for playing mus over Internet. The *  ，  * project is just the server , but Java applet and Linux *  ，  * console clients are provided. *  ，  *  *  ，  * SUMUS contains a remotely exploitable buffer overflow in *  ，  * the httpd portion of its server code , which runs *  ，  * automatically upon starting the SUMUS server ( usually port *  ，  * 81 ) . *  ，  *  *  ，  * the overflow itself occurs on the stack , but it isn't quite *  ，  * cut and dry as normal. this overflow occurs in a while (  )  *  ，  * byte-by-byte write loop , and the integers used in the loop *  ，  * get overwritten before it makes it to the eip/return *  ，  * address. this is best explained by viewing the code *  ，  * itself :  *  ，  *  *  ，  * ----------------------------------------------------------- *  ，  * char Buffer [ 65536 ]  ;  *  ，  * ... *  ，  * k = recv ( SocketWebPendientes [ j ]  , Buffer , 20480 , 0 )  ;  *  ，  * if ( k > 0 )  *  ，  * RespondeHTTPPendiente ( j )  ;  *  ，  * ... *  ，  * void RespondeHTTPPendiente ( int Pos )  *  ，  * { *  ，  * int j , kk , faltan ;  *  ，  * char tmpCad [ 100 ]  ,  * p1 ,  * p2 ;  *  ，  * FILE * f ;  *  ，  *  *  ，  * Buffer [ 400 ] = 0 ;  *  ，  * p1 = strstr ( Buffer , \"GET\" )  ;  *  ，  * if ( p1 == NULL ) p1 = strstr ( Buffer , \"Get\" )  ;  *  ，  * if ( p1 == NULL ) p1 = strstr ( Buffer , \"get\" )  ;  *  ，  * if ( p1 ! = NULL )  *  ，  * { *  ，  * j = 5 ;  *  ，  * kk = 0 ;  *  ，  * if ( j < strlen ( p1 )  )  *  ，  * while ( p1 [ j ]  ! = ' ' p1 [ j ]  )  *  ，  * tmpCad [ kk++ ] = p1 [ j++ ]  ;  *  ，  * tmpCad [ kk ] = 0 ;  *  ，  * } *  ，  * ... *  ，  * ----------------------------------------------------------- *  ，  *  *  ，  * as you can see this makes for a special situation. the *  ，  * best method i came up with was to format the buffer like *  ，  * so :  *  ，  *  [ 400 bytes ]  |  [ 20000 bytes ]  *  ，  *  [ FILLER ]  [ \"GET\" ]  [ FILLER ]  [ new \"kk\" ]  [ ADDR ]  |  [ EGG/SHELLCODE ]  *  ，  *  *  ，  * this way since the new \"kk\"/addr ends right the 400 *  ，  * boundary point , only the overwritten \"kk\" integer needs to *  ，  * be worried about ( and not the \"j\" integer as well ) . *  ，  *  *  ，  * i mainly made this because it was a moderatly different *  ，  * exploit method than the norm. figured i'd see if it could *  ，  * be done , and here we are. *  ，  *  *  ，  * tested with default values ( on static binary )  :  *  ，  * + gentoo-r5 : successful. *  ，  * + mandrake9.1/default : successful. *  ，  * + mandrake9.1/secure : failed. *  ，  * + fedora core2 : successful. * ",
    "time": "2005-04-14"
}