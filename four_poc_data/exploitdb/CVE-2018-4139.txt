{
    "text": "ecve : CVE-2018-4139 ， title : Apple macOS 10.13.2 - Double mach_port_deallocate in kextd due to Failure to Comply with MIG Ownership Rules - macOS dos Exploit ， verified : Verified ， exploit_detail : Here's a kextd method exposed via MIG ( com.apple.KernelExtensionServer )  ， kern_return_t _kextmanager_unlock_kextload (  ， mach_port_t server ,  ， mach_port_t client )  ， kern_return_t mig_result = KERN_FAILURE ;  ， OSKextLog ( / * kext * / NULL ,  ， kOSKextLogErrorLevel | kOSKextLogIPCFlag ,  ， \"Non-root kextutil doesn't need to lock/unlock.\" )  ;  ， mig_result = KERN_SUCCESS ;  ， goto finish ;  ， OSKextLog ( / * kext * / NULL ,  ， kOSKextLogErrorLevel | kOSKextLogIPCFlag ,  ， \"%d not used to lock for kextutil.\" , client )  ;  ， goto finish ;  ， removeKextutilLock (  )  ;  ， mig_result = KERN_SUCCESS ;  ， finish :  ， // we don't need the extra send right added by MiG ， mach_port_deallocate ( mach_task_self (  )  , client )  ;  ， If the client has UID 0 but passes an invalid client port this code will ， drop a UREF on client port then return KERN_FAILURE. ， Returning KERN_FAILURE in MIG means all resources will be released which will ， cause client to be passed to mach_port_deallocate again , even though only ， one UREF was taken. ， You'll have to use a debugger attached to kextd to see this behaviour. ， This",
    "time": "2018-04-30"
}