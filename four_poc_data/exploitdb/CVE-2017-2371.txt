{
    "text": "ecve : CVE-2017-2371 ， title : Apple WebKit 10.0.2 - Cross-Origin or Sandboxed IFRAME Pop-up Blocker Bypass - Multiple webapps Exploit ， verified : Verified ， exploit_detail : < ! -- ， Source :  ， The second argument of window.open is a name for the new window. If there's a frame that has same name , it will try to load the URL in that. If not , it just tries to create a new window and pop-up. But without the user's click event , its attempt will fail. ， Here's some snippets. ， RefPtr<DOMWindow> DOMWindow :  : open ( const String& urlString , const AtomicString& frameName , const String& windowFeaturesString ,  ， DOMWindow& activeWindow , DOMWindow& firstWindow )  ， ---------------- ( 1 ) ----------------------- ， // Because FrameTree :  : find (  ) returns true for empty strings , we must check for empty frame names. ， // Otherwise , illegitimate window.open (  ) calls with no name will pass right through the popup blocker. ， RefPtr<Frame> result = createWindow ( urlString , frameName , parseWindowFeatures ( windowFeaturesString )  , activeWindow ,  * firstFrame ,  * m_frame )  ;  ， RefPtr<Frame> DOMWindow :  : createWindow ( const String& urlString , const AtomicString& frameName , const WindowFeatures& windowFeatures , DOMWindow& activeWindow , Frame& firstFrame , Frame& openerFrame , std :  : function<void ( DOMWindow& ) > prepareDialogFunction )  ， RefPtr<Frame> newFrame = WebCore :  : createWindow (  * activeFrame , openerFrame , frameRequest , windowFeatures , created )  ;  ， RefPtr<Frame> createWindow ( Frame& openerFrame , Frame& lookupFrame , const FrameLoadRequest& request , const WindowFeatures& features , bool& created )  ， ASSERT (  ! features.dialog |  | request.frameName (  ) .isEmpty (  )  )  ;  ， created = false ;  ， ---------------- ( 2 ) ----------------------- ， page->chrome (  ) .focus (  )  ;  ， ----------- failed to find the frame , creates a new one. ， The logic of the code ( 1 ) depends on the assumption that if | m_frame->tree (  ) .find ( frameName )  | succeeds ,  | lookupFrame.loader (  ) .findFrameForNavigation | at ( 2 ) will also succeed. If we could make | m_frame->tree (  ) .find ( frameName )  | succeed but | lookupFrame.loader (  ) .findFrameForNavigation | fail , a new window will be created and popped up without the user's click event. ， Let's look into | findFrameForNavigation | . ， Frame * FrameLoader :  : findFrameForNavigation ( const AtomicString& name , Document * activeDocument )  ， Frame * frame = m_frame.tree (  ) .find ( name )  ;  ， // FIXME : Eventually all callers should supply the actual activeDocument so we can call canNavigate with the right document. ， activeDocument = m_frame.document (  )  ;  ， bool Document :  : canNavigate ( Frame * targetFrame )  ， const char * reason = \"The frame attempting navigation is sandboxed , and is therefore disallowed from navigating its ancestors.\" ;  ， reason = \"The frame attempting navigation of the top-level window is sandboxed , but the 'allow-top-navigation' flag is not set.\" ; ",
    "time": "2017-02-24"
}