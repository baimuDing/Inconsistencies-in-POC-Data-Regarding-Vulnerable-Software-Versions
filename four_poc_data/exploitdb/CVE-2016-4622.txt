{
    "text": "ecve : CVE-2016-4622 ， title : Phrack : Attacking JavaScript Engines : A case study of JavaScriptCore and CVE-2016-4622 ( saelo ) - Magazine papers Exploit ， verified : Verified ， exploit_detail :  | =-----------------------------------------------------------------------= |  ，  | =---------------= [ The Art of Exploitation ] =---------------= |  ，  | =-----------------------------------------------------------------------= |  ，  | =------------------= [ Attacking JavaScript Engines ] =-------------------= |  ，  | =--------= [ A case study of JavaScriptCore and CVE-2016-4622 ] =---------= |  ，  | =-----------------------------------------------------------------------= |  ，  | =----------------------------= [ saelo ] =--------------------------------= |  ，  | =-----------------------= [ phrack @ saelo.net ] =--------------------------= |  ，  | =-----------------------------------------------------------------------= |  ， -- [ Table of contents ， 0 - Introduction ， 1 - JavaScriptCore overview ， 1.1 - Values , the VM , and ( NaN- ) boxing ， 1.2 - Objects and arrays ， 1.3 - Functions ， 2 - The bug ， 2.1 - The vulnerable code ， 2.2 - About JavaScript type conversions ， 2.3 - Exploiting with valueOf ， 2.4 - Reflecting on the bug ， 3 - The JavaScriptCore heaps ， 3.1 - Garbage collector basics ， 3.2 - Marked space ， 3.3 - Copied space ， 4 - Constructing exploit primitives ， 4.1 - Prerequisites : Int64 ， 4.2 - addrof and fakeobj ， 4.3 - Plan of exploitation ， 5 - Understanding the JSObject system ， 5.1 - Property storage ， 5.2 - JSObject internals ， 5.3 - About structures ， 6 - Exploitation ， 6.1 - Predicting structure IDs ， 6.2 - Putting things together : faking a Float64Array ， 6.3 - Executing shellcode ， 6.4 - Surviving garbage collection ， 6.5 - Summary ， 7 - Abusing the renderer process ， 7.1 - WebKit process and privilege model ， 7.2 - The same-origin policy ， 7.3 - Stealing emails ， 8 - ， 9 - Source code ， -- [ 0 - Introduction ， This article strives to give an introduction to the topic of JavaScript ， engine exploitation at the example of a specific vulnerability. The ， particular target will be JavaScriptCore , the engine inside WebKit. ， The vulnerability in question is CVE-2016-4622 and was discovered by yours ， truly in early 2016 , then reported as ZDI-16-485 [ 1 ] . It allows an attacker ， to leak addresses as well as inject fake JavaScript objects into the ， engine. Combining these primitives will result in remote code execution ， inside the renderer process. The bug was fixed in 650552a. Code snippets in ， this article were taken from commit 320b1fc , which was the last vulnerable ， revision. The vulnerability was introduced approximately one year earlier ， with commit 2fa4973. All exploit code was tested on Safari 9.1.1. ， The exploitation of said vulnerability requires knowledge of various engine ， internals , which are , however , also quite interesting by themselves. As ， such various pieces that are part of a modern JavaScript engine will be ， discussed along the way. We will focus on the implementation of ， JavaScriptCore , but the concepts will generally be applicable to other ， engines as well. ， Prior knowledge of the JavaScript language will , for the most part , not be ， required. ， -- [ 1 - JavaScript engine overview ， On a high level , a JavaScript engine contains ，  * a compiler infrastructure , typically including at least one ， just-in-time ( JIT ) compiler ，  * a virtual machine that operates on JavaScript values ，  * a runtime that provides a set of builtin objects and functions ， We will not be concerned about the inner workings of the compiler ， infrastructure too much as they are mostly irrelevant to this specific bug. ， For our purposes it suffices to treat the compiler as a black box which ， emits bytecode ( and potentially native code in the case of a JIT compiler )  ， from the given source code. ， ---- [ 1.1 - The VM , Values , and NaN-boxing ， The virtual machine ( VM ) typically contains an interpreter which can ， directly execute the emitted bytecode. The VM is often implemented as ， stack-based machines ( in contrast to register-based machines ) and thus ， operate around a stack of values. The implementation of a specific opcode ， handler might then look something like this :  ， CASE ( JSOP_ADD )  ， MutableHandleValue lval = REGS.stackHandleAt ( -2 )  ;  ， MutableHandleValue rval = REGS.stackHandleAt ( -1 )  ;  ， MutableHandleValue res = REGS.stackHandleAt ( -2 )  ;  ， goto error ;  ， REGS.sp- ;  ， END_CASE ( JSOP_ADD )  ， Note that this example is actually taken from Firefox' Spidermonkey engine ， as JavaScriptCore ( from here on abbreviated as JSC ) uses an interpreter ， that is written in a form of assembly language and thus not quite as ， straightforward as the above example. The interested reader can however ， find the implementation of JSC's low-level interpreter ( llint ) in ， LowLevelInterpreter64.asm. ， Often the first stage JIT compiler ( sometimes called baseline JIT ) takes ， care of removing some of the dispatching overhead of the interpreter while ， higher stage JIT compilers perform sophisticated optimizations , similar to ， the ahead-of-time compilers we are used to. Optimizing JIT compilers are ， typically speculative , meaning they will perform optimizations based on ， some speculation , e.g. 'this variable will always contain a number'. ， Should the speculation ever turn out to be incorrect , the code will usually ， bail out to one of the lower tiers. For more information about the ， different execution modes the reader is referred to [ 2 ] and [ 3 ] . ， JavaScript is a dynamically typed language. As such , type information is ， associated with the ( runtime ) values rather than ( compile-time ) variables. ， The JavaScript type system [ 4 ] defines primitive types ( number , string ,  ， boolean , null , undefined , symbol ) and objects ( including arrays and ， functions ) . In particular , there is no concept of",
    "time": "2016-10-27"
}