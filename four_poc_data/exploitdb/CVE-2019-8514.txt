{
    "text": "ecve : CVE-2019-8514 ， title : iOS < 12.2 / macOS < 10.14.4 XNU - pidversion Increment During execve is Unsafe - Multiple dos Exploit ， verified : Verified ， exploit_detail : Privileged IPC services in userspace often have to verify the security context of their client processes ( such as whether the client is sandboxed , has a specific entitlement , or is signed by some code signing authority ) . This , in turn , requires a way to identify a client process. If PIDs are used for that purpose , the following attack becomes possible :  ， 1. The ( unprivileged ) client process sends an IPC message to a privileged service ， 2. The client process terminates and spawns a privileged process into its PID ， 3. The privileged service performs the security check , but since the PID has been reused it performs it on the wrong process ， This attack is feasible because the PID space is usually fairly small ( e.g. 100000 for XNU ) and PIDs can thus be wrapped around relatively quickly ( in step 2 or up front ) . As such , on darwin platforms the recommended way to identify IPC clients for the purpose of performing security checks in userspace is to rely on the audit_token. In contrast to the PID , which wraps around at 100000 , the audit_token additionally contains the pidversion , which is in essence a 32-bit PID ( from bsd/kern/kern_fork.c )  :  ， proc_t ， forkproc ( proc_t parent_proc )  ， static int nextpid = 0 , pidwrap = 0 , nextpidversion = 0 ;  ， ... ;  ， / * Repeat until nextpid is a currently unused PID. * / ， nextpid++ ;  ， ... ;  ， nprocs++ ;  ， child_proc->p_pid = nextpid ;  ， child_proc->p_responsible_pid = nextpid ;  ， child_proc->p_idversion = nextpidversion++ ;  ， ... ;  ， When using audit_tokens , the previously described attack would now require creating two different processes which have the same pair of ( pid , pidversion )  , which in turn would require spawning roughly 232 processes to wrap around the pidversion. However , the pidversion is additionally incremented during execve ( from bsd/kern/kern_exec.c )  :  ， / * Update the process' identity version and set the security token * / ， p->p_idversion++ ;  ， This is likely done to prevent another attack where a process sends an IPC message , then immediately execve's a privileged binary. The problem here is that the pidversion is incremented \"ad-hoc\" , without updating the global nextpidversion variable. With that it becomes possible to create two processes with the same ( pid , pidversion ) pair without wrapping around the 32-bit pidversion :  ， 1. The initial exploit process is identified by the pair ( p2. The exploit performs 10000 execves to get ( X , Y + 100000 )  ， 3. The exploit interacts with a privileged service which stores the client's audit_token ( or directly uses it , in which case the following part becomes a race )  ， 4. The exploit forks , with the parent processes immediately terminating , until it has the same PID again. This could , for example , require 99000 forks ( because some PIDs are in use ) . The process now has ( X , Y + 99000 )  ， 5. The exploit execves until it has ( X , Y + 99999 )  ， 6. The exploit execves a privileged binary. The privileged binary will have ( X , Y + 100000 )  ， 7. At this time the privileged service performs a security check of the client but will perform this check on the entitled process even though the request came from an unprivileged process ， The attached",
    "time": "2019-04-03"
}