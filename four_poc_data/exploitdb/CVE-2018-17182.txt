{
    "text": "published_time: 2018-09-26 ， id: 39540 ， eid: 45497 ， cve: CVE-2018-17182 ， title: Linux Kernel - VMA Use-After-Free via Buggy vmacache_flush_all() Fastpath Local Privilege Escalation - Linux local Exploit ， author: Google Security Research ， published_time: 2018-09-26 ， verified: Verified ， platform: Linux ， exploit_type: local ， exploit_url: /download/45497 ， exploit_detail: Since commit 615d6e8756c8 (\"mm: per-thread vma caching\", first in 3.15),\r ， Linux has per-task VMA caches that contain up to four VMA pointers for\r ， fast lookup. VMA caches are invalidated by bumping the 32-bit per-mm\r ， sequence number mm->vmacache_seqnum; when the sequence number wraps,\r ， vmacache_flush_all() scans through all running tasks and wipes the\r ， VMA caches of all tasks that share current's mm.\r ， In commit 6b4ebc3a9078 (\"mm,vmacache: optimize overflow system-wide\r ， flushing\", first in 3.16), a bogus fastpath was added that skips the\r ， invalidation on overflow if current->mm->mm_users=1. This means that\r ， the following sequence of events triggers a use-after-free:\r ， [A starts as a singlethreaded process]\r ， A: create mappings X and Y (in separate memory areas\r ，    far away from other allocations)\r ， A: perform repeated invalidations until\r ，    current->mm->vmacache_seqnum=0xffffffff and\r ，    current->vmacache.seqnum=0xfffffffe\r ， A: dereference an address in mapping Y that is not\r ，    paged in (thereby populating A's VMA cache with\r ，    Y at seqnum 0xffffffff)\r ， A: unmap mapping X (thereby bumping\r ，    current->mm->vmacache_seqnum to 0)\r ， A: without any more find_vma() calls (which could\r ，    happen e.g. via pagefaults), create a thread B\r ， B: perform repeated invalidations until\r ，    current->mm->vmacache_seqnum=0xfffffffe\r ， B: unmap mapping Y (thereby bumping\r ，    current->mm->vmacache_seqnum to 0xffffffff)\r ， A: dereference an address in the freed mapping Y\r ，    (or any address that isn't present in the\r ，    pagetables and doesn't correspond to a valid\r ，    VMA cache entry)\r ， A's VMA cache is still at sequence number 0xffffffff from before the\r ， overflow. The sequence number has wrapped around in the meantime, back\r ， to 0xffffffff, and A's outdated VMA cache is considered to be valid.\r ， I am attaching the following reproduction files:\r ， vmacache-debugging.patch: Kernel patch that adds some extra logging for\r ，                           VMA cache internals.\r ， vma_test.c: Reproducer code\r ， dmesg: dmesg output of running the reproducer in a VM\r ， In a Debian 9 VM, I've tested the reproducer against a 4.19.0-rc3+\r ， kernel with vmacache-debugging.patch applied, configured with\r ， CONFIG_DEBUG_VM_VMACACHE=y.\r ， Usage:\r ， user@debian:~/vma_bug$ gcc -O2 -o vma_test vma_test.c -g  ./vma_test\r ， Segmentation fault\r ， Within around 40 minutes, I get the following warning in dmesg:\r ， [ 2376.292518] WARNING: CPU: 0 PID: 1103 at mm/vmacache.c:157 vmacache_find+0xbb/0xd0\r ， [ 2376.296813] Modules linked in: btrfs xor zstd_compress raid6_pq\r ， [ 2376.300095] CPU: 0 PID: 1103 Comm: vma_test Not tainted 4.19.0-rc3+ #161\r ， [ 2376.303650] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1 04/01/2014\r ， [ 2376.305796] RIP: 0010:vmacache_find+0xbb/0xd0\r ， [ 2376.306963]"
}