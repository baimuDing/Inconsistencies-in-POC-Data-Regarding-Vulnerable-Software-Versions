{
    "text": "ecve : CVE-2016-0778 CVE-2016-0777 ， title : Roaming Through the OpenSSH Client : CVE-2016-0777 and CVE-2016-0778 - Multiple papers Exploit ， verified : Verified ， exploit_detail : Qualys Security Advisory ， Roaming through the OpenSSH client : CVE-2016-0777 and CVE-2016-0778 ， Contents ， Summary ， Information Leak ( CVE-2016-0777 )  ， - Analysis ， - Private Key Disclosure ， - Mitigating Factors ， - Examples ， Buffer Overflow ( CVE-2016-0778 )  ， - Analysis ， - Mitigating Factors ， - File Descriptor Leak ， Acknowledgments ， Proof Of Concept ， Summary ， Since version 5.4 ( released on March 8 , 2010 )  , the OpenSSH client ， supports an undocumented feature called roaming : if the connection to an ， SSH server breaks unexpectedly , and if the server supports roaming as ， well , the client is able to reconnect to the server and resume the ， suspended SSH session. ， Although roaming is not supported by the OpenSSH server , it is enabled ， by default in the OpenSSH client , and contains two vulnerabilities that ， can be exploited by a malicious SSH server ( or a trusted but compromised ， server )  : an information leak ( memory disclosure )  , and a buffer overflow ，  ( heap-based ) . ， The information leak is exploitable in the default configuration of the ， OpenSSH client , and ( depending on the client's version , compiler , and ， operating system ) allows a malicious SSH server to steal the client's ， private keys. This information leak may have already been exploited in ， the wild by sophisticated attackers , and high-profile sites or users may ， need to regenerate their SSH keys accordingly. ， The buffer overflow , on the other hand , is present in the default ， configuration of the OpenSSH client but its exploitation requires two ， non-default options : a ProxyCommand , and either ForwardAgent ( -A ) or ， ForwardX11 ( -X ) . This buffer overflow is therefore unlikely to have any ， real-world impact , but provides a particularly interesting case study. ， All OpenSSH versions between 5.4 and 7.1 are vulnerable , but can be ， easily hot-fixed by setting the undocumented option \"UseRoaming\" to ， \"no\" , as detailed in the Mitigating Factors section. OpenSSH version ， 7.1p2 ( released on January 14 , 2016 ) disables roaming by default. ， Information Leak ( CVE-2016-0777 )  ， Analysis ， If the OpenSSH client connects to an SSH server that offers the key ， exchange algorithm \"resume @ appgate.com\" , it sends the global request ， \"roaming @ appgate.com\" to the server , after successful authentication. If ， this request is accepted , the client allocates a roaming buffer out_buf ,  ， by calling malloc (  )  ( and not calloc (  )  ) with an out_buf_size that is ， arbitrarily chosen by the server :  ， 63 void ， 64 roaming_reply ( int type , u_int32_t seq , void * ctxt )  ， 65 { ， 66 if ( type == SSH2_MSG_REQUEST_FAILURE ) { ， 67 logit ( \"Server denied roaming\" )  ;  ， 68 return ;  ， 69 } ， 70 verbose ( \"Roaming enabled\" )  ;  ， 75 set_out_buffer_size ( packet_get_int (  ) + get_snd_buf_size (  )  )  ;  ， 77 } ， 40 static size_t out_buf_size = 0 ;  ， 41 static char * out_buf = NULL ;  ， 42 static size_t out_start ;  ， 43 static size_t out_last ;  ， 75 void ， 76 set_out_buffer_size ( size_t size )  ， 77 { ， 78 if ( size == 0 |  | size > MAX_ROAMBUF )  ， 79 fatal ( \"%s : bad buffer size %lu\" , __func__ ,  ( u_long ) size )  ;  ， 80 / *  ， 81 * The buffer size can only be set once and the buffer will live ， 82 * as long as the session lives. ， 83 * / ， 84 if ( out_buf == NULL ) { ， 85 out_buf_size = size ;  ， 86 out_buf = xmalloc ( size )  ;  ， 87 out_start = 0 ;  ， 88 out_last = 0 ;  ， 89 } ， 90 } ， The OpenSSH client's roaming_write (  ) function , a simple wrapper around ， write (  )  , calls wait_for_roaming_reconnect (  ) to transparently reconnect ， to the SSH server after a disconnection. It also calls buf_append (  ) to ， copy the data sent to the server into the roaming buffer out_buf. During ， a reconnection , the client is therefore able to resend the data that was ， not received by the server because of the disconnection :  ， 198 void ， 199 resend_bytes ( int fd , u_int64_t * offset )  ， 200 { ， 201 size_t available , needed ;  ， 202 ， 203 if ( out_start < out_last )  ， 204 available = out_last - out_start ;  ， 205 else ， 206 available = out_buf_size ;  ， 207 needed = write_bytes - * offset ;  ， 208 debug3 ( \"resend_bytes : resend %lu bytes from %llu\" ,  ， 209 ( unsigned long ) needed ,  ( unsigned long long )  * offset )  ;  ， 210 if ( needed > available )  ， 211 fatal ( \"Needed to resend more data than in the cache\" )  ;  ， 212 if ( out_last < needed ) { ， 213 int chunkend = needed - out_last ;  ， 214 atomicio ( vwrite , fd , out_buf + out_buf_size - chunkend ,  ， 215 chunkend )  ;  ， 216 atomicio ( vwrite , fd , out_buf , out_last )  ;  ， 217 } else { ， 218 atomicio ( vwrite , fd , out_buf + ( out_last - needed )  , needed )  ;  ， 219 } ， 220 } ， In the OpenSSH client's roaming buffer out_buf , the most recent data ， sent to the server begins at index out_start and ends at index out_last. ， As soon as this circular buffer is full , buf_append (  ) maintains the ， invariant \"out_start = out_last + 1\" , and consequently three different ， cases have to be considered :  ， - \"out_start < out_last\" ( lines 203-204 )  : out_buf is not full yet ( and ， out_start is still equal to 0 )  , and the amount of data available in ， out_buf is indeed \"out_last - out_start\" ;  ， - \"out_start > out_last\" ( lines 205-206 )  : out_buf is full ( and out_start ， is exactly equal to \"out_last + 1\" )  , and the amount of data available ， in out_buf is indeed the entire out_buf_size ;  ， - \"out_start == out_last\" ( lines 205-206 )  : no data was ever written to ， out_buf ( and both out_start and out_last are still equal to 0 ) because ， no data was ever sent to the server after roaming_reply (  ) was called ,  ， but the client sends ( leaks ) the entire uninitialized out_buf to the ， server ( line 214 )  , as if out_buf_size bytes of data were available. ， In order to successfully exploit this information leak and retrieve ， sensitive information from the OpenSSH client's memory ( for example ,  ， private SSH keys , or memory addresses useful for further exploitation )  ,  ， a malicious server needs to :  ， - Massage the client's heap before roaming_reply (  ) malloc (  ) ates out_buf ,  ， and force malloc (  ) to return a previously free (  ) d but uncleansed chunk ， of sensitive information. The simple proof-of-concept in this advisory ， does not implement heap massaging. ， - Guess the client's get_snd_buf_size (  ) in order to precisely control ， out_buf_size. OpenSSH < 6.0 accepts out_buf sizes in the range ( 0 , 4G )  ,  ， and OpenSSH >= 6.0 accepts sizes in the range ( 0 , 2M ] . Sizes smaller ， than get_snd_buf_size (  ) are attainable because roaming_reply (  ) does ， not protect \"packet_get_int (  ) + get_snd_buf_size (  ) \" against integer ， wraparound. The proof-of-concept in this advisory attempts to derive ， the client's get_snd_buf_size (  ) from the get_recv_buf_size (  ) sent by ， the client to the server , and simply chooses a random out_buf_size. ， - Advise the client's resend_bytes (  ) that all \"available\" bytes ( the ， entire out_buf_size ) are \"needed\" by the server , even if fewer bytes ， were actually written by the client to the server ( because the server ， controls the \" * offset\" argument , and resend_bytes (  ) does not protect ， \"needed = write_bytes - * offset\" against integer wraparound ) . ， Finally , a brief digression on a minor bug in resend_bytes (  )  : on 64-bit ， systems , where \"chunkend\" is a 32-bit signed integer , but \"out_buf\" and ， \"out_buf_size\" are 64-bit variables , \"out_buf + out_buf_size - chunkend\" ， may point out-of-bounds , if chunkend is negative ( if out_buf_size is in ， the [ 2G , 4G ) range ) . This negative chunkend is then converted to a 64-bit ， size_t greater than SSIZE_MAX when passed to atomicio (  )  , and eventually ， returns EFAULT when passed to write (  )  ( at least on Linux and OpenBSD )  ,  ， thus avoiding an out-of-bounds read from the OpenSSH client's memory. ， Private Key Disclosure ， We initially believed that this information leak in the OpenSSH client's ， roaming code would not allow a malicious SSH server to steal the ， client's private keys , because :  ， - the information leaked is not read from out-of-bounds memory , but from ， a previously free (  ) d chunk of memory that is recycled to malloc (  ) ate ， the client's roaming buffer out_buf ;  ， - private keys are loaded from disk into memory and freed by key_free (  )  ，  ( old API , OpenSSH < 6.7 ) or sshkey_free (  )  ( new API , OpenSSH >= 6.7 )  ,  ， and both functions properly cleanse the private keys' memory with ， OPENSSL_cleanse (  ) or explicit_bzero (  )  ;  ， - temporary copies of in-memory private keys are freed by buffer_free (  )  ，  ( old API ) or sshbuf_free (  )  ( new API )  , and both functions attempt to ， cleanse these copies with memset (  ) or bzero (  ) . ， However , we eventually identified three reasons why , in our experiments ,  ， we were able to partially or completely retrieve the OpenSSH client's ， private keys through this information leak ( depending on the client's ， version , compiler , operating system , heap layout , and private keys )  :  ，  ( besides these three reasons , other reasons may exist , as suggested by ， the CentOS and Fedora examples at the end of this section )  ， 1. If a private SSH key is loaded from disk into memory by fopen (  )  ( or ， fdopen (  )  )  , fgets (  )  , and fclose (  )  , a partial or complete copy of this ， private key may remain uncleansed in memory. Indeed , these functions ， manage their own internal buffers , and whether these buffers are ， cleansed or not depends on the OpenSSH client's libc ( stdio )  ， implementation , but not on OpenSSH itself. ， - In all vulnerable OpenSSH versions , SSH's main (  ) function calls ， load_public_identity_files (  )  , which loads the client's public keys ， with fopen (  )  , fgets (  )  , and fclose (  ) . Unfortunately , the private keys ，  ( without the \".pub\" suffix ) are loaded first and then discarded , but ， nonetheless buffered in memory by the stdio functions. ， - In OpenSSH versions <= 5.6 , the load_identity_file (  ) function ( called ， by the client's public-key authentication method ) loads a private key ， with fdopen (  ) and PEM_read_PrivateKey (  )  , an OpenSSL function that uses ， fgets (  ) and hence internal stdio buffering. ， Internal stdio buffering is the most severe of the three problems ， discussed in this section , although GNU/Linux is not affected because ， the glibc mmap (  ) s and munmap (  ) s ( and therefore cleanses ) stdio buffers. ， BSD-based systems , on the other hand , are severely affected because they ， simply malloc (  ) ate and free (  ) stdio buffers. For interesting comments on ， this issue :  ， 2. In OpenSSH versions >= 5.9 , the client's load_identity_file (  )  ， function ( called by the public-key authentication method ) read (  ) s a ， private key in 1024-byte chunks that are appended to a growing buffer ( a ， realloc (  ) ating buffer ) with buffer_append (  )  ( old API ) or sshbuf_put (  )  ，  ( new API ) . Unfortunately , the repeated calls to realloc (  ) may leave ， partial copies of the private key uncleansed in memory. ， - In OpenSSH < 6.7 ( old API )  , the initial size of such a growing buffer ， is 4096 bytes : if a private-key file is larger than 4K , a partial copy ， of this private key may remain uncleansed in memory ( a 3K copy in a 4K ， buffer ) . Fortunately , only the file of a very large RSA key ( for ， example , an 8192-bit RSA key ) can exceed 4K. ， - In OpenSSH >= 6.7 ( new API )  , the initial size of a growing buffer is ， 256 bytes : if a private-key file is larger than 1K ( the size passed to ， read (  )  )  , a partial copy of this private key may remain uncleansed in ， memory ( a 1K copy in a 1K buffer ) . For example , the file of a ， default-sized 2048-bit RSA key exceeds 1K. ， For more information on this issue :  ， 3. An OpenSSH growing-buffer that holds a private key is eventually ， freed by buffer_free (  )  ( old API ) or sshbuf_free (  )  ( new API )  , and both ， functions attempt to cleanse the buffer with memset (  ) or bzero (  ) before ， they call free (  ) . Unfortunately , an optimizing compiler may remove this ， memset (  ) or bzero (  ) call , because the buffer is written to , but never ， again read from ( an optimization known as Dead Store Elimination ) . ， OpenSSH 6.6 is the only version that is not affected , because it calls ， explicit_bzero (  ) instead of memset (  ) or bzero (  ) . ， Dead Store Elimination is the least severe of the three problems ， explored in this section , because older GCC versions do not remove the ， memset (  ) or bzero (  ) call made by buffer_free (  ) or sshbuf_free (  ) . GCC 5 ， and Clang/LLVM do , however , remove it. For detailed discussions of this ， issue :  ， Finally , for these three reasons , passphrase-encrypted SSH keys are ， leaked in their encrypted form , but an attacker may attempt to crack the ， passphrase offline. On the other hand , SSH keys that are available only ， through an authentication agent are never leaked , in any form. ， Mitigating Factors ， This information leak affects all OpenSSH clients >= 5.4 , but its impact ， is slightly reduced by the following four reasons :  ， 1. The vulnerable roaming code can be permanently disabled by adding the ， undocumented option \"UseRoaming no\" to the system-wide configuration ， file ( usually /etc/ssh/ssh_config )  , or per-user configuration file ，  (  ~ /.ssh/config )  , or command-line ( -o \"UseRoaming no\" ) . ， 2. If an OpenSSH client is disconnected from an SSH server that offers ， roaming , it",
    "time": "2016-01-15"
}