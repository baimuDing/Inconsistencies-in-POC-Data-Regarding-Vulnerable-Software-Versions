{
    "text": "ecve : CVE-2018-11412 ， title : Linux Kernel < 4.16.11 - 'ext4_read_inline_data (  ) ' Memory Corruption - Linux dos Exploit ， verified : Not Verified ， exploit_detail : ext4 can store data for small regular files as \"inline data\" , meaning that the ， data is stored inside the corresponding inode instead of in separate blocks. ， Inline data is stored in two places : The first 60 bytes go in the i_block field ， in the inode ( which normally contains a list of blocks instead )  , the rest goes ， in the special filesystem-internal extended attribute \"system.data\". ， Since commit e50e5129f384 ( \"ext4 : xattr-in-inode support\" , in v4.13+ )  , ext4 can ， store extended attribute values not only inline in the inode , but can also store ， such values in dedicated inodes. ， When a corrupted filesystem stores the system.data extended attribute value in a ， dedicated inode , the kernel gets confused , causing memory corruption. ， ext4_find_inline_data_nolock (  ) attempts to locate an inode's inline data by ， searching for the system.data xattr using ext4_xattr_ibody_find (  ) . ， If the inode has xattrs , ext4_xattr_ibody_find (  ) first checks them for ， corruption using xattr_check_inode (  )  , then grabs the wanted xattr using ， xattr_find_entry (  ) . ， xattr_check_inode (  ) uses ext4_xattr_check_entries (  ) to check the individual ， xattrs , but skips most checks if `entry->e_value_inum ! = 0` ( marking an xattr ， whose value is in a dedicated inode ) - only for inline values , length and offset ， checks are performed to ensure that the value actually fits into the inode. ， The problem is that ext4_find_inline_data_nolock (  ) then assumes that the ， returned xattr uses inline storage and that the returned length will fit into ， the inode ; it stores the length field from the xattr in ， `EXT4_I ( inode ) ->i_inline_size` without further checks. ， Later , when the file is read , ext4_read_inline_data (  ) trusts this length value ,  ， causing an out-of-bounds memcpy (  ) in the following line :  ， memcpy ( buffer ,  ，  ( void *  ) IFIRST ( header ) + le16_to_cpu ( entry->e_value_offs )  , len )  ;  ， To reproduce , on a system with kernel v4.13 or newer , ideally with KASAN on :  ， 1. Create a new ext4 filesystem image , with 256-byte inodes and inline data ， support :  ，  $ mkfs.ext4 -b 4096 -I 256 -O inline_data testfs.img 400k ， mke2fs 1.43.7 ( 16-Oct-2017 )  ， Creating regular file testfs.img ， Filesystem too small for a journal ， Creating filesystem with 100 4k blocks and 64 inodes ， Allocating group tables : done ， Writing inode tables : done ， Writing superblocks and filesystem accounting information : done ， 2. Create a 75-byte file in the new filesystem :  ，  $ mkdir mount ，  $ sudo mount testfs.img mount ，  $ sudo dd bs=75 count=1 if=/dev/zero of=mount/testfile ， 1+0 records in ， 1+0 records out ， 75 bytes copied , 0.000811554 s , 92.4 kB/s ，  $ sudo umount mount ， 3. Bump up the inode size , bump up the xattr size , and mark the xattr value as ， non-inline : ",
    "time": "2018-06-05"
}