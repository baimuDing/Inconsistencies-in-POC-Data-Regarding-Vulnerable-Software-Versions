{
    "text": "ecve : CVE-2010-5075 ， title : Avast ! Internet Security 5.0 - 'aswFW.sys' Kernel Driver IOCTL Memory Pool Corruption - Windows dos Exploit ， verified : Not Verified ， exploit_detail : +-------------------------------------------------------------------------------------+ ，  | Avast ! Internet Security 5.0 'aswFW.sys' kernel driver IOCTL Memory Pool Corruption |  ， +-------------------------------------------------------------------------------------+ ， Tested Platform : Avast ! Internet Security 5.0 ( Korean Trial )  ， Affacted File info : 'aswFW.sys' 5.0.594.0 ， Type : Local ， Impact : Denial Of Service ( kernel panic )  ， Vendor :  ， Author : x90c of InetCop Security ( x90c.org , geinblues @ gmail.com )  ， Vulnerability Summary :  ， The IOCTL call 0x829C0964 ( IOCTL_ASWFW_COMM_PIDINFO_RESULTS ) of 'aswFW.sys' kernel driver ， Shiped with 'Avast ! Internet Security 5.0' uses the user controlled First 4 bytes value ， To allocate a NonPagedPool without any value range checking then an integer overrun occurs. ， If 'aswFW.sys' received a first 4 bytes about to '0xFFFFFFFF' with an Irp then an invalid ， Sized Memory Pool allocated. ， After the invalid allocation , the kernel driver copys user controlled buffer into ， ' [ allocated pool+84h ] ' with too large copy length '0FFFFFFFFh' then the Memory Pool corrupted. ， Technical Detail :  ， .text : 000114B0 ; int __stdcall sub_114B0 ( int , PIRP Irp )  ，  [ ... ]  ， .text : 00011529 mov edi ,  [ ebp+Irp ]  ; edi = Irp ，  [ ... ]  ， .text : 000115A9 mov edi ,  [ edi+0Ch ]  ; edi = [ edi+0Ch ]  ( User Controlled Buffer of Irp )  ，  [ ... ]  ， .text : 000115CF sub eax , 0Ch ， .text : 000115D2 jz short to_IOCTL_Request ; jump into ( 1 )  ，  [ ... ]  ， .text : 00011626 to_IOCTL_Request :  ; <-- ( 1 )  ， .text : 00011626 mov eax ,  [ ebx+0Ch ]  ; eax = IOCTL Code ，  [ ... ]  ， .text : 00011629 cmp eax , edx ， .text : 0001162B jz to_ioctl_code_829C0964h ; IOCTL Code == 829C0964h ? jump into ( 2 )  ，  [ ... ]  ， .text : 000116BA to_ioctl_code_829C0964h :  ; <-- ( 2 )  ， .text : 000116BA call sub_18D68 ; returned 0. ， .text : 000116BF test eax , eax ， .text : 000116C1 jz short loc_116E3 ; jump into ( 3 )  ，  [ ... ]  ， .text : 000116E3 loc_116E3 :  ; <-- ( 3 )  ，  [ ... ]  ， .text : 000116FC push dword ptr [ edi ]  ;  [ edi ] = 0FFFFFFFF ( User Controlled Buffer of Irp )  ， .text : 000116FE push 0 ， .text : 00011700 call NonPagedPool_alloc_1AB32 ; call ( 4 )  ，  ; kd> bl ，  ; 0 e b2d36700 0001 ( 0001 ) aswFW+0x1700 ，  [ ... ]  ， .text : 0001AB32 NonPagedPool_alloc_1AB32 proc near ; <-- ( 4 )  ，  [ ... ]  ， .text : 0001AB37 mov eax ,  [ ebp+0Ch ]  ; eax = 0FFFFFFFFh ( Second param )  ， .text : 0001AB3A push ebx ， .text : 0001AB3B push 74527741h ; Tag ， .text : 0001AB40 add eax , 88h ; 0FFFFFFFFh + 88h ( 0x87 , result of Integer Overrun )  ， .text : 0001AB45 push eax ; Size to allocate ( 0x87 )  ， .text : 0001AB46 push 0 ; PoolType ( 0 = NonPagedPool )  ， .text : 0001AB48 call ds : ExAllocatePoolWithTag ; Invalid Memory Pool allocated. ， .text : 0001AB4E mov ebx , eax ; ebx = eax ，  [ ... ]  ， .text : 0001AB7F mov eax , ebx ， .text : 0001AB83 retn 8 ; return with an Invalid Memory Pool. return into ( 5 )  ， // Integer Overrun. ， _87bytes_NonPagedPool = ExAllocatePoolWithTag ( 0 , 0xFFFFFFFF + 0x88 , 0x74527741 )  ;  ， .text : 000116E3 loc_116E3 :  ，  [ ... ]  ， .text : 00011705 mov esi , eax ; <-- ( 5 ) esi = eax = Invalid Memory Pool. ， .text : 00011707 test esi , esi ， .text : 00011709 jz to_Epilog ; esi == 0 ? ，  [ ... ]  ， .text : 00011727 push dword ptr [ edi ]  ; copy size == 0FFFFFFFFh ( too large )  ， .text : 00011729 lea eax ,  [ esi+84h ]  ; eax = [ esi+84h ] == [ Invalid Memory Pool Allocated + 84h ]  ， .text : 0001172F push edi ; src == User Controlled Buffer of Irp ( FFFFFFFF ... )  ， .text : 00011730 push eax ; dest == eax ， .text : 00011731 call memcpy ; Memory Corruption Occurs. ， // Memory Pool Corruption. ， memcpy (  ( _87bytes_NonPagedPool+0x84 )  , User Controlled Buffer of Irp , 0xFFFFFFFF )  ; ",
    "time": "2010-08-03"
}