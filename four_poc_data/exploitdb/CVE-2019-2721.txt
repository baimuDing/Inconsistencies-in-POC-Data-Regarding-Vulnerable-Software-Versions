{
    "text": "ecve : CVE-2019-2721 ， title : VirtualBox 6.0.4 r128413 - COM RPC Interface Code Injection Host Privilege Escalation - Windows local Exploit ， verified : Verified ， exploit_detail : VirtualBox : COM RPC Interface Code Injection Host EoP ， Platform : VirtualBox 6.0.4 r128413 x64 on Windows 10 1809 ， Class : Elevation of Privilege ， Summary :  ， The hardened VirtualBox process on a Windows host doesnt secure its COM interface leading to arbitrary code injection and EoP. ， Description :  ， This issue is similar in scope to others Ive reported such as S0867394/CVE-2017-10204. It allows you to call arbitrary code inside the hardened process which can expose the kernel drivers to normal user processes resulting in EoP. Im assuming that this is still an issue youd like to fix? ， The VirtualBox hardening code allows other processes running as the same user to read all virtual memory by granting the PROCESS_VM_READ access right. It isnt obvious that this could result in arbitrary code execution , except that VirtualBox initializes out-of-process COM and by extension exposes an RPC interface. With access to read arbitrary memory from such a process its possible to call existing interfaces running inside the VirtualBox process such as the undocumented IRundown interface which COM uses for various infrastructure tasks. This interface has a DoCallback method which will execute an arbitrary function in the process with a single arbitrary pointer sized argument. ， You can get more details from my blog about using this technique as a mechanism to bypass Windows Protected Processes , In this case we dont need to abuse an old version of WERFault to dump memory as the hardening driver allows us to do just read memory. ， To fix this issue you might want to block PROCESS_VM_READ access entirely , its not clear if this is a necessary access right for something or just because it didnt seem to be dangerous. Id also call CoInitializeSecurity at process start and pass an security descriptor to the pSecDesc parameter which limits access to administrators and perhaps service accounts. However be careful if you decide to only initialize CoInitializeSecurity as its process wide and has weird behaviors which might result in the security descriptor getting unset. Id probably call the API every time you call CoInitialize just in case.",
    "time": "2019-04-24"
}