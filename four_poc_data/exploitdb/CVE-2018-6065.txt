{
    "text": "ecve : CVE-2018-6065 ， title : Google Chrome V8 - Object Allocation Size Integer Overflow - Multiple remote Exploit ， verified : Verified ， exploit_detail : There's an integer overflow in computing the required allocation size when instantiating a new javascript object. ， See the following code in objects.cc ， // static ， bool JSFunction :  : CalculateInstanceSizeForDerivedClass (  ， Handle<JSFunction> function , InstanceType instance_type ,  ， int requested_embedder_fields , int * instance_size ,  ， int * in_object_properties ) { ， Isolate * isolate = function->GetIsolate (  )  ;  ， int expected_nof_properties = 0 ;  ， bool result = true ;  ，  ! iter.IsAtEnd (  )  ; iter.Advance (  )  ) { ， Handle<JSReceiver> current = ， PrototypeIterator :  : GetCurrent<JSReceiver> ( iter )  ;  ， Handle<JSFunction> func ( Handle<JSFunction> :  : cast ( current )  )  ;  ， // The super constructor should be compiled for the number of expected ， // properties to be available. ， Handle<SharedFunctionInfo> shared ( func->shared (  )  )  ;  ， Compiler :  : Compile ( func , Compiler :  : CLEAR_EXCEPTION )  ) { ， DCHECK ( shared->is_compiled (  )  )  ;  ， expected_nof_properties += shared->expected_nof_properties (  )  ; // <--- overflow here !  ， } else if (  ! shared->is_compiled (  )  ) { ， // In case there was a compilation error for the constructor we will ， // throw an error during instantiation. Hence we directly return 0 ;  ， result = false ;  ， CalculateInstanceSizeHelper ( instance_type , true , requested_embedder_fields ,  ， expected_nof_properties , instance_size ,  ， in_object_properties )  ;  ， By supplying a long prototype chain of objects with a large expected_nof_properties we can control the resulting value of instance_size by causing ( requested_embedder_fields + requested_in_object_properties ) kPointerSizeLog2 to be overflown to a small negative value , resulting in an allocation smaller than header_size , which is the minimum required size for the base object",
    "time": "2018-05-04"
}