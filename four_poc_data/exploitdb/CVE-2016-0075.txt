{
    "text": "published_time: 2016-10-18 ， id: 33138 ， eid: 40573 ， cve: CVE-2016-0075 ， title: Microsoft Windows - DeviceApi CMApi PiCMOpenDeviceKey Arbitrary Registry Key Write Privilege Escalation (MS16-124) - Windows local Exploit ， author: Google Security Research ， published_time: 2016-10-18 ， verified: Verified ， platform: Windows ， exploit_type: local ， exploit_url: /download/40573 ， exploit_detail: /*\r ， Source: \r ， Windows: DeviceApi CMApi PiCMOpenClassKey Arbitrary Registry Key Write EoP\r ， Platform: Windows 10 10586 not tested 8.1 Update 2 or Windows 7\r ， Class: Elevation of Privilege\r ， Summary:\r ， The DeviceApi CMApi PiCMOpenClassKey IOCTL allows a normal user to create arbitrary registry keys in the system hive leading to elevation of privilege.\r ， Description:\r ， The DeviceApi is a driver implemented inside the kernel which exposes a number of devices. One of those is CMApi which presumably is short for configuration manager API as it primarily exposes device configuration from the registry to the caller. The device exposes calls using IOCTLs, in theory anything which creates or deletes an object is limited behind an access check which only administrators have access to. However certain calls feed into the call PnpCtxRegCreateTree which will allow a user to open parts of the registry, and if theyre not there will create the keys. This is a problem as the keys are created in the users context using ZwCreateKey but without forcing an access check (it does this intentionally, as otherwise the user couldnt create the key). All we need to do is find a CMApi IOCTL which will create the arbitrary keys for us.\r ， Fortunately its not that simple, all the ones I find using the tree creation function verify that string being passed from the user meets some valid criteria and is always placed into a subkey which the user doesnt have direct control over. However I noticed PiCMOpenDeviceKey allows a valid 3 part path, of the form ABC\\DEF\\XYZ to be specified and the only criteria for creating this key is it exists as a valid device under CurrentControlSet\\Enum, however the keys will be created under CurrentControlSet\\Hardware Profiles which doesnt typically exist. The majority of calls to this IOCTL will apply a very restrictive security descriptor to the new keys, however if you specify the 0x200 device type flag it will use the default SD which will be inherited from the parent key. Even if this didnt provide a useful ACE (in this case it has the default CREATOR OWNER giving full access) as its created under our user context we are the owner and so could rewrite the DACL anyway.\r ， To convert this into a full arbitrary write we can specify a device path which doesnt already exist and it will create the three registry keys. If we now delete the last key and replace it with a symbolic link we can point it at any arbitrary key. As the system hive is trusted this isnt affected by the inter-hive symbolic link protections (and at anyrate services is in the same hive), however this means that the exploit wont work from low-IL due to restrictions on creating symbolic links from sandboxes.\r ， You should be treating anything which calls PnpCtxRegCreateTree or SysCtxRegCreateKey as suspect, especially if no explicit security descriptor is being passed. For example you can use PiCMOpenDeviceInterfaceKey to do something very similar and get an arbitrary Device Parameters key created with full control for any device interface which doesnt already have one. You cant use the same symbolic link trick here (you only control the leaf key) however there might be a driver which has exploitable behaviour if the user can create a arbitrary Device Parameters key."
}