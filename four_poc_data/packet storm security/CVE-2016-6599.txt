{
    "text": "title : BMC Track-It ! 11.4 Code Execution / Information Disclosure  ， detail : BMC Track-It ! version 11.4 suffers from remote code execution and credential disclosure vulnerabilities.  ， cve : advisories | CVE-2016-6598 , CVE-2016-6599  ，  ， desc : Happy new year !   ， I was doing some new year cleaning and realised I never released this  ， advisory properly. Two vulnerabilities in BMC Track-It ! 11.4 which were  ， disclosed by SecuriTeam Secure Disclosure on July 2016.  ， Posting here because I've seen quite a few of these still in active use ,   ， live and deployed in corporate networks.  ， The exploit is available in my repo at [ 3 ] . It's also interesting to see  ， how they completely ignored my advice , but I'm used to that. Here it is  ， in full glory for your reading pleasure.  ， This advisory and exploit can also be fetched at my github repo  ，  ( https : /github.com/pedrib/PoC ) and in the SSD blog at  ， https : /blogs.securiteam.com/index.php/archives/2713. A big thanks to  ， SecuriTeam for helping out as always.  ， > Multiple critical vulnerabilities in BMC Track-It ! 11.4  ， > Discovered by Pedro Ribeiro ( pedrib @ gmail.com )  , Agile Information  ， Security  ，   ， Disclosure : 04/07/2016 / Last updated : 01/01/2017  ， > Background and summary  ， BMC Track-It ! exposes several .NET remoting services on port 9010. .NET  ， remoting is a remote method technology similar to Java RMI or CORBA  ， which allows you to invoke methods remotely and retrieve their result.  ， These remote methods are used when a technician uses the Track-It !   ， client console to communicate with the central Track-It ! server. A  ， technician would invoke these methods for obtaining tickets , creating a  ， new ticket , uploading files to tickets , etc.  ， On October 2014 , two 0 day vulnerabilities for Track-It ! 11.3 were  ， disclosed ( under CVE-2014-4872 , see [ 1 ]  ) . The vulnerabilities were due  ， to the Track-It ! server accepting remote method invocations without any  ， kind of authentication or encryption. The vulnerabilities were very  ， severe : one allowed an attacker to execute code on the server as NETWORK  ， SERVICE or SYSTEM , while the other would allow an attacker to obtain the  ， domain administrator and SQL server passwords if the Track-It ! server  ， had password reset turned on.  ， These vulnerabilities were discovered in a trivial manner - simply by  ， turning Wireshark on and observing the packets one could see the remote  ， method invocations and objects being passed around. Duplicate and even  ， triplicate packets would not be rejected by the server , which would  ， execute whatever action was requested in the packet.  ， Disclosure was done by the US-CERT , which attempted to contact BMC but  ， received no response after 45 days. After this period they released the  ， vulnerability information and I released two Metasploit exploits.  ， BMC contacted me asking for advice on how to fix the issues , to which I  ， responded :   ， \"For # 1 [ file upload ] and # 2 [ domain admin pass disclosure ] the fix is  ， to implement authentication and authorisation. There is no other way to  ， fix it.  ，  [ . ] Make sure the auth is done properly. You will have to negotiate  ， some kind of session key using the user's credential at the start and  ， use that session key for encryption going forward. Do not use a fixed  ， key , as this can be reverse engineered.  ， If you don't implement such mechanism , it's just a question of time  ， before someone else breaks your protection and finds new vulnerabilities.\"  ， On December 9th 2014 , BMC released Track-It ! 11.4 [ 2 ]  , which they  ， claimed had fixed the security vulnerabilities.  ， At first glance , this seemed to be true. Traffic in Wireshark did seem  ， to be encrypted. However upon further inspection , it became obvious that  ，  ， encrypted using a DES key , there was still no authentication being done.  ， What this means in practice is that anyone can negotiate a new  ， encryption key with the server and use that from then on to invoke  ， remote methods without ever authenticating to the server , even for the  ， initial encryption key exchange.  ， The code can be inspected by decompiling TrackIt.Utility.Common.dll. The  ， interesting part is in :   ， namespace TrackIt.Utility.Common.Remoting  ， {  ， internal enum SecureTransaction  ， {  ， Uninitialized ,   ， SendingPublicKey ,   ， SendingSharedKey ,   ， SendingEncryptedMessage ,   ， SendingEncryptedResult ,   ， UnknownIdentifier ,   ， UnauthenticatedClient  ， }  ， }  ， This represents the state machine that the server uses to track client  ， requests. The initial state is UnauthenticatedClient for any unknown  ， client. A typical communication would be as follows :   ， 1- Client generates a RSA key , which it shares with the server by  ， sending a Modulus and an Exponent.  ， 2- Server creates a DES key and sends that key back to the client  ， 3- Client and server now share an encryption key ; that key is used to  ， pass back messages back and forth ( states SendingEncryptedMessage and  ， SendingEncryptedResult ) .  ， As it is evident , at no point there is any authentication or credentials  ， being passed from the client to the server. So while all traffic is  ， encrypted , anyone can negotiate an encryption key with the server and  ， invoke any remote method.  ， >From here on , building an exploit is trivial. All that is needed is to",
    "time": "Jan 26, 2018"
}