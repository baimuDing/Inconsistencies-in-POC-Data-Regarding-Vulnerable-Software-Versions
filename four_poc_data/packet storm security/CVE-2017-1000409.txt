{
    "text": "date_time:Dec 13, 2017 ， title:Qualys Security Advisory - GNU C Library Memory Leak / Buffer Overflow  ， detail:Qualys has discovered a memory leak and a buffer overflow in the dynamic loader (ld.so) of the GNU C Library (glibc).  ， cve:advisories | CVE-2017-1000408, CVE-2017-1000409  ， date_time:Dec 13, 2017  ， desc:Qualys Security Advisory  ， Buffer overflow in glibc's ld.so  ，  ， Contents  ，  ， Summary  ， Memory Leak  ， Buffer Overflow  ， Exploitation  ， Acknowledgments  ，  ， Summary  ，  ， We have discovered a memory leak and a buffer overflow in the dynamic  ， loader (ld.so) of the GNU C Library (glibc):  ， - the memory leak (CVE-2017-1000408) first appeared in glibc 2.1.1  ， (released on May 24, 1999) and can be reached and amplified through  ， the LD_HWCAP_MASK environment variable;  ， - the buffer overflow (CVE-2017-1000409) first appeared in glibc 2.5  ， (released on September 29, 2006) and can be triggered through the  ， LD_LIBRARY_PATH environment variable.  ， Further investigation showed that:  ， - the buffer overflow is not exploitable if  ， /proc/sys/fs/protected_hardlinks is enabled (it is not enabled by  ， default on vanilla Linux kernels, but most Linux distributions turn it  ， on by default);  ， - the memory leak and the buffer overflow are not exploitable if the  ， glibc is patched against CVE-2017-1000366, because this patch ignores  ， the LD_HWCAP_MASK and LD_LIBRARY_PATH environment variables when SUID  ， binaries are executed (CVE-2017-1000366 was first patched in glibc  ， 2.26, released on August 2, 2017, but most Linux distributions had  ， already backported this patch on June 19, 2017).  ， We have therefore rated the impact of these vulnerabilities as Low.  ， Nevertheless, we give a brief analysis of the vulnerable function, and  ， present a simple method for exploiting a SUID binary on the command line  ， and obtaining full root privileges (if /proc/sys/fs/protected_hardlinks  ， is not enabled, and CVE-2017-1000366 is not patched).  ，  ， Memory Leak (CVE-2017-1000408)  ，   ， Analysis  ，  ， In _dl_init_paths(), ld.so malloc()ates \"rtld_search_dirs.dirs[0]\", a  ， cache of information about the system's trusted directories (typically  ， \"/lib\" and \"/usr/lib\" on 32-bit or \"/lib64\" and \"/usr/lib64\" on 64-bit).  ， To compute the number of system directories, ld.so uses the classic C  ， idiom \"sizeof (system_dirs) / sizeof (system_dirs[0])\":  ， 691 rtld_search_dirs.dirs[0] = (struct r_search_path_elem *)  ， 692 malloc (sizeof (system_dirs) / sizeof (system_dirs[0])  ， 693 * round_size * sizeof (struct r_search_path_elem);  ， Unfortunately, \"system_dirs\" is not a classic array: it is not an array  ， of strings (pointers to characters), but rather an array of characters,  ， the concatenation of all system directories, separated by null bytes:"
}