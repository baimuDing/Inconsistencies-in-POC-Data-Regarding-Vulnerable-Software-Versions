{
    "text": "title : Chrome v8 : internal : Object : SetPropertyWithAccessor Type Confusion  ， detail : Google Chrome version 112.0.5615.137 and Chromium version 115.0.5737.0 suffer from a type confusion vulnerability in v8 : internal : Object : SetPropertyWithAccessor.  ， cve : advisories | CVE-2023-2935  ，  ， desc : Chrome : Type confusion in v8 : internal : Object : SetPropertyWithAccessor  ， VULNERABILITY DETAILS  ， When `SetSuperProperty` can't find the requested property in the holder , it performs an `OWN` lookup on the receiver. If the receiver has a property interceptor installed , the function invokes the interceptor's descriptor callback [ 1 ] and , if the callback opts not to intercept the request [ 2 ]  , creates a new property by calling `CreateDataProperty` on the original lookup iterator [ 3 ] .  ， Some descriptor callbacks , for example , the one used with `HTMLCollection` objects , call `GetRealNamedPropertyAttributesInPrototypeChain` [ 4 ] to ensure they don't hide an existing property in the prototype chain. The function works by creating a lookup iterator that starts with the receiver's prototype and calling `GetPropertyAttributes` on it. Finally , if `GetPropertyAttributes` encounters a JavaScript Proxy object , it runs the descriptor handler of the proxy. This creates a user code reentrancy point.  ， The problem is that the user code in the proxy handler might invalidate `own_lookup` , which is used in [ 3 ]  , by modifying the object , for example , by creating a property with the same name. In this scenario , `own_lookup` will be in the `NOT_FOUND` state , and `CreateDataProperty` will attempt to add a second property with the same name.  ， This primitive has been abused multiple times in the past , including exploits detected in the wild , to break field type tracking and bypass security-critical checks in TurboFan. Therefore , last year a hardening patch was landed [ 6 ] that catches duplicate properties in \\\"fast property\\\" mode objects. We were aware of the fact that it would still be possible to create duplicate properties in \\\"dictionary mode\\\" objects with a similar vulnerability , however , even if such an object is converted to the fast mode , its field types are generalized i.e. useless for field type tracker.  ， It turns out there's a way to exploit the duplicate property primitive without abusing field type tracking or TurboFan at all. The basic idea is that , depending on the current order of the properties , a property lookup for a duplicate property name might return a different value , and an object shape change , for example , transitioning between \\\"fast\\\" and \\\"dictionary\\\" properties , might reshuffle the properties.  ， More specifically , when `DefineOwnPropertyIgnoreAttributes` encounters a special `AccessorInfo` property and the requested attributes don't match the current ones , it will first call `TransitionToAccessorPair` [ 7 ] to update the attributes. `TransitionToAccessorPair` might reshape the object twice if needed : first from \\\"fast\\\" to \\\"slow\\\" [ 9 ] and then back to \\\"fast\\\" [ 10 ] . After that , it restarts the lookup in the current object [ 11 ] . However , if the property is a duplicate , the new lookup might point to a different value which isn't even an accessor. This value is later used for the `SetPropertyWithAccessor` call [ 8 ] .  ， In debug builds , this will lead to the `DCHECK_EQ ( ACCESSOR , state_ ) ` assertion failure in `LookupIterator : GetAccessors`. In release builds , a value of an attacker's choice will be interpreted as an `AccessorPair` object.  ， REFERENCES  ， https : /source.chromium.org/chromium/chromium/src/+/main : v8/src/objects/objects.cc ; drc=f49e998b8d369971b65bc980846d2395bf4dee30 ; l=2665  ， `  ， Maybe<bool> Object : SetSuperProperty ( LookupIterator * it , Handle<Object> value ,   ， StoreOrigin store_origin ,   ， Maybe<ShouldThrow> should_throw ) {  ， Isolate * isolate = it->isolate (  )  ;   ，  ， bool found = true ;   ， Maybe<bool> result =  ， SetPropertyInternal ( it , value , should_throw , store_origin , &found )  ;   ，  ， }  ，  [ . ]   ， Handle<JSReceiver> receiver = Handle<JSReceiver> : cast ( it->GetReceiver (  )  ;   ， / Note , the callers rely on the fact that this code is redoing the full own  ， / lookup from scratch.  ， LookupIterator : Configuration c = LookupIterator : OWN ;   ， LookupIterator own_lookup =  ， it->IsElement (  ) ? LookupIterator ( isolate , receiver , it->index (  )  , c )   ，  : LookupIterator ( isolate , receiver , it->name (  )  , c )  ;   ，  ， switch ( own_lookup.state (  ) {  ，  [ . ]   ， case LookupIterator : INTERCEPTOR :   ， case LookupIterator : JSPROXY : {  ， PropertyDescriptor desc ;   ， Maybe<bool> owned =  ， JSReceiver : GetOwnPropertyDescriptor ( &own_lookup , &desc )  ; / *  [ 1 ]  *   ， MAYBE_RETURN ( owned , Nothing<bool> (  )  ;   ，   ， should_throw ) {  ，  ， }  ，  ， should_throw )  ;   ， }  ，  [ . ]   ， }  ， https : /source.chromium.org/chromium/chromium/src/+/refs/heads/main : out/Debug/gen/third_party/blink/renderer/bindings/core/v8/v8_html_collection.cc ; drc=332f92aab4a32607f7813ac1a824f6ff0d86c369 ; l=197  ， `  ， void V8HTMLCollection : NamedPropertyDescriptorCallback (   ， v8 : Local<v8 : Name> v8_property_name , ",
    "time": "Jun 30, 2023"
}