{
    "text": "vul_name : Sqlite3 Window Function Remote Code Execution ， vul_cve : CVE-2019-5018 ， vul_poc : Talos Vulnerability Report ， TALOS-2019-0777 ， Sqlite3 Window Function Remote Code Execution Vulnerability ， May 9 , 2019 ， CVE Number ， CVE-2019-5018 ， Summary ， An exploitable use after free vulnerability exists in the window function functionality of Sqlite3 3.26.0. A specially crafted SQL command can cause a use after free vulnerability , potentially resulting in remote code execution. An attacker can send a malicious SQL command to trigger this vulnerability. ， Tested Versions ， SQLite 3.26.0 , 3.27.0 ， Product URLs ， CVSSv3 Score ， 8.1 - CVSS : 3.0/AV : N/AC : H/PR : N/UI : N/S : U/C : H/I : H/A : H ， CWE ， CWE-416 : Use After Free ， Details ， SQLite is a popular library implementing a SQL database engine. It is used extensively in mobile devices , browsers , hardware devices , and user applications. It is a frequent choice for a small , fast , and reliable database solution. ， SQLite implements the Window Functions feature of SQL which allows queries over a subset , or \"window\" , of rows. After parsing a SELECT statement that contains a window function , the SELECT statement is transformed using the sqlite3WindowRewrite function. ， src/select.c : 5643 ， sqlite3SelectPrep ( pParse , p , 0 )  ;  ， . ，  # ifndef SQLITE_OMIT_WINDOWFUNC ， goto select_end ;  ， } ， During this function , the expression-list held by the SELECT object is rewritten if an aggregate function ( COUNT , MAX , MIN , AVG , SUM ) was used [ 0 ] . ， src/window.c : 747 ， int sqlite3WindowRewrite ( Parse * pParse , Select * p ) { ， int rc = SQLITE_OK ;  ， . ， Window * pMWin = p->pWin ; / * Master window object * / ， Window * pWin ; / * Window object iterator * / ， . ， selectWindowRewriteEList ( pParse , pMWin / * window * / , pSrc , p->pEList , &pSublist )  ;  [ 0 ]  ， selectWindowRewriteEList ( pParse , pMWin / * window * / , pSrc , p->pOrderBy , &pSublist )  ;  ， . ， pSublist = exprListAppendList ( pParse , pSublist , pMWin->pPartition )  ;  ， The master window object pMWin is taken from the SELECT object and is used during the rewrite [ 1 ] . This walks the expression list from the SELECT object and rewrites the window function ( s ) for easier processing. ， src/window.c : 692 ， static void selectWindowRewriteEList (  ， Parse * pParse ,  ， Window * pWin ,  ， SrcList * pSrc ,  ， ExprList * pEList ,  ， ExprList ppSub ，  ) { ， Walker sWalker ;  ， WindowRewrite sRewrite ;  ， memset ( &sWalker , 0 , sizeof ( Walker )  ;  ， memset ( &sRewrite , 0 , sizeof ( WindowRewrite )  ;  ， sRewrite.pSub = * ppSub ;  ， sRewrite.pWin = pWin ; / [ 1 ]  ， sRewrite.pSrc = pSrc ;  ， sWalker.pParse = pParse ;  ， sWalker.xExprCallback = selectWindowRewriteExprCb ;  ， sWalker.xSelectCallback = selectWindowRewriteSelectCb ;  ， sWalker.u.pRewrite = &sRewrite ;  ，  ( void ) sqlite3WalkExprList ( &sWalker , pEList )  ;  ，  * ppSub = sRewrite.pSub ;  ， } ， Note the master window object is used in the WindowRewrite object. While processing each expression , the xExprCallback function is used as a callback for processing. When processing an aggregate function ( TKAGGFUNCTION ) and after appending to the expression list , the expression is deleted [ 2 ] . ， src/window.c : 602 ， static int selectWindowRewriteExprCb ( Walker * pWalker , Expr * pExpr ) { ， struct WindowRewrite * p = pWalker->u.pRewrite ;  ， Parse * pParse = pWalker->pParse ;  ， . ， switch ( pExpr->op ) { ， . ， / * Fall through. * / ， case TK_AGG_FUNCTION :  ， case TK_COLUMN : { ， Expr * pDup = sqlite3ExprDup ( pParse->db , pExpr , 0 )  ;  ， p->pSub = sqlite3ExprListAppend ( pParse , p->pSub , pDup )  ;  ， assert ( ExprHasProperty ( pExpr , EP_Static ) =0 )  ;  ， ExprSetProperty ( pExpr , EP_Static )  ;  ， sqlite3ExprDelete ( pParse->db , pExpr )  ;  [ 2 ]  ， ExprClearProperty ( pExpr , EP_Static )  ;  ， memset ( pExpr , 0 , sizeof ( Expr )  ;  ， pExpr->op = TK_COLUMN ;  ， pExpr->iColumn = p->pSub->nExpr-1 ;  ， pExpr->iTable = p->pWin->iEphCsr ;  ， } ， . ， } ， During the deletion of the expression , if the expression is marked as a Window Function , the associated Window object is deleted as well. ， src/window.c : 1051 ， static SQLITE_NOINLINE void sqlite3ExprDeleteNN ( sqlite3 * db , Expr * p ) { ， . ， . ， assert ( p->op=TK_FUNCTION )  ;  ， sqlite3WindowDelete ( db , p->y.pWin )  ;  ， } ， } ， During the deletion of the Window , the assocated partition for the Window is deleted. ， src/window.c : 851 ， void sqlite3WindowDelete ( sqlite3 * db , Window * p ) { ， sqlite3ExprDelete ( db , p->pFilter )  ;  ， sqlite3ExprListDelete ( db , p->pPartition )  ;  ， sqlite3ExprListDelete ( db , p->pOrderBy )  ;  ， sqlite3ExprDelete ( db , p->pEnd )  ;  ， sqlite3ExprDelete ( db , p->pStart )  ;  ， sqlite3DbFree ( db , p->zName )  ;  ， sqlite3DbFree ( db , p )  ;  ， } ， } ， Looking back at the original sqlite3WindowRewrite function , this deleted partition is reused after the rewrite of the expression list [ 4 ] . ， src/window.c : 785 ， selectWindowRewriteEList ( pParse , pMWin , pSrc , p->pEList , &pSublist )  ;  [ 4 ]  ， selectWindowRewriteEList ( pParse , pMWin , pSrc , p->pOrderBy , &pSublist )  ;  ， pMWin->nBufferCol = ( pSublist ? pSublist->nExpr : 0 )  ;  ， . ， pSublist = exprListAppendList ( pParse , pSublist , pMWin->pPartition )  ;  [ 5 ]  ， src/window.c : 723 ， static ExprList * exprListAppendList (  ， Parse * pParse ,  ， ExprList * pList ,  ， ExprList * pAppend [ 5 ]  ，  ) { ， int i ;  ， int nInit = pList ? pList->nExpr : 0 ;  ， Expr * pDup = sqlite3ExprDup ( pParse->db , pAppend->a [ i ] .pExpr , 0 )  ;  ， pList = sqlite3ExprListAppend ( pParse , pList , pDup )  ;  ， } ， } ， } ， After this partition is deleted , it is then reused in exprListAppendList [ 5 ]  , causing a use after free vulnerability , resulting in a denial of service. If an attacker can control this memory after the free , there is an opportunity to corrupt more data , potentially leading to code execution. ， Crash Information ， Using the debug version of sqlite3 to trash contents of freed buffer helps demonstrate this vulnerability [ 5 ] . Watching for a crash around 0xfafafafafafafafa would mean a freed buffer is being accessed again. ， src/malloc.c : 341 ， void sqlite3DbFreeNN ( sqlite3 * db , void * p ) { ， assert ( db=0 | sqlite3_mutex_held ( db->mutex )  )  ;  ， assert ( p ! =0 )  ;  ， . ， LookasideSlot * pBuf = ( LookasideSlot *  ) p ;  ， / * Trash all content in the buffer being freed * / ， memset ( p , 0xfa , db->lookaside.sz )  ;  [ 5 ]  ， pBuf->pNext = db->lookaside.pFree ;  ， db->lookaside.pFree = pBuf ;  ， }",
    "time": "2019.05.13"
}