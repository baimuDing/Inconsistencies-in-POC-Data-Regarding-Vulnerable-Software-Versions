{
    "text": "vul_name : macOS 10.12 XNU UaF due to lack of locking in set_dp_control_port ， vul_cve : CVE-2016-7644 ， vul_poc : set_dp_control_port is a MIG method on the host_priv_port so this bug is a root->kernel escalation. ， kern_return_t ， set_dp_control_port (  ， host_priv_t host_priv ,  ， ipc_port_t control_port )  ， { ， ipc_port_release_send ( dynamic_pager_control_port )  ;  ， dynamic_pager_control_port = control_port ;  ， } ， This should be an atomic operation ; there's no locking so two threads can race to see the same value for dynamic_pager_control_port and release two references when the kernel only holds one. ， This PoC triggers the bug such that the first thread frees the port and the second uses it ; a more sensible approach towards exploiting it would be to use this race to try to decrement the reference count of a port with two references to zero such that you end up with a dangling port pointer. ， Tested on MacOS 10.12 16A323 ， / * ianbeer * / ， READ THIS FIRST :  ，  (  *  ) more precisely , I only have those devices and have only tested it on them. ，  (  *  ) 1b4150 will probably also work , I haven't tested it. ， Contents :  ， 1 - Build Instructions ， 2 - Adding support for other devices ， 3 - Notes on the bugs and exploits ，  ( 1 ) Build Instructions ，  * download and install Xcode 8.1 or higher ，  * download Jonathan Levins collection of arm64 iOS binaries :  ， + Follow the link for \"The 64-bit tgz pack\" here :  ，  ( you want iosbinpack64.tgz )  ， + extract it into the iosbinpack64 directory which is already in the mach_portal ， source dir so that directly underneath iosbinpack64 you have the bin/ , etc/ , sbin/ , usr/ directories ， When you expand the iosbinpack64 directory in the xcode folder view you should see those folders ，  * open this .xcodeproj ，  * if you don't have an apple id make one now at ，  * if you don't have a developer signing certificate you can make a free one now in Xcode ，  * in Xcode go Xcode->Preference->Accounts and click the '+' in the lower left hand corner and add your apple id ，  * select your account then \"View Details\" and under signing identites click Create next to iOS Development ，  * connect your iDevice and click \"trust\" in the pop up on it ，  * wait for xcode to process symbol files for this device ，  * in the box to the right of the play and stop buttons in the top left corner of the xcode window select your iDevice ，  * in the left hand window pane select the mach_portal project and navigate to the General tab ，  * in the signing window select your personal team ，  * We now need to fix up a few things :  ，  * go to Build Settings -> Packaging and give your project a new , unique bundle identifier ( eg change it from \"com.example.mach_portal\" to \"com.ios.test.account.mach_portal\" where ios.test.account is your apple id. ( it doesnt have to be your apple id , just a unique string )  ，  * We also need to register a unique App Group :  ，  * In the capabilities view scroll down to the App Groups section , remove the existing App Group ( \"group.mach_portal\" )  ， and add a new unique one ( eg \"group.ios.test.account.mach_portal\" )  ，  * open jailbreak.c and change the app_group variable to this new app group id. ，  * on the iDevice go to settings -> General -> Device Management and select your apple ID and click trust ，  * in xcode click view -> debug area -> activate console so you can see debugging output ( there's no output on the iDevice screen at all , that's normal )  ，  * make sure your iDevice and host are connected to the same wifi network and that network allows client to client connections. Note down the iDevice's ip address. ，  * click play to run the app on the iDevice. If it fails press and hold the power and home buttons to reset the device. If Xcode asks you to enable developer mode on this mac agree. ，  * if it succeeds you should see :  ， \"shell listening on port 4141\" ， printed to the debug consol ，  * the kernel exploit is only around 50% reliable ( this can certainly be improved , read the code and make it better !  )  ， it will fail more often if there is high system load - try leaving the device for a minute after rebooting it and connecting it to you mac before trying again ，  * connect to that port with netcat :  ， nc X.X.X.X 4141 ， where X.X.X.X is your iDevices ip address ，  * you have a root shell :  ) Theres no controlling terminal so fancy curses gui stuff won't work unless you fix that ，  * you can run any pseudo-signed thin ARM64 binaries - if you want the kernel task port it's host special port 4 ，  * copy your custom testing tools to the iosbinpack64 directory and they'll be bundled with the .app so you can run them from the shell ，  * you're running as an unsandboxed root user so you can talk to any iokit user clients/mach services ，  * amfid is patched to allow any signatures/entitlements ，  * When youre done hold power and home to reset the device ，  ( 2 ) Adding support for other devices ，  * you have to do this manually , sorry !  ，  * download the ipsw for your device from The bugs are there in any version <= 10.1.1 but the further back you go the more offsets will be wrong so ideally stick to 10.1.1 ( and for anything earlier that iOS 10 the kernel cache is encrypted so you'll have to do the rest yourself )  ，  * for >= iOS 10 unzip the ipsw and hexdump the kernel.release. * file like this :  ，  $ hexdump -C kernelcache.release.n51 | head ， 00000000 30 83 b5 9b 0d 16 04 49 4d 34 50 16 04 6b 72 6e | 0.IM4P.krn |  ， 00000010 6c 16 1c 4b 65 72 6e 65 6c 43 61 63 68 65 42 75 | l.KernelCacheBu |  ， 00000020 69 6c 64 65 72 2d 31 31 36 32 2e 32 30 2e 31 04 | ilder-1162.20.1. |  ， 00000030 83 b5 9a de 63 6f 6d 70 6c 7a 73 73 83 13 7d ae | .complzss.}. |  ， 00000040 01 64 80 00 00 b5 29 5e 00 00 00 01 00 00 00 00 | .d. ) ^. |  ， 00000050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | . |  ， 000001b0 00 00 00 00 ff cf fa ed fe 0c 00 00 01 d5 00 f6 | . |  ， 000001c0 f0 02 f6 f0 14 f6 f0 38 0e 9a f3 f1 20 f6 f1 00 | .8. . |  ， 000001d0 19 ff f1 f5 f0 5f 9f 5f 54 45 58 54 09 02 1c 03 | ._._TEXT. |  ，  * note down the offset of the ff cf fa ed fe byte sequence ( in this case it's 0x1b4 )  ，  * compile lzssdec from ，  * run a command like : lzssdec -o 0x1b4 < kernel.release.n51 > kernel.decompressed ，  * open the decompressed kernelcache in a recent version of IDA Pro ( with support for iOS kextcaches )  ，  * say yes when IDA asks to split by kext ，  * let the auto-analysis run - depending on how fast your computer is this might take a while !  ( it takes my 2013 MBP about 30 minutes )  ，  * go view -> open subviews -> segments and find the _TEXT : HEADER segment , the start should be FFFFFFF007004000 ，  * go view -> open subviews -> names and find the kernproc data symbol. ，  * subtract the _TEXT : HEADER value from that , this is the kernproc offset ， eg for iPhone 5S 10.1.1 kernproc is at FFFFFFF0075AE0E0 making the offset : 0x5AA0E0 ，  * now the harder one ! We need to find allproc which isn't exported so is harder to find :  ，  * go view -> open subviews -> strings and find the string \"pgrp_add : pgrp is dead adding process\" ，  * hit 'x' on the autogenerated string symbol name ; you should see this symbol referenced from two functions ，  * open the smaller of those functions in the IDA graph view ，  * this is pgrp_add in the XNU source ，  * scroll to the bottom of the CFG , the final three nodes all reference the same global variable with code like this :  ， ADRP X8 ,  # qword_FFFFFFF0075A8128 @ PAGE ， LDR X9 ,  [ X8 ,  # qword_FFFFFFF0075A8128 @ PAGEOFF ]  ，  * that's the address of allproc - subtract the kernel base to get the offset , in this case it's : 0x5A4128 ，  * open offset.c and add support for your device. You should only have to update those two variable ( kernproc and allproc )  ， The structure offsets should stay the same , at least for recent kernels. If you want to target a much older kernel you'll ， also have to work out all the structure offsets - this is much more fiddly. ，  * 32-bit devices :  ， All the offsets will be totally different and the code which manipulates the kernel data structures will also be completely wrong. ， There's no reason it wouldn't work but you'll have to fix the code to make it work ， fixing userspace stuff ， I also rely on a handful of offsets in amfid ; you should be able to find those very easily if they're different on your target. ， See the code and alse the section \"Patch amfid\" below. ，  ( 3 ) Notes on the bugs and exploits ， This project is called \"mach_portal\" - it's the result of a research project I did this year looking at mach ports. ( All the bugs used ， involve mach ports : - )  ) There are two main bugs plus one more which is only used to force a service to restart :  ， CVE-2016-7637 : Broken kernel mach port name uref handling on iOS/MacOS can lead to privileged port name replacement in other processes ， CVE-2016-7644 : XNU kernel UaF due to lack of locking in set_dp_control_port ， CVE-2016-7661 : MacOS/iOS arbitrary port replacement in powerd ， There is no untether ( persistent codesigning bypass ) but the exploit will temporarily disable codesigning while it runs so you can run ， unsigned binaries. ， The high level exploit flow is like this :  ， I use CVE-2016-7637 to replace launchd's send right to com.apple.iohideventsystem with a send right to a port for which I hold the receive right. ， I use CVE-2016-7661 to crash the powerd daemon ( which runs as root ) . It gets automatically restarted and as part of its startup it will lookup the com.apple.iohideventsystem mach service and send its own task port to that service. Since I hold the receive right for that port this means that powerd actually sends me its task port giving me complete control over it : - )  ， I use powerd's task port to get the host_priv port which I use to trigger the kernel bug. ， The kernel bug is a lack of locking when releasing a reference on a port. I allocate a large number of mach ports then trigger the bug on around 20 ， of them which are likely to be allocated near each other in the kernel. I use no-more-senders notifications so I can deterministically know when I've ， managed to over-release a port so that I can actually give myself dangling port pointers at an exact point in time later. ， I free all these mach ports ( leaving myself with ~ 20 dangling mach port pointers ) and force a zone GC. I try to move ， the page pointed to by all the dangling port pointers into the kalloc.4096 zone and then I send myself a large number of mach message containing OOL ， ports with send rights to the host port. I set up these OOL port pages so that overlapping the dangling port's context pointers there's a pointer to the host port ipc_port and the dangling port's lock and is_guarded fields are replaced with NULL pointers. ， If that all worked I can call mach_port_get_context on each of the dangling ports and I should get back the address of the host port ipc_port. ， The kernel task port is allocated at around the same time as the host port and as such they both end up in the same kernel zone page. I work out the base of this page then call mach_port_set_context on all of the dangling ports passing each possible address of the kernel task port in turn. I then receive all the ports I sent to myself and if everything worked I've ended receiving a send right to the kernel task port :  )  ， Here's a more detailed writeup of the sandbox escape part of the exploit. You'll have to read the code for the kernel exploit , I haven't written a longer writeup for that yet. ， Sandbox escape ， When sending and receiving mach messages from userspace there are two important kernel objects ; ipc_entry and ipc_object. ， ipc_entry's are the per-process handles or names which a process uses to refer to a particular ipc_object. ， ipc_object is the actual message queue ( or kernel object ) which the port refers to. ， ipc_entrys have a pointer to the ipc_object they are a handle for along with the ie_bits field which contains the urefs and capacility bits for this name/handle ( whether this is a send right , receive right etc. )  ， struct ipc_entry { ， struct ipc_object * ie_object ;  ， ipc_entry_bits_t ie_bits ;  ， mach_port_index_t ie_index ;  ， union { ， mach_port_index_t next ; / * next in freelist , or. * / ， ipc_table_index_t request ; / * dead name request notify * / ， } index ;  ， } ; ",
    "time": "2016.12.16"
}