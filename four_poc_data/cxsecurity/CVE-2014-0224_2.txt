{
    "text": "vul_name : OpenSSL 1.0.1g ChangeCipherSpec Attack ， vul_cve : CVE-2014-0224 ， vul_poc : OpenSSL 1.0.1h ( and others ) were released today with a scary looking security advisiory and that's always an event worth looking into. ( Hopefully people are practiced at updating OpenSSL now !  )  ， Update : the original reporter has a blog post up. Also , I won't , personally , be answering questions about specific Google services. ( I cut this blog post together from notes that I'm writing for internal groups to evaluate and this is still very fresh. )  ， Update : my initial thoughts from looking at the diff still seem to be holding up. Someone is welcome to write a more detailed analysis than below. HP/ZDI have a write up of one of the DTLS issues. ， There are some critical bug fixes to DTLS ( TLS over datagram transports , i.e. UDP )  , but most people will be more concerned about the MITM attack against TLS ( CVE-2014-0224 ) . ， The code changes are around the rejection of ChangeCipherSpec messages , which are messages sent during the TLS handshake that mark the change from unencrypted to encrypted traffic. These messages aren't part of the handshake protocol itself and aren't linked into the handshake state machine in OpenSSL. Rather there's a check in the code that they are only received when a new cipher is ready to be used. However , that check ( for s->s3->tmp.new_cipher in s3_pkt.c ) seems reasonable , but new_cipher is actually set as soon as the cipher for the connection has been decided ( i.e. once the ServerHello message has been sent/received )  , not when the cipher is actually ready ! It looks like this is the problem that's getting fixed in this release. ， Here's the code in question that handles a ChangeCipherSpec message :  ， int ssl3_do_change_cipher_spec ( SSL * s )  ， { ， int i ;  ， const char * sender ;  ， int slen ;  ， i=SSL3_CHANGE_CIPHER_SERVER_READ ;  ， i=SSL3_CHANGE_CIPHER_CLIENT_READ ;  ， { ， { ， / * might happen if dtls1_read_bytes (  ) calls this * / ， SSLerr ( SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC , SSL_R_CCS_RECEIVED_EARLY )  ;  ， } ， s->session->cipher=s->s3->tmp.new_cipher ;  ， } ， / * we have to record the message digest at ，  * this point so we can get it before we read ，  * the finished message * / ， { ， sender=s->method->ssl3_enc->server_finished_label ;  ， slen=s->method->ssl3_enc->server_finished_label_len ;  ， } ， { ， sender=s->method->ssl3_enc->client_finished_label ;  ， slen=s->method->ssl3_enc->client_finished_label_len ;  ， } ， i = s->method->ssl3_enc->final_finish_mac ( s ,  ， sender , slen , s->s3->tmp.peer_finish_md )  ; 3 ， { ， SSLerr ( SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC , ERR_R_INTERNAL_ERROR )  ;  ， } ， s->s3->tmp.peer_finish_md_len = i ;  ， } ， If a ChangeCipherSpec message is injected into the connection after the ServerHello , but before the master secret has been generated , then ssl3_do_change_cipher_spec will generate the keys ( 2 ) and the expected Finished hash ( 3 ) for the handshake with an empty master secret. This means that both are based only on public information. Additionally , the keys will be latched because of the check at ( 1 ) - further ChangeCipherSpec messages will regenerate the expected Finished hash , but not the keys. ， The oldest source code on the OpenSSL site is for 0.9.1c ( Dec 28 , 1998 ) and the affected code appears almost unchanged. So it looks like this bug has existed for 15+ years. ， The implications of this are pretty complex. ， For a client there's an additional check in the code that requires that a CCS message appear before the Finished and after the master secret has been generated. An attacker can still inject an early CCS too and the keys will be calculated with an empty master secret. Those keys will be latched - another CCS won't cause them to be recalculated. However , when sending the second CCS that the client code requires , the Finished hash is recalculated with the correct master secret. This means that the attacker can't fabricate an acceptable Finished hash. This stops the obvious , generic impersonation attack against the client. ， For a server , there's no such check and it appears to be possible to send an early CCS message and then fabricate the Finished hash because it's based on an empty master secret. However , that doesn't obviously gain an attacker anything. It would be interesting if a connection with a client certificate could be hijacked , but there is a check in ssl3_get_cert_verify that a CCS hasn't been already processed so that isn't possible. ， Someone may be able to do something more creative with this bug ; I'm not ruling out that there might be other implications. ， Things change with an OpenSSL 1.0.1 server however. In 1.0.1 , a patch of mine was included that moves the point where Finished values are calculated. The server will now use the correct Finished hash even if it erroneously processed a CCS , but this interacts badly with this bug. The server code ( unlike the client ) won't accept two CCS messages in a handshake. So , if an attacker injects an early CCS at the server to fixate the bad keys , then it's not possible for them to send a second in order to get it to calculate the correct Finished hash. But with 1.0.1 , the server will use the correct Finished hash and will reply with the correct hash to the client. This explains the 1.0.1 and 1.0.2 mention in the advisory. With any OpenSSL client talking to an OpenSSL 1.0.1 server , an attacker can inject CCS messages to fixate the bad keys at both ends but the Finished hashes will still line up. So it's possible for the attacker to decrypt and/or hijack the connection completely. ， The good news is that these attacks need man-in-the-middle position against the victim and that non-OpenSSL clients ( IE , Firefox , Chrome on Desktop and iOS , Safari etc ) aren't affected. None the less , all OpenSSL users should be updating. ， I'm hacking up the Go TLS library to play with this and might be able to build a probing tool without too much effort.",
    "time": "2014.06.06"
}