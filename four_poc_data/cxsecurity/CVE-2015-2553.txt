{
    "text": "vul_name : Windows 10 Sandboxed Mount Reparse Point Creation Mitigation Bypass ( MS15-111 )  ， vul_cve : CVE-2015-2553 ， vul_poc : Source :  ， Windows : Sandboxed Mount Reparse Point Creation Mitigation Bypass ， Platform : Windows 10 ( build 10240 )  , earlier versions do not have the functionality ， Class : Security Feature Bypass ， Summary :  ， A mitigation added to Windows 10 to prevent NTFS Mount Reparse Points being created at integrity levels below medium can be bypassed. ， Description :  ， Windows 10 has added some new mitigations to block the creation or change the behaviour of certain symbolic links when issued by a low integrity/sandboxed process. The presumed aim to to make it harder to abuse these types of tricks to break out of a sandbox. ， In earlier builds on Windows 10 NTFS Mount Reparse Points were blocked outright from a sandboxed process , however in 10240 ( what can only be assumed a final build ) the check was moved to the kernel in IopXControlFile and changed slightly so that sandboxed processes could create some mount points. The check is roughly :  ， NTSTATUS status = ZwOpenFile ( . , buffer->ReparseTarget , FILE_GENERIC_WRITE , . , FILE_DIRECTORY_FILE )  ;  ， } ， } ， } ， The kernel is therefore checking that the target of the mount point is a directory and that the current process has write access to the directory. This would sufficiently limit the ability of a sandboxed process to abuse this to write files at a higher privilege. Unfortunately theres a perhaps unexpected problem with this check , the sandboxed process can redirect the ZwOpenFile call arbitrarily to something it can open for write , yet the original value is set as the mount point. This is because the file open check is being made inside the process which is doing the call which means it honours the users device mapping. ， While the sandboxed process cannot change the per-user drive mappings , it can change the processs device map using NtSetInformationProcess with the ProcessDeviceMap information class. As we can create arbitrary object directories and symbolic links ( which while they also have a mitigation it only prevents a higher privilege process following them , which we dont care about ) we can build a completely fake device map which redirects the open to another directory. A good target turns out to be DeviceNamedPipe ( note the trailing slash ) as that can be opened from any privilege level ( including Chrome renderer processes ) for write access and as a directory. So if we want to set an arbitrary mount point to say ?c : somewhere we can build something like :  ， <UNNAMED> ( DIR ) -> C :  ( DIR ) -> somewhere ( LINK to DeviceNamedPipe )  ， If we set the unnamed directory to the process device map we can bypass the check and create the mount point. ， Perhaps from a fix perspective you could query for the opened path and use that to write to the NTFS reparse point rather than using the original value.",
    "time": "2015.10.16"
}