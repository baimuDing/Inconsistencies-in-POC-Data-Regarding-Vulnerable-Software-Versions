{
    "text": "vul_name : Linux Kernel <= 3.18 Buffer overflow when copying data from skbuff to userspace ， vul_cve : CVE-2015-8019 ， vul_poc : skb_copy_and_csum_datagram_iovec doesn't check the actual length of the iovec's buffers to which it copies data , then memcpy_toiovec can copy to an address that was not specified by userspace , but garbage lying on the kernel stack. ， In some cases , this address can be a valid userspace address , to which memcpy_toiovec will write the buffers. ， This can happen when userspace calls write followed by recvmsg. ， In that case , memcpy_toiovec will dump the packet contents to the buffer passed to the write call , and can for example overwrite stack contents. ， Patch has been submitted :  ， diff -git a/include/linux/skbuff.h b/include/linux/skbuff.h ， index ab3133797ff7.220454f32509 100644 ， - a/include/linux/skbuff.h ， + b/include/linux/skbuff.h ， -2431 , 7 +2431 , 7 unsigned int datagram_poll ( struct file * file , struct socket * sock ,  ， int skb_copy_datagram_iovec ( const struct sk_buff * from , int offset ,  ， struct iovec * to , int size )  ;  ， int skb_copy_and_csum_datagram_iovec ( struct sk_buff * skb , int hlen ,  ， - struct iovec * iov )  ;  ， + struct iovec * iov , int len )  ;  ， int skb_copy_datagram_from_iovec ( struct sk_buff * skb , int offset ,  ， const struct iovec * from , int from_offset ,  ， int len )  ;  ， diff -git a/net/core/datagram.c b/net/core/datagram.c ， index 13bc7dad7990.3437762668af 100644 ， - a/net/core/datagram.c ， + b/net/core/datagram.c ， -796 , 6 +796 , 7 EXPORT_SYMBOL ( _skb_checksum_complete )  ;  ，  *  @ skb : skbuff ，  *  @ hlen : hardware length ，  *  @ iov : io vector ， + *  @ len : amount of data to copy from skb to iov ，  * Caller _must_ check that skb will fit to this iovec. ， -805 , 11 +806 , 14 EXPORT_SYMBOL ( _skb_checksum_complete )  ;  ，  * can be modified !  ， int skb_copy_and_csum_datagram_iovec ( struct sk_buff * skb ,  ， - int hlen , struct iovec * iov )  ， + int hlen , struct iovec * iov , int len )  ， { ， _wsum csum ;  ， int chunk = skb->len - hlen ;  ， + if ( chunk > len )  ， + chunk = len ;  ， + ， diff -git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c ， index 9fbd69efa999.cf6168b897c3 100644 ， - a/net/ipv4/tcp_input.c ， + b/net/ipv4/tcp_input.c ， -4934 , 7 +4934 , 7 static int tcp_copy_to_iovec ( struct sock * sk , struct sk_buff * skb , int hlen )  ， err = skb_copy_datagram_iovec ( skb , hlen , tp->ucopy.iov , chunk )  ;  ， err = skb_copy_and_csum_datagram_iovec ( skb , hlen ,  ， - tp->ucopy.iov )  ;  ， + tp->ucopy.iov , chunk )  ;  ， tp->ucopy.len -= chunk ;  ， diff -git a/net/ipv4/udp.c b/net/ipv4/udp.c ， index 6970e36ad7b8.8395cf5ec487 100644 ， - a/net/ipv4/udp.c ， + b/net/ipv4/udp.c ， -1268 , 7 +1268 , 7 try_again :  ， err = skb_copy_and_csum_datagram_iovec ( skb ,  ， sizeof ( struct udphdr )  ,  ， - msg->msg_iov )  ;  ， + msg->msg_iov , copied )  ;  ， goto csum_copy_err ;  ， diff -git a/net/ipv6/raw.c b/net/ipv6/raw.c ， index 1f29996e368a.e6c9b4a7ee3c 100644 ， - a/net/ipv6/raw.c ， + b/net/ipv6/raw.c ， -492 , 7 +492 , 7 static int rawv6_recvmsg ( struct kiocb * iocb , struct sock * sk ,  ， goto csum_copy_err ;  ， err = skb_copy_datagram_iovec ( skb , 0 , msg->msg_iov , copied )  ;  ， } else { ， - err = skb_copy_and_csum_datagram_iovec ( skb , 0 , msg->msg_iov )  ;  ， + err = skb_copy_and_csum_datagram_iovec ( skb , 0 , msg->msg_iov , copied )  ;  ， goto csum_copy_err ;  ， } ， diff -git a/net/ipv6/udp.c b/net/ipv6/udp.c ， index 38625a91ec94.4011ccad6c9f 100644 ， - a/net/ipv6/udp.c ， + b/net/ipv6/udp.c ， -428 , 7 +428 , 8 try_again :  ， err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr )  ,  ， msg->msg_iov , copied )  ;  ， - err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr )  , msg->msg_iov )  ;  ， + err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr )  ,  ， + msg->msg_iov , copied )  ;  ， goto csum_copy_err ;  ， } ， diff -git a/net/rxrpc/ar-recvmsg.c b/net/rxrpc/ar-recvmsg.c ， index 4949f753686c.83484ebf691d 100644 ， - a/net/rxrpc/ar-recvmsg.c ， + b/net/rxrpc/ar-recvmsg.c ， -186 , 7 +186 , 8 int rxrpc_recvmsg ( struct kiocb * iocb , struct socket * sock ,  ， msg->msg_iov , copy )  ;  ， } else { ， ret = skb_copy_and_csum_datagram_iovec ( skb , offset ,  ， - msg->msg_iov )  ;  ， + msg->msg_iov ,  ， + copy )  ;  ， goto csum_copy_error ;  ， } ， Versions affected :  ， stable kernels before v3.19 ( 3.x.y , x <= 18 ) that have backported ， commit 89c22d8c3b27 ( \"net : Fix skb csum races when peeking\" )  ， v3.18.22 ， v3.14.54+ ， v3.12.48 , v3.12.49 ， v3.10.90+ ， v3.2.72 ， 3.16.7-ckt17 , 3.16.7-ckt18 ， 3.13.11-ckt27 , 3.13.11-ckt28",
    "time": "2015-10-28 / 2015-10-29"
}