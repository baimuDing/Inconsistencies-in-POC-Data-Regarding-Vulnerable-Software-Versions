{
    "text": "vul_name : nginx 1.20.0 DNS Resolver Off-By-One Heap Write ， vul_cve : CVE-2021-23017 ， vul_poc : Advisory X41-2021-002 : nginx DNS Resolver Off-by-One Heap Write Vulnerability ， Severity Rating : High ， Confirmed Affected Versions : 0.6.18 - 1.20.0 ， Confirmed Patched Versions : 1.21.0 , 1.20.1 ， Vendor : F5 , Inc. ， Vendor URL :  ， Vendor ， Vector : Remote / DNS ， Credit : X41 D-SEC GmbH , Luis Merino , Markus Vervier , Eric Sesterhenn ， Status : Public ， CVE : CVE-2021-23017 ， CWE : 193 ， CVSS Score : 8.1 ， CVSS Vector : CVSS : 3.1/AV : N/AC : H/PR : N/UI : N/S : U/C : H/I : H/A : H/E : U/RL : O/RC : C ， Advisory-URL :  ， Summary and Impact ， An off-by-one error in ngx_resolver_copy (  ) while processing DNS responses ， allows a network attacker to write a dot character ( '.' , 0x2E ) out of bounds ， in a heap allocated buffer. The vulnerability can be triggered by a DNS ， response in reply to a DNS request from nginx when the resolver primitive ， is configured. A specially crafted packet allows overwriting the least ， significant byte of next heap chunk metadata with 0x2E. A network attacker ， capable of providing DNS responses to a nginx server can achieve ， Denial-of-Service and likely remote code execution. ， Due to the lack of DNS spoofing mitigations in nginx and the fact that the ， vulnerable function is called before checking the DNS Transaction ID , remote ， attackers might be able to exploit this vulnerability by flooding the ， victim server with poisoned DNS responses in a feasible amount of time. ， Root Cause Analysis ， nginx DNS resolver ( core/ngx_resolver.c ) is used to resolve hostnames via DNS ， ngx_resolver_copy (  ) is called to validate and decompress each DNS domain name ， contained in a DNS response , receiving the network packet as input and a ， pointer to the name being processed , and returning a pointer to a newly ， allocated buffer containing the uncompressed name on success. This is done ， in two steps ,  ， 1 ) The uncompressed domain name sizelenis calculated and the input packet is ， validated , discarding names containing more than 128 pointers or containing ， pointers that fall out of the input buffer boundaries. ， 2 ) An output buffer is allocated , and the uncompressed name is copied into it. ， A mismatch between size calculation in part 1 and name decompression in part 2 ， leads to an off-by-one error inlen , allowing to write a dot character one byte ， off name->data boundaries. ， The miscalculation happens when the last part of the compressed name contains a ， pointer to a NUL byte. While the calculation step only accounts dots between ， labels , the decompression step writes a dot character every time a label has ， been processed and next character is not NUL. When a label is followed by a ， pointer that leads to a NUL byte , the decompression procedure will :  ， / 1 ) copy the label to the output buffer ,  ， ngx_strlow ( dst , src , n )  ;  ， dst += n ;  ， src += n ;  ， / 2 ) read next character ,  ， n = * src+ ;  ， / 3 ) as its a pointer , its not NUL ,  ， / 4 ) so a dot character that was not accounted for is written out of bounds ，  * dst+ = '.' ;  ， } ， / 5 ) Afterwards , the pointer is followed ,  ， n = ( n & 0x3f ) 8 ) + * src ;  ， src = &buf [ n ]  ;  ， n = * src+ ;  ， } ， / 6 ) and a NULL byte is found , signaling the end of the function ， name->len = dst - name->data ;  ， } ， If the calculated size happens to align with the heap chunk size , the dot ， character , written out of bounds , will overwrite the least significant byte ， of next heap chunk size metadata. This might modify the size of the next heap ， chunk , but also overwrite 3 flags , resulting in PREV_INUSE being cleared ， and IS_MMAPPED being set :  ， =7863= Invalid write of size 1 ， =7863= at 0x137C2E : ngx_resolver_copy ( ngx_resolver.c : 4018 )  ， =7863= by 0x13D12B : ngx_resolver_process_a ( ngx_resolver.c : 2470 )  ， =7863= by 0x13D12B : ngx_resolver_process_response ( ngx_resolver.c : 1844 )  ， =7863= by 0x13D46A : ngx_resolver_udp_read ( ngx_resolver.c : 1574 )  ， =7863= by 0x14AB19 : ngx_epoll_process_events ( ngx_epoll_module.c : 901 )  ， =7863= by 0x1414D4 : ngx_process_events_and_timers ( ngx_event.c : 247 )  ， =7863= by 0x148E57 : ngx_worker_process_cycle ( ngx_process_cycle.c : 719 )  ， =7863= by 0x1474DA : ngx_spawn_process ( ngx_process.c : 199 )  ， =7863= by 0x1480A8 : ngx_start_worker_processes ( ngx_process_cycle.c : 344 )  ， =7863= by 0x14952D : ngx_master_process_cycle ( ngx_process_cycle.c : 130 )  ， =7863= by 0x12237F : main ( nginx.c : 383 )  ， =7863= Address 0x4bbcfb8 is 0 bytes after a block of size 24 alloc'd ， =7863= at 0x483E77F : malloc ( vg_replace_malloc.c : 307 )  ， =7863= by 0x1448C4 : ngx_alloc ( ngx_alloc.c : 22 )  ， =7863= by 0x137AE4 : ngx_resolver_alloc ( ngx_resolver.c : 4119 )  ， =7863= by 0x137B26 : ngx_resolver_copy ( ngx_resolver.c : 3994 )  ， =7863= by 0x13D12B : ngx_resolver_process_a ( ngx_resolver.c : 2470 )  ， =7863= by 0x13D12B : ngx_resolver_process_response ( ngx_resolver.c : 1844 )  ， =7863= by 0x13D46A : ngx_resolver_udp_read ( ngx_resolver.c : 1574 )  ， =7863= by 0x14AB19 : ngx_epoll_process_events ( ngx_epoll_module.c : 901 )  ， =7863= by 0x1414D4 : ngx_process_events_and_timers ( ngx_event.c : 247 )  ， =7863= by 0x148E57 : ngx_worker_process_cycle ( ngx_process_cycle.c : 719 )  ， =7863= by 0x1474DA : ngx_spawn_process ( ngx_process.c : 199 )  ， =7863= by 0x1480A8 : ngx_start_worker_processes ( ngx_process_cycle.c : 344 )  ， =7863= by 0x14952D : ngx_master_process_cycle ( ngx_process_cycle.c : 130 )  ， More information about general exploitability of a similar bug class found in",
    "time": "2021.05.31"
}