{
    "text": "vul_name : Linux Kernel 3.14.3 filter prevent nla extensions ， vul_cve : CVE-2014-3144 , CVE-2014-3145 ， vul_poc : filter : prevent nla extensions to peek beyond the end of the message ， The BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check ， within the bounds of the message. This allows the subtraction of the nla ， header to underflow and therefore - as the data type is unsigned - ， allowing far to big offset and length values for the search of the ， netlink attribute. ， The remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is ， also wrong. It has the minuend and subtrahend mixed up , therefore ， calculates a huge length value , allowing to overrun the end of the ， message while looking for the netlink attribute. ， The following three BPF snippets will trigger the bugs when attached to ， a UNIX datagram socket and parsing a message with length 1 , 2 or 3. ，  , - [ PoC for missing size check in BPF_S_ANC_NLATTR ] - ，  | ld # 0x87654321 ，  | ldx # 42 ，  | ld # nla ，  | ret a ， `- ，  , - [ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ] - ，  | ld # 0x87654321 ，  | ldx # 42 ，  | ld # nlan ，  | ret a ， `- ，  , - [ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ] - ，  |  ;  ( needs a fake netlink header at offset 0 )  ，  | ld # 0 ，  | ldx # 42 ，  | ld # nlan ，  | ret a ， `- ， Fix the first issue by ensuring the message length fulfills the minimal ， size constrains of a nla header. Fix the second bug by getting the math ， diff -git a/net/core/filter.c b/net/core/filter.c ， index e08b382.0e0856f 100644 ， - a/net/core/filter.c ， + b/net/core/filter.c ， -600 , 6 +600 , 9 static u64 _skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 )  ， + if ( skb->len < sizeof ( struct nlattr )  ， + return 0 ;  ， + ， -618 , 11 +621 , 14 static u64 _skb_get_nlattr_nest ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 )  ， + if ( skb->len < sizeof ( struct nlattr )  ， + return 0 ;  ， + ， nla = ( struct nlattr *  ) &skb->data [ A ]  ;  ， - if ( nla->nla_len > A - skb->len )  ， + if ( nla->nla_len > skb->len - A )  ， nla = nla_find_nested ( nla , X )  ; ",
    "time": "2014-05-11 / 2014-05-12"
}