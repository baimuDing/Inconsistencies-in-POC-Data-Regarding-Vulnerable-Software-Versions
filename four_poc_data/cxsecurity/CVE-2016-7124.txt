{
    "text": "vul_name : PHP 7.0.9 _wakeup (  ) in Deserialization ， vul_cve : CVE-2016-7124 ， vul_poc : Description :  ， Create an Unexpected Object and Don't Invoke _wakeup (  ) in During Deserialization ， ` ， static inline long object_common1 ( UNSERIALIZE_PARAMETER , zend_class_entry * ce )  ， { ， . ， object_init_ex (  * rval , ce )  ; <= create object ， . ， static inline int object_common2 ( UNSERIALIZE_PARAMETER , long elements )  ， { ， . ， } ， zend_hash_exists ( &Z_OBJCE_PP ( rval ) ->function_table , \"_wakeup\" , sizeof ( \"_wakeup\" ) { ， INIT_PZVAL ( &fname )  ;  ， ZVAL_STRINGL ( &fname , \"_wakeup\" , sizeof ( \"_wakeup\" ) - 1 , 0 )  ;  ， BG ( serialize_lock ) + ;  ， call_user_function_ex ( CG ( function_table )  , rval , &fname , &retval_ptr , 0 , 0 , 1 , NULL TSRMLS_CC )  ; <= call to _wakeup (  )  ， BG ( serialize_lock ) - ;  ， } ， ` ， If the process_nested_data (  ) return 0 , the _wakeup (  ) will not be invoked , but the object and its properties has been created , then the unexpected object will be destroyed ( or may not ) . This may cause some security issues. ， i ) The unexpected object was destroyed , invoke _destruct (  )  ， Some app revents objects deserialization via _wakeup (  )  , ex SugarCRM :  ， ` ， public function _destruct (  )  ， { ， fclose (  $ this->stream )  ;  ，  $ this->stream = null ;  ， } ，  @ unlink (  $ this->stream_name )  ;  ， } ， } ，  * This is needed to prevent unserialize vulnerability ， public function _wakeup (  )  ， { ， / clean all properties ， foreach ( get_object_vars (  $ this ) as $ k => $ v ) { ，  $ this-> $ k = null ;  ， } ， throw new Exception ( \"Not a serializable object\" )  ;  ， } ， ` ， So attacker can bypass _wakeup (  ) and invoke _destruct (  ) with crafted properties. ， ii ) The unexpected object wasn't destroyed , invoke more magic methods. ， Keeping the unexpected object via customized deserialization. ， PoC :  ， `",
    "time": "2016.09.05"
}