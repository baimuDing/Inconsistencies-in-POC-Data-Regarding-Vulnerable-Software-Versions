{
    "text": "vul_name : libpng 1.6.15 Heap Overflow ， vul_cve : CVE-2015-0973 ， vul_poc : / ，  * Alex Eubanks *  ，  * endeavor @ rainbowsandpwnies.com *  ，  * libpng 1.6.15 heap overflow *  ，  * 18 December 2014 *  ，  * A foreword *  ， / this bug was found with american fuzzy lop ! thanks lcamtuf !  ，  * We will trigger a call to zlib which will decompress data from an IDAT chunk ，  * into a heap-buffer of 48 bytes. The size of this heap-buffer does not depend ，  * on the amount of data we decompress into it. ，  * In some cases , like my case ( programs are wonderful creations )  , this may ，  * allow for a controlled write. ，  * My environment is ，  * user @ debian :  ~  $ uname -a ，  * Linux debian 3.2.0-4-686-pae # 1 SMP Debian 3.2.63-2+deb7u2 i686 GNU/Linux ，  * Example code to trigger this overflow is available at the end of this post. ，  * Simply set OVERFLOW_DATA to what you want to overflow the heap with. ， Program received signal SIGSEGV , Segmentation fault. ， 0xb7eb4f71 in ? (  ) from /lib/i386-linux-gnu/i686/cmov/libc.so.6 ，  ( gdb ) x/i $ pc ， => 0xb7eb4f71 : movdqu %xmm0 ,  ( %esi )  ，  ( gdb ) i r esi ， esi 0x41414141 1094795585 ，  ( gdb ) i r xmm0 ， xmm0 {v4_float = {0xc , 0xc , 0xc , 0xc} , v2_double = {0x228282 , 0x228282} , v16_int8 = {0x41 <repeats 16 times>} ,  ， v8_int16 = {0x4141 , 0x4141 , 0x4141 , 0x4141 , 0x4141 , 0x4141 , 0x4141 , 0x4141} , v4_int32 = {0x41414141 , 0x41414141 ,  ， 0x41414141 , 0x41414141} , v2_int64 = {0x4141414141414141 , 0x4141414141414141} ,  ， uint128 = 0x41414141414141414141414141414141} ，  * The overflow *  ，  # pngrutil.c : png_read_IDAT_data : line 4018 ，  * At the time of this call ,  ，  * png_ptr->zstream->avail_out = 0x20000000 ，  * png_ptr->zstream->avail_in = size of our compressed IDAT data ，  * png_ptr->zstream->next_in = our compressed IDAT data ，  * png_ptr->zstream->next_out = a pointer to row_buf , 31 bytes in big_row_buf ， ret = inflate ( &png_ptr->zstream , Z_NO_FLUSH )  ;  ，  * IHDR *  ，  [ 0-3 ] = png_ptr->width / 0x20000000 ，  [ 4-7 ] = png_ptr->height / 0x00000020 ，  [ 8 ] = png_ptr->bit_depth / 0x10 ，  [ 9 ] = png_ptr->color_type / 0x06 ，  [ 10 ] = png_ptr->compression_type / 0x00 ，  [ 11 ] = png_ptr->filter_type / 0x00 ，  [ 12 ] = png_ptr->interlace_type / 0x01 ，  * png_read_IDAT_data *  ，  # pngrutil.c : png_read_IDAT_data : line 3941 ， void / * PRIVATE * / ， png_read_IDAT_data ( png_structrp png_ptr , png_bytep output ,  ， png_alloc_size_t avail_out )  ，  * png_bytep output ，  * \\-> a buffer to decompress the IDAT data into ，  * png_alloc_size_t avail_out ，  * \\-> The size of output in bytes ，  # pngrutil.c : png_read_IDAT_data : line 3984 ， buffer = png_read_buffer ( png_ptr , avail_in , 0/ * error * / )  ;  ，  # pngrutil.c : png_read_IDAT_data : line 3989 ， png_ptr->zstream.next_in = buffer ;  ，  # pngrutil.c : png_read_IDAT_data : line 3946 ， png_ptr->zstream.next_out = output ;  ，  # pngrutil.c : png_read_IDAT_data : line 4002 ， png_ptr->zstream.avail_out = out ;  ， pngrutil.c : png_read_IDAT_data : line 4018 ， ret = inflate ( &png_ptr->zstream , Z_NO_FLUSH )  ;  ，  * The call to png_read_IDAT_data *  ，  # pngread.c : png_read_row : line 534 ， png_read_IDAT_data ( png_ptr , png_ptr->row_buf , row_info.rowbytes + 1 )  ;  ，  # pngrutil.c : png_read_IDAT_data : line 3941 ， void / * PRIVATE * / ， png_read_IDAT_data ( png_structrp png_ptr , png_bytep output , png_alloc_size_t avail_out )  ，  * deriving row_info.rowbytes *  ，  # pngread.c : png_read_row : line 397 ， row_info.rowbytes = PNG_ROWBYTES ( row_info.pixel_depth , row_info.width )  ;  ，  * deriving row_info.rowbytes *  ，  * \\-> deriving row_info.pixel_depth *  ，  # pngread.c : png_read_row : line 396 ， row_info.pixel_depth = png_ptr->pixel_depth ;  ， / row_info.pixel_depth is set in png_handle_IHDR ，  # pngrutil.c : png_handle_IHDR : line 855 ， png_ptr->pixel_depth = ( png_byte )  ( png_ptr->bit_depth * png_ptr->channels )  ;  ， / where png_ptr->bit_depth = IHDR [ 8 ]  , or 0x10 ， / channels is set by the following logic based off ， / IHDR->color_type , or 0x6 ， png_ptr->channels = 3 ， png_ptr->channels = 2 ， png_ptr->channels = 4 ， png_ptr->channels = 1 ， / row_info.pixel_depth = 0x10 * 4 ，  * deriving row_info.rowbytes *  ，  * \\-> deriving row_info.width *  ，  # pngread.c : png_read_row : line 392 ， row_info.width = png_ptr->iwidth ; / * NOTE : width of current interlaced row * / ， / png_ptr->iwidth is set in png_read_start_row ， / cliff notes here are , during the first interlace pass , width will be ， / divided by 8 , so 0x20000000 becomes 0x4000000 ， / actual computation is ( 0x20000000 + 8 - 1 - 0 ) / 8 )  ，  # pngrutil.c : png_read_start_row : line 4217 ， png_ptr->iwidth = ( png_ptr->width + / png_ptr->width = 0x20000000 ， png_pass_inc [ png_ptr->pass ] - 1 - ， png_pass_start [ png_ptr->pass ]  ) / ， png_pass_inc [ png_ptr->pass ]  ;  ， / png_ptr->iwidth = 0x4000000 ， / back to our original call for row_info.rowbytes ，  # pngread.c : png_read_row : line 397 ， row_info.rowbytes = PNG_ROWBYTES ( row_info.pixel_depth , row_info.width )  ;  ，  # pngpriv.h : line 659 ， / * Added to libpng-1.2.6 JB * /",
    "time": "2014-12-23 / 2015-01-23"
}