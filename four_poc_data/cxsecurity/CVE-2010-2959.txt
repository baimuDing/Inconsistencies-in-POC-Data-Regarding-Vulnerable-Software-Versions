{
    "text": "vul_name : Linux Kernel < 2.6.36-rc1 CAN BCM Privilege Escalation Exploit ， vul_cve : CVE-2010-2959 ， vul_poc : / *  ，  * i-CAN-haz-MODHARDEN.c ，  * Linux Kernel < 2.6.36-rc1 CAN BCM Privilege Escalation Exploit ，  * Jon Oberheide <jon @ oberheide.org> ，  * Information :  ，  * Ben Hawkes discovered an integer overflow in the Controller Area Network ，  *  ( CAN ) subsystem when setting up frame content and filtering certain ，  * messages. An attacker could send specially crafted CAN traffic to crash ，  * the system or gain root privileges. ，  * Usage :  ，  *  $ gcc i-can-haz-modharden.c -o i-can-haz-modharden ，  *  $ ./i-can-haz-modharden ，  * . ，  *  [ + ] launching root shell !  ，  *  # id ，  * uid=0 ( root ) gid=0 ( root )  ，  * Notes :  ，  * The allocation pattern of the CAN BCM module gives us some desirable ，  * properties for smashing the SLUB. We control the kmalloc with a 16-byte ，  * granularity allowing us to place our allocation in the SLUB cache of our ，  * choosing ( we'll use kmalloc-96 and smash a shmid_kernel struct for ，  * old-times sake ) . The allocation can also be made in its own discrete ，  * stage before the overwrite which allows us to be a bit more conservative ，  * in ensuring the proper layout of our SLUB cache. ，  * To exploit the vulnerability , we first create a BCM RX op with a crafted ，  * nframes to trigger the integer overflow during the kmalloc. On the second ，  * call to update the existing RX op , we bypass the E2BIG check since the ，  * stored nframes in the op is large , yet has an insufficiently sized ，  * allocation associated with it. We then have a controlled write into the ，  * adjacent shmid_kernel object in the 96-byte SLUB cache. ，  * However , while we control the length of the SLUB overwrite via a ，  * memcpy_fromiovec operation , there exists a memset operation that directly ，  * follows which zeros out last_frames , likely an adjacent allocation , with ，  * the same malformed length , effectively nullifying our shmid smash. To ，  * work around this , we take advantage of the fact that copy_from_user can ，  * perform partial writes on x86 and trigger an EFAULT by setting up a ，  * truncated memory mapping as the source for the memcpy_fromiovec operation ,  ，  * allowing us to smash the necessary amount of memory and then pop out and ，  * return early before the memset operation occurs. ，  * We then perform a dry-run and detect the shmid smash via an EIDRM errno ，  * from shmat (  ) caused by an invalid ipc_perm sequence number. Once we're ，  * sure we have a shmid_kernel under our control we re-smash it with the ，  * malformed version and redirect control flow to our credential modifying ，  * calls mapped in user space. ，  * Distros : please use grsecurity's MODHARDEN or SELinux's module_request ，  * to restrict unprivileged loading of uncommon packet families. Allowing ，  * the loading of poorly-written PF modules just adds a non-trivial and ，  * unnecessary attack surface to the kernel. ，  * Targeted for 32-bit Ubuntu Lucid 10.04 ( 2.6.32-21-generic )  , but ports ，  * easily to other vulnerable kernels/distros. Careful , it could use some ，  * post-exploitation stability love as well. ，  * Props to twiz , sgrakkyu , spender , qaaz , and anyone else I missed that ，  * this exploit borrows code from.",
    "time": "2010.09.13"
}