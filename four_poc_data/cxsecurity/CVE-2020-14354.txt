{
    "text": "vul_name : c-ares 1.16.0 Use-After-Free ， vul_cve : CVE-2020-14354 ， vul_poc : c-ares 1.16.0 : ares_destroy (  ) with pending ares_getaddrinfo (  ) leads to use-after-free ， The following code was introduced in c-ares commit dbd4c441 ( first released in 1.16.0 , which was published on 2020-03-13 )  , as part of the new ares_getaddrinfo (  ) feature :  ， static void end_hquery ( struct host_query * hquery , int status )  ， { ，  [ . ]  ， hquery->callback ( hquery->arg , status , hquery->timeouts , hquery->ai )  ;  ， ares_free ( hquery->name )  ;  ， ares_free ( hquery )  ;  ， } ， static void host_callback ( void * arg , int status , int timeouts ,  ， unsigned char * abuf , int alen )  ， { ， struct host_query * hquery = ( struct host_query *  ) arg ;  ， int addinfostatus = ARES_SUCCESS ;  ，  [ . ]  ，  [ . ]  ， { ， end_hquery ( hquery , status )  ;  ， } ， { ，  [ . ]  ， { ， / * at least one query ended with ARES_SUCCESS * / ， end_hquery ( hquery , ARES_SUCCESS )  ;  ， } ，  [ . ]  ， { ， end_hquery ( hquery , status )  ;  ， } ， } ， / * at this point we keep on waiting for the next query to finish * / ， } ， In the ARES_EDESTRUCTION case , host_callback (  ) ends up calling end_hquery (  ) twice ( unless it crashes before the second call )  , and the second call will , among other things , call a function pointer from freed memory and free the memory a second time. ， Here's a reproducer : ",
    "time": "2020-08-06 / 2021-05-14"
}