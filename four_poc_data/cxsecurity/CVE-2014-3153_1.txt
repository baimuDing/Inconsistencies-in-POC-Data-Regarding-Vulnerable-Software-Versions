{
    "text": "vul_name : Linux Kernel 3.14.5 futex local privilege escalation ， vul_cve : CVE-2014-3153 ， vul_poc : The futex_requeue function in kernel/futex.c in the Linux kernel through 3.14.5 does not ensure that calls have two different futex addresses , which allows local users to gain privileges via a crafted FUTEX_REQUEUE command that facilitates unsafe waiter modification. ， If uaddr = uaddr2 , then we have broken the rule of only requeueing from ， a non-pi futex to a pi futex with this call. If we attempt this , then ， dangling pointers may be left for rt_waiter resulting in an exploitable ， condition. ， This change brings futex_requeue (  ) in line with futex_wait_requeue_pi (  )  ， which performs the same check as per commit 6f7b0a2a5c0f ( \"futex : Forbid ， uaddr = uaddr2 in futex_wait_requeue_pi (  ) \" )  ，  [ tglx : Compare the resulting keys as well , as uaddrs might be ， different depending on the mapping ]  ， Fixes CVE-2014-3153. ， -rw-r-r- kernel/futex.c 25 ， 1 files changed , 25 insertions , 0 deletions ， diff -git a/kernel/futex.c b/kernel/futex.c ， index 81dbe77.663ea2b 100644 ， - a/kernel/futex.c ， + b/kernel/futex.c ， -1442 , 6 +1442 , 13 static int futex_requeue ( u32 _user * uaddr1 , unsigned int flags ,  ， + * Requeue PI only works on two distinct uaddrs. This ， + * check is only valid for private futexes. See below. ， + * / ， + if ( uaddr1 = uaddr2 )  ， + return -EINVAL ;  ， + ， + / *  ，  * requeue_pi requires a pi_state , try to allocate it now ，  * without any locks in case it fails. ， -1479 , 6 +1486 , 15 retry :  ， goto out_put_key1 ;  ， + / *  ， + * The check above which compares uaddrs is not sufficient for ， + * shared futexes. We need to compare the keys :  ， + * / ， + if ( requeue_pi match_futex ( &key1 , &key2 ) { ， + ret = -EINVAL ;  ， + goto out_put_keys ;  ， + } ， + ， hb1 = hash_futex ( &key1 )  ;  ， hb2 = hash_futex ( &key2 )  ;  ， -2525 , 6 +2541 , 15 static int futex_wait_requeue_pi ( u32 _user * uaddr , unsigned int flags ,  ， goto out_key2 ;  ， + / *  ， + * The check above which compares uaddrs is not sufficient for ， + * shared futexes. We need to compare the keys :  ， + * / ， + if ( match_futex ( &q.key , &key2 ) { ， + ret = -EINVAL ;  ， + goto out_put_keys ;  ， + } ， + ， / * Queue the futex_q , drop the hb lock , wait for wakeup. * / ， futex_wait_queue_me ( hb , &q , to )  ; ",
    "time": "2014.06.08"
}