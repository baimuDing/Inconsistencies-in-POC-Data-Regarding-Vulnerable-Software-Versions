{
    "text": "vul_name : libotr 4.1.0 Memory Corruption ， vul_cve : CVE-2016-2851 ， vul_poc : X41 D-Sec GmbH Security Advisory : X41-2016-001 ， Memory Corruption Vulnerability in \"libotr\" ， Overview ， Severity Rating : high ， Confirmed Affected Version : 4.1.0 and below ， Confirmed Patched Version : libotr 4.1.1 ， Vendor : OTR Development Team ， Vendor URL :  ， Vendor ， Vector : Remote ， Credit : X41 D-Sec GmbH , Markus Vervier ， Status : public ， CVE : CVE-2016-2851 ， CVSS Score : 8.1 ( High )  ， CVSS Vector : CVSS : 3.0/AV : N/AC : H/PR : N/UI : N/S : U/C : H/I : H/A : H ， Advisory-URL :  ， Summary and Impact ， A remote attacker may crash or execute arbitrary code in libotr by ， sending large OTR messages. ， While processing specially crafted messages , attacker controlled data on ， the heap is written out of bounds. ， No special user interaction or authorization is necessary in default ， configurations. ， Product Description ， Off-the-Record ( OTR ) Messaging is a cryptographic protocol used in ， well-known instant messaging clients such as Pidgin , ChatSecure , Adium ， and others. It is designed to work on top of existing protocols and used ， worldwide to provide secure communication in insecure environments. ， OTR is regarded as highly secure and according to documents revealed by ， Edward Snowden one of the protocols that the NSA is not able to decrypt ， via cryptanalysis. ， The most commonly used implementation of OTR is \"libotr\" which is a pure ， C code implementation of the OTR protocol. ， Analysis ， During a manual code review X41 D-Sec GmbH discovered a remotely ， exploitable vulnerability in libotr. ， By sending large messages , an integer overflow can be triggered which ， subsequently leads to a heap overflow on 64 bit architectures. ， When a message of type OTRL_MSGSTATE_DATA is received during an ， established OTR conversation , this message is passed to function ， otrl_proto_accept_data in src/message.c line 1347 :  ， case OTRL_MSGSTATE_ENCRYPTED :  ， extrakey = gcry_malloc_secure ( OTRL_EXTRAKEY_BYTES )  ;  ， err = otrl_proto_accept_data ( &plaintext , &tlvs , context ,  ， message , &flags , extrakey )  ;  ， After base64 decoding the message and reading various values from it ,  ， the length of a payload is read into a variable of type \"unsigned int\" ， in file proto.c line 784 :  ， read_int ( datalen )  ;  ， It is checked that the message buffer will contain at least a \"datalen\" ， number of bytes using read_int in proto.c line 785 :  ， require_len ( datalen )  ;  ， The macros \"read_int\" and \"required_len\" are defined in src/serial.h : ",
    "time": "2016.03.11"
}