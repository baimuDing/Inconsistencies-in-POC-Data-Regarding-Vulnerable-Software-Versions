{
    "text": "vul_name : MiniUPnP MiniUPnPc < 2.0 Remote Denial of Service ， vul_cve : CVE-2017-8798 ， vul_poc : VuNote ， Author : <github.com/tintinweb> ， Ref :  ， Version : 0.6 ， Date : May 1st , 2017 ， Tag : miniupnpc getHTTPResponse chunked encoding integer signedness error ， Overview ， Name : miniupnpc ， Vendor : Thomas Bernard ， Version : v2.0 [ 2 ]  ， Latest Version : v2.0.20170421 [ 2 ]  [ 3 ]  ， Other Versions : >= v1.4.20101221 [ 2 ]  ( released 21/12/2010 ;  ~ 6 years ago )  ， Platform ( s )  : cross ， Technology : c ， Vuln Classes : CWE-196 , CWE-190 ， Origin : remote ， Min. Privs. : - ， CVE : CVE-2017-8798 ， Description ， quote website [ 1 ]  ， >UPnP IGD client lightweight library and UPnP IGD daemon ， >The UPnP protocol is supported by most home adsl/cable routers and Microsoft Windows 2K/XP. The aim of the MiniUPnP project is to bring a free software solution to support the \"Internet Gateway Device\" part of the protocol. The MediaServer/MediaRenderer UPnP protocol ( DLNA ) is also becoming very popular but here we are talking about IGD. ReadyMedia ( formely known as MiniDLNA ) is a UPnP Media Server using some UPnP code from MiniUPnPd. ， miniupnp is part of many applications and embedded network devices ，  * P2P File Sharing software - e.g. qBittorrent ，  * Network Device Firmware ，  * Blockchain clients - e.g. EthereumCPP , bitcoind and forked coins ， Summary ，  * TL ; DR - one-click crash miniupnpc based applications on your network *  ， Integer signedness error in miniupnpc allows remote attackers to ， cause a denial of service condition via specially crafted HTTP response ， An integer signedness error was found in miniupnp's `miniwget` allowing ， an unauthenticated remote entity typically located on the ， local network segment to trigger a heap corruption or an access violation ， in miniupnp's http response parser when processing a specially crafted ， chunked-encoded response to a request for the xml root description url. ， To exploit this vulnerability , an attacker only has to provide a ， chunked-encode HTTP response with a negative chunk length to upnp ， clients requesting a resource on the attackers webserver. Upnp clients ， can easily be instructed to request resources on the attackers webserver ， by answering SSDP discovery request or by issueing SSDP service ， notifications ( low complexity , integral part of the protocol ) . ，  * remote , unauthenticated , `ACCESS_VIOLATION_READ` and heap corruption ，  *  ( confirmed ) DoS ;  ( unconfirmed ) could also lead to RCE under certain ， circumstances ( multi-threaded? )  ， see attached PoC ， see proposed patch ， Details ， The vulnerable component is a HTTP file download method called ， `miniwget` ( precisely `getHTTPResponse` ) that fails to properly handle ， invalid chunked-encoded HTTP responses. The root cause is a bounds check ， that mistakenly casts an unsigned attacker-provided chunksize to signed ， int leading to an incorrect decision on the destination heap buffer size ， when copying data from the server response to an internal buffer. The ， attacker controls both the size of the internal buffer as well as the ， number of bytes to copy. In order for this attack to succeed , the number ， of bytes to copy must be negative. ， attacker controls :  ，  * `int content_length` ，  * `unsigned int chunksize` ，  * `bytestocopy` if ` ( int ) chunksize` is negative ( or at least < `n-i` ~ 1900 bytes )  ，  * length of `content_buf` if `bytestocopy` is negative ， In the end , the attacker controls ，  * `realloc ( content_buf , content_length ) ` ，  * `memcpy ( content_buf+x , http_response , chunksize ) ` ， client ( miniupnpc ) server ( poc.py )  ，  | SSDP : Discovery - M-SEARCH |  ， 1. | -> |  ，  | SSDP : Reply - Location Header |  ， 2. | <- |  ，  | SCPD : GET ( Location Header/xx.xml )  |  ， 3. | -> |  ，  | SCPD : HTTP chunked-encoded reply |  ， 4. | <- |  ， 1. application performs SSDP discovery via M-SEARCH ( multicast , local network segment )  ， 2. poc.py responds with the url to the xml root description requesting the application to navigate to the malicious webserver. ， 3. application requests xml root description url ( taken from reply to M-SEARCH , Location Header ) on malicious webserver ( poc.py )  ， 4. poc.py responds with a specially crafted http response triggering the heap overwrite in miniupnp ， Source ， `miniwget.c : 236` [ 4 ]  ，  * Note :  * Inline annotations are prefixed with / #  !  ，  * A ) 1. to 3. is the parsing of the chunksize ，  * B ) 4. to 5. integer signedness error ，  * C ) 6. integer wrapping ，  * D ) 7. to 9. destination buffer size ，  * E ) 10. heap overwrite with size in bytestocopy ， `c ， / * content * / ， { ， int i = 0 ;  ， { ， { ， / * reading chunk size * / ， / * skipping any leading CR LF * / ， } ， chunksize_buf_index < ( sizeof ( chunksize_buf ) -1 )  ， { ， chunksize_buf [ chunksize_buf_index+ ] = buf [ i ]  ;  ， chunksize_buf [ chunksize_buf_index ] = '\\0' ;  ， i+ ;  ， } ， i+ ; / * discarding chunk-extension * / ， unsigned int j ;  ， chunksize_buf [ j ] <= '9' )  ， chunksize = ( chunksize 4 ) + ( chunksize_buf [ j ] - '0' )  ;  ， chunksize = ( chunksize 4 ) + ( chunksize_buf [ j ]  | 32 ) - 'a' + 10 )  ;  ， } ， chunksize_buf [ 0 ] = '\\0' ;  ， chunksize_buf_index = 0 ;  ， i+ ;  ， } else { ， / * not finished to get chunksize * / ， } ，  # ifdef DEBUG ， printf ( \"chunksize = %u ( %x ) \\n\" , chunksize , chunksize )  ;  ，  # endif ， { ，  # ifdef DEBUG ， printf ( \"end of HTTP content - %d %d\\n\" , i , n )  ;  ， / * printf ( \"'%. * s'\\n\" , n-i , buf+i )  ;  * / ，  # endif ， goto end_of_stream ;  ， } ， } ， / #  ! 4 )  ， / #  ! goal : a ) bytestocopy becomes negative due to chunksize being negative ， / #  ! b ) content_length defines destination buffer size ， / #  ! c ) overwrite destination heap buffer content_buf [ content_length ] with bytestocopy bytes from request ， / #  ! memcopy ( content_buf [ content_length ]  , req_body ,  ( unsigned ) bytestocopy )  ， bytestocopy = ( int ) chunksize < ( n - i ) ?chunksize :  ( unsigned int )  ( n - i )  ; / #  ! 5 ) boom ! - bytestocopy becomes chunksize since chunksize is negative ( e.g. -1 )  ， { ， char * tmp ;  ， content_buf_len = content_length ; / #  ! 8 ) we want content_length to define our dst buffer size ( e.g. 9000 )  ， } else { / #  ! if we dont hit this , content_buf_len would likely be ~ 2k ， content_buf_len = content_buf_used + bytestocopy ;  ， } ， tmp = realloc ( content_buf , content_buf_len )  ; / #  ! 9 ) realloc to content_length bytes ( e.g. 9000 )  ， / * memory allocation error * / ， free ( content_buf )  ;  ， free ( header_buf )  ;  ，  * size = -1 ;  ， } ， content_buf = tmp ;  ， } ， memcpy ( content_buf + content_buf_used , buf + i , bytestocopy )  ; / #  ! 10 ) boom heap overwrite with bytesttocopy bytes ( e.g. ( unsigned ) -1 ) to content_length ( e.g. 9000 ) sized buffer ， content_buf_used += bytestocopy ; / #  !  ( also an out of bounds ready since it has not been checked if buf holds enough bytes )  ， i += bytestocopy ;  ， chunksize -= bytestocopy ;  ， } ， } ， ` ， Taint Graph ， basically all `miniwget * ` and `UPNP_ * ` methods. ，  * getHTTPResponse ( vulnerable )  ，  * miniwget3 ，  * miniwget2 ，  * miniwget ，  * miniwget_getaddr ，  * UPNP_GetIGDFromUrl ，  * UPNP_GetValidIGD ，  * UPnP_selectigd ，  * UPNP_Get *  ，  * UPNP_Check *  ，  * UPNP_Delete *  ，  * UPNP_Update *  ，  * UPNP_Add *  ， Scenarios ， The PoC can be configured for three scenarios :  ， 1 ) SCENARIO_CRASH_LARGE_MEMCPY ， Similar to 3 ) attempts to smash the heap but likely fails with an ， `ACCESS_VIOLATION_READ` when trying to read from an non-accessible ， memory region. ，  ( gdb ) up ，  # 1 0x000000000040862c in getHTTPResponse ( s=s @ entry=3 , size=size @ entry=0x7fffffffd77c ,  ， status_code=status_code @ entry=0x0 ) at miniwget.c : 305 ， 305 memcpy ( content_buf + content_buf_used , buf + i , bytestocopy )  ;  ，  ( gdb ) i lo ， i = 30 ， buf = \"f\\r\\n<xml>BOOM</xml>\\r\\n80000000\\r\\n\" , 'A' <repeats 2018 times> ， n = 1954 ， endofheaders = 94 ， chunked = 1 ， content_length = 9041 ， chunksize = 2147483648 ， bytestocopy = 2147483648 / #  ! <- nr of bytes to copy from buf",
    "time": "2018.01.12"
}