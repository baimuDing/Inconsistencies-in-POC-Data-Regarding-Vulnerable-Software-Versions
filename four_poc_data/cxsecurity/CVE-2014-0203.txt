{
    "text": "vul_name : Linux kernel 2.6.32 local denial of service ， vul_cve : CVE-2014-0203 ， vul_poc : The _do_follow_link function in fs/namei.c in the Linux kernel before 2.6.33 does not properly handle the last pathname component during use of certain filesystems , which allows local users to cause a denial of service ( incorrect free operations and system crash ) via an open system call. ， fix autofs/afs/etc. magic mountpoint breakage ， We end up trying to kfree (  ) nd.last.name on open ( \"/mnt/tmp\" , O_CREAT ) if /mnt/tmp is an autofs direct mount. The reason is that nd.last_type is bogus here ; we want LAST_BIND for everything of that kind and we get LAST_NORM left over from finding parent directory. So make sure that it * is * set properly ; set to LAST_BIND before doing ->follow_link (  ) - for normal symlinks it will be changed by _vfs_follow_link (  ) and everything else needs it set that way. ， diff -git a/fs/namei.c b/fs/namei.c ， index b55440b.1b26b16 100644 ， - a/fs/namei.c ， + b/fs/namei.c ， -561 , 6 +561 , 7 static _always_inline int _do_follow_link ( struct path * path , struct nameidata ， dget ( dentry )  ;  ， } ， mntget ( path->mnt )  ;  ， + nd->last_type = LAST_BIND ;  ， cookie = dentry->d_inode->i_op->follow_link ( dentry , nd )  ;  ， error = PTR_ERR ( cookie )  ;  ， diff -git a/fs/proc/base.c b/fs/proc/base.c ， index 18d5cc6.e42bbd8 100644 ， - a/fs/proc/base.c ， + b/fs/proc/base.c ， -1419 , 7 +1419 , 6 static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd )  ， goto out ;  ， error = PROC_I ( inode ) ->op.proc_get_link ( inode , &nd->path )  ;  ， - nd->last_type = LAST_BIND ;  ， out :  ， }",
    "time": "2014.06.23"
}