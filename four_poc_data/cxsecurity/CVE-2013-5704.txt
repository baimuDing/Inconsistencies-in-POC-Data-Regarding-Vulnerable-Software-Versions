{
    "text": "vul_name : Apache HTTPD 2.2.22/ModSecurity 2.7.5 bypass RequestHeader unset ， vul_cve : CVE-2013-5704 , CVE-2013-5705 ， vul_poc : Chunked HTTP transfer encoding ， Back in the days before websockets , and even XHR , something called Chunked encoding or chunked http responses were used to achieve a server->client callback. I once wrote a chat server , based on the following concept ; the client loads resources from a common webserver , a.chatserver.com , which also sets its domain to chatserver.com. That page also loads a script from b.chatserver.com. That script also sets its domain to chatserver.com - just to clear any SOP issues. At b.chatserver.com , we had a tcp server listening , which allowed us to keep an open tcp socket towards the client , and could use to send javascript snippets , for example messageReceived ( 'foobar' )  ， By using chunked responses , the actual tcp traffic would look something like this :  ， HTTP 200 OK ， Transfer-Encoding : chunked ， 20 ， document.domain='chatserver.com' ， . some time later . ， FA ， messageReceived ( 'hello' )  ;  ， As far as I can tell , this is designed mostly just as a mechanism to allow a server to stream data to a client. I don't know to what extent a browser has ever been coerced into sending chunked requests to a server. However , the protocol defines this as a bi-directional mechanism , it can be used by the client as well as the server. ， Diving into chunked HTTP requests ， For whatever reason , I happened to check out the source code for a part of Netty , the HttpChunkAggregator. The way Netty does things is that it has various handlers for upstream or downstream traffic , organised throgh a pipe , and one of these handlers can unchunk http requests that arrive in chunks.",
    "time": "2014.04.16"
}