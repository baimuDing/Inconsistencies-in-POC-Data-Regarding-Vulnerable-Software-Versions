{
    "text": "vul_name : macOS/iOS Kernel 10.12.3 Double-Free Due to Bad Locking in fsevents Device ， vul_cve : CVE-2017-2490 ， vul_poc : / *  ， fseventsf_ioctl handles ioctls on fsevent fds acquired via FSEVENTS_CLONE_64 on /dev/fsevents ， Heres the code for the FSEVENTS_DEVICE_FILTER_64 ioctl :  ， case FSEVENTS_DEVICE_FILTER_64 :  ， ret = EINVAL ;  ， } ， devfilt_args = ( fsevent_dev_filter_args64 *  ) data ;  ， handle_dev_filter :  ， { ， int new_num_devices ;  ， dev_t * devices_not_to_watch ,  * tmp=NULL ;  ， ret = EINVAL ;  ， } ， new_num_devices = devfilt_args->num_devices ;  ， tmp = fseh->watcher->devices_not_to_watch ; <- ( a )  ， lock_watch_table (  )  ; <- ( b )  ， fseh->watcher->devices_not_to_watch = NULL ;  ， fseh->watcher->num_devices = new_num_devices ;  ， unlock_watch_table (  )  ; <- ( c )  ， FREE ( tmp , M_TEMP )  ; <- ( d )  ， } ， } ， There's nothing stopping two threads seeing the same value for devices_not_to_watch at ( a )  ,  ， assigning that to tmp then freeing it at ( d ) . The lock/unlock at ( b ) and ( c ) don't protect this. ， This leads to a double free , which if you also race allocations from the same zone can lead to an ， exploitable kernel use after free. ， /dev/fsevents is :  ， crw-r-r- 1 root wheel 13 , 0 Feb 15 14 : 00 /dev/fsevents ， so this is a privesc from either root or members of the wheel group to kernel ， tested on MacOS 10.12.3 ( 16D32 ) on MacbookAir5 , 2 ，  ( build with -O3 )  ， The open handler for the fsevents device node has a further access check :  ， } ， restricting this issue to root only despite the permissions on the device node ( which is world-readable )  ， / ianbeer ，  # if 0 ， MacOS/iOS kernel double free due to bad locking in fsevents device ， fseventsf_ioctl handles ioctls on fsevent fds acquired via FSEVENTS_CLONE_64 on /dev/fsevents ， Heres the code for the FSEVENTS_DEVICE_FILTER_64 ioctl :  ， case FSEVENTS_DEVICE_FILTER_64 :  ， ret = EINVAL ;  ， } ， devfilt_args = ( fsevent_dev_filter_args64 *  ) data ;  ， handle_dev_filter :  ， { ， int new_num_devices ;  ， dev_t * devices_not_to_watch ,  * tmp=NULL ;  ， ret = EINVAL ;  ， } ， new_num_devices = devfilt_args->num_devices ;  ， tmp = fseh->watcher->devices_not_to_watch ; <- ( a )  ， lock_watch_table (  )  ; <- ( b )  ， fseh->watcher->devices_not_to_watch = NULL ;  ， fseh->watcher->num_devices = new_num_devices ;  ， unlock_watch_table (  )  ; <- ( c )  ， FREE ( tmp , M_TEMP )  ; <- ( d )  ， } ， } ， There's nothing stopping two threads seeing the same value for devices_not_to_watch at ( a )  ,  ， assigning that to tmp then freeing it at ( d ) . The lock/unlock at ( b ) and ( c ) don't protect this. ， This leads to a double free , which if you also race allocations from the same zone can lead to an ， exploitable kernel use after free. ， /dev/fsevents is :  ， crw-r-r- 1 root wheel 13 , 0 Feb 15 14 : 00 /dev/fsevents ， so this is a privesc from either root or members of the wheel group to kernel ， tested on MacOS 10.12.3 ( 16D32 ) on MacbookAir5 , 2 ，  ( build with -O3 )  ，  # endif",
    "time": "2017.04.05"
}