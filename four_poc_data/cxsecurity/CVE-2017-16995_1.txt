{
    "text": "vul_name : Linux >= 4.9 eBPF memory corruption bugs ， vul_cve : CVE-2017-16995 , CVE-2017-16996 ， vul_poc : A few BPF verifier bugs in the Linux kernel , most of which can be used ， One of the bugs was introduced in 4.9 , the others were only introduced ， in 4.14. ， The fixes are in the net tree of the Linux kernel ， but not in Linus' tree yet. ， The following bug was introduced in 4.9 :  ， = fixed by \"bpf : fix incorrect sign extension in check_alu_op (  ) \" = ， check_alu_op (  ) did not distinguish between ， BPF_ALU64 | BPF_MOV | BPF_K ( load 32-bit immediate , sign-extended to 64-bit )  ， and BPF_ALU | BPF_MOV | BPF_K ( load 32-bit immediate , zero-padded to 64-bit )  ;  ， it performed sign extension in both cases. ， Debian assigned CVE-2017-16995 for this issue. ， The following bugs were introduced in 4.14 :  ， = fixed by \"bpf/verifier : fix bounds calculation on BPF_RSH\" = ， Incorrect signed bounds were being computed for BPF_RSH. ， If the old upper signed bound was positive and the old lower signed bound was ， negative , this could cause the new upper signed bound to be too low ,  ， leading to security issues. ， = fixed by \"bpf : fix incorrect tracking of register size truncation\" = ， The BPF verifier did not properly handle register truncation to a smaller size. ， The old code first mirrors the clearing of the high 32 bits in the bitwise ， tristate representation , which is correct. But then , it computes the new ， arithmetic bounds as the intersection between the old arithmetic bounds and ， the bounds resulting from the bitwise tristate representation. Therefore ,  ， when coerce_reg_to_32 (  ) is called on a number with bounds ，  [ 0xffff'fff8 , 0x1'0000'0007 ]  , the verifier computes ，  [ 0xffff'fff8 , 0xffff'ffff ] as bounds of the truncated number. ， This is incorrect : The truncated number could also be in the range [ 0 , 7 ]  ,  ， and no meaningful arithmetic bounds can be computed in that case apart from ， the obvious [ 0 , 0xffff'ffff ] . ， Debian assigned CVE-2017-16996 for this issue. ， = fixed by \"bpf : fix 32-bit ALU op verification\" = ， adjust_scalar_min_max_vals (  ) only truncates its inputs and otherwise operates on ， 64-bit numbers while the BPF interpreter and JIT perform 32-bit arithmetic. ， This means that the output of e.g. ` ( u32 ) 0x40000000 *  ( u32 ) 5` will be incorrect.",
    "time": "2017.12.21"
}