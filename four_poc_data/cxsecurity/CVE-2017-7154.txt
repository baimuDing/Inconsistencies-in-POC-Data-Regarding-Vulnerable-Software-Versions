{
    "text": "vul_name : macOS process_policy Stack Leak Through Uninitialized Field ， vul_cve : CVE-2017-7154 ， vul_poc : / *  ， The syscall ， process_policy ( scope=PROC_POLICY_SCOPE_PROCESS , action=PROC_POLICY_ACTION_GET , policy=PROC_POLICY_RESOURCE_USAGE , policy_subtype=PROC_POLICY_RUSAGE_CPU , attrp=<userbuf> , target_pid=0 , target_threadid=<ignored> )  ， causes 4 bytes of uninitialized kernel stack memory to be written to userspace. ， The call graph looks as follows :  ， process_policy ， handle_cpuuse ， proc_get_task_ruse_cpu ， task_get_cpuusage ，  [ writes scope=1/2/4/0 ]  ，  [ always returns zero ]  ，  [ writes policyp if scope ! =0 ]  ，  [ always returns zero ]  ， copyout ， If task_get_cpuusage (  ) set ` * scope=0` because none of the flags ， TASK_RUSECPU_FLAGS_PERTHR_LIMIT , TASK_RUSECPU_FLAGS_PROC_LIMIT and TASK_RUSECPU_FLAGS_DEADLINE are set in task->rusage_cpu_flags ,  ， proc_get_task_ruse_cpu (  ) does not write anything into ` * policyp` , meaning that `cpuattr.ppattr_cpu_attr` in ， handle_cpuuse (  ) remains uninitialized. task_get_cpuusage (  ) and proc_get_task_ruse_cpu (  ) always return zero ,  ， so handle_cpuuse (  ) will copy `cpuattr` , including the unititialized `ppattr_cpu_attr` field , to userspace. ， Tested on a Macmini7 , 1 running macOS 10.13 ( 17A405 )  , Darwin 17.0.0 :  ，  $ cat test.c",
    "time": "2018.01.12"
}