{
    "text": "vul_name : iOS/MacOSX/AppleTV man-in-the-middle attack ， vul_cve : CVE-2014-1266 ， vul_poc : Yesterday , Apple pushed a rather spooky security update for iOS that suggested that something was horribly wrong with SSL/TLS in iOS but gave no details. Since the answer is at the top of the Hacker News thread , I guess the cat's out of the bag already and we're into the misinformation-quashing stage now. ， So here's the Apple bug :  ， static OSStatus ， SSLVerifySignedServerKeyExchange ( SSLContext * ctx , bool isRsa , SSLBuffer signedParams ,  ， uint8_t * signature , UInt16 signatureLen )  ， { ， OSStatus err ;  ， . ， goto fail ;  ， goto fail ;  ， goto fail ;  ， goto fail ;  ， . ， fail :  ， SSLFreeBuffer ( &signedHashes )  ;  ， SSLFreeBuffer ( &hashCtx )  ;  ， } ，  ( Quoted from Apple's published source code. )  ， Note the two goto fail lines in a row. The first one is correctly bound to the if statement but the second , despite the indentation , isn't conditional at all. The code will always jump to the end from that second goto , err will contain a successful value because the SHA1 update operation was successful and so the signature verification will never fail. ， This signature verification is checking the signature in a ServerKeyExchange message. This is used in DHE and ECDHE ciphersuites to communicate the ephemeral key for the connection. The server is saying & # 8220 ; here's the ephemeral key and here's a signature , from my certificate , so you know that it's from me& # 8221 ; . Now , if the link between the ephemeral key and the certificate chain is broken , then everything falls apart. It's possible to send a correct certificate chain to the client , but sign the handshake with the wrong private key , or not sign it at all ! There's no proof that the server possesses the private key matching the public key in its certificate. ， Since this is in SecureTransport , it affects iOS from some point prior to 7.0.6 ( I confirmed on 7.0.4 ) and also OS X ( confirmed on 10.9.1 ) . It affects anything that uses SecureTransport , which is most software on those platforms although not Chrome and Firefox , which both use NSS for SSL/TLS. However , that doesn't mean very much if , say , the software update systems on your machine might be using SecureTransport. ， I coded up a very quick test site at Note the port number ( which is the CVE number )  , the normal site is running on port 443 and that is expected to work. On port 1266 the server is sending the same certificates but signing with a completely different key. If you can load an HTTPS site on port 1266 then you have this bug. ， Because the certificate chain is correct and it's the link from the handshake to that chain which is broken , I don't believe any sort of certificate pinning would have stopped this. Also , this doesn't only affect sites using DHE or ECDHE ciphersuites - the attacker gets to choose the ciphersuite in this case and will choose the one that works for them. ， Also , this doesn't affect TLS 1.2 because there's a different function for verifying the different ServerKeyExchange message in TLS 1.2. But , again , the attacker can choose any version that the client will accept. But if the client only enables TLS 1.2 then it appears that would workaround this issue. Likewise , if the client only enabled the plain , RSA ciphersuites then there's no ServerKeyExchange and that should also work around this issue. ( Of the two , the former workaround is much more preferable. )  ， Based on my test site , iOS 7.0.6 does fix the issue but OS X 10.9.1 is still affected. ( Update : it looks like the bug was introduced in 10.9 for OS X but existed in at least some versions of iOS 6. iOS 6.1.6 was released yesterday to fix it. )  ， This sort of subtle bug deep in the code is a nightmare. I believe that it's just a mistake and I feel very bad for whomever might have slipped in an editor and created it. ， Here's a stripped down that code with the same issue :  ， extern int f (  )  ;  ， int g (  ) { ， int ret = 1 ;  ， goto out ;  ， ret = f (  )  ;  ， out :  ， } ， If I compile with -Wall ( enable all warnings )  , neither GCC 4.8.2 or Clang 3.3 from Xcode make a peep about the dead code. That's surprising to me. A better warning could have stopped this but perhaps the false positive rate is too high over real codebases? ( Thanks to Peter Nelson for pointing out the Clang does have -Wunreachable-code to warn about this , but it's not in -Wall. )  ， Maybe the coding style contributed to this by allowing ifs without braces , but one can have incorrect indentation with braces too , so that doesn't seem terribly convincing to me. ， A test case could have caught this , but it's difficult because it's so deep into the handshake. One needs to write a completely separate TLS stack , with lots of options for sending invalid handshakes. In Chromium we have a patched version of TLSLite to do this sort of thing but I cannot recall that we have a test case for exactly this. ( Sounds like I know what my Monday morning involves if not. )  ， Code review can be effective against these sorts of bug. Not just auditing , but review of each change as it goes in. I've no idea what the code review culture is like at Apple but I strongly believe that my colleagues , Wan-Teh or Ryan Sleevi , would have caught it had I slipped up like this. Although not everyone can be blessed with folks like them. ， Lastly , there was a lot of discussion yesterday that Apple missed checking the hostname in the certificate. It's true that curl on the OS X command line oddly accepts HTTPS connections to IP addresses when the IP address isn't in the certificate , but I can't find that there's anything more than that and Safari doesn't have that problem.",
    "time": "2014-02-23 / 2014-02-24"
}